// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.21.2
// Changes made to this file will not be saved.
// SourceHash: 9aaed620a14ebc220cf8e270edab42b58bb9ae08e56052b6bafea920eaf4e6cc

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals, clippy::too_many_arguments)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry {
    Amg,
    AmgPack,
    BlockPrecond,
    DotProduct,
    DotProductPair,
    GeneratedDpInitIncompressibleMomentum,
    GeneratedDpUpdateFromDiagIncompressibleMomentum,
    GeneratedFluxModuleCompressible,
    GeneratedFluxModuleGradientsCompressible,
    GeneratedFluxModuleGradientsIncompressibleMomentum,
    GeneratedFluxModuleIncompressibleMomentum,
    GeneratedGenericCoupledApply,
    GeneratedGenericCoupledAssemblyCompressible,
    GeneratedGenericCoupledAssemblyGenericDiffusionDemo,
    GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann,
    GeneratedGenericCoupledAssemblyGradStateCompressible,
    GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo,
    GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann,
    GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum,
    GeneratedGenericCoupledAssemblyIncompressibleMomentum,
    GeneratedGenericCoupledUpdateCompressible,
    GeneratedGenericCoupledUpdateGenericDiffusionDemo,
    GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann,
    GeneratedGenericCoupledUpdateIncompressibleMomentum,
    GeneratedPackedStateGradientsCompressible,
    GeneratedPackedStateGradientsGenericDiffusionDemo,
    GeneratedPackedStateGradientsGenericDiffusionDemoNeumann,
    GeneratedPackedStateGradientsIncompressibleMomentum,
    GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum,
    GeneratedRhieChowGradPUpdateIncompressibleMomentum,
    GeneratedRhieChowStoreGradPIncompressibleMomentum,
    GenericCoupledSchurSetup,
    GmresCgs,
    GmresLogic,
    GmresOps,
    LinearSolver,
    OuterConvergence,
    Scalars,
    SchurPrecond,
    SchurPrecondGeneric,
}
impl ShaderEntry {
    pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout {
        match self { Self :: Amg => amg :: create_pipeline_layout (device) , Self :: AmgPack => amg_pack :: create_pipeline_layout (device) , Self :: BlockPrecond => block_precond :: create_pipeline_layout (device) , Self :: DotProduct => dot_product :: create_pipeline_layout (device) , Self :: DotProductPair => dot_product_pair :: create_pipeline_layout (device) , Self :: GeneratedDpInitIncompressibleMomentum => generated :: dp_init_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedDpUpdateFromDiagIncompressibleMomentum => generated :: dp_update_from_diag_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleCompressible => generated :: flux_module_compressible :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleGradientsCompressible => generated :: flux_module_gradients_compressible :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleGradientsIncompressibleMomentum => generated :: flux_module_gradients_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleIncompressibleMomentum => generated :: flux_module_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledApply => generated :: generic_coupled_apply :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyCompressible => generated :: generic_coupled_assembly_compressible :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemo => generated :: generic_coupled_assembly_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann => generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateCompressible => generated :: generic_coupled_assembly_grad_state_compressible :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo => generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann => generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum => generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyIncompressibleMomentum => generated :: generic_coupled_assembly_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateCompressible => generated :: generic_coupled_update_compressible :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemo => generated :: generic_coupled_update_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann => generated :: generic_coupled_update_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateIncompressibleMomentum => generated :: generic_coupled_update_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsCompressible => generated :: packed_state_gradients_compressible :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsGenericDiffusionDemo => generated :: packed_state_gradients_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsGenericDiffusionDemoNeumann => generated :: packed_state_gradients_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsIncompressibleMomentum => generated :: packed_state_gradients_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum => generated :: rhie_chow_correct_velocity_delta_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedRhieChowGradPUpdateIncompressibleMomentum => generated :: rhie_chow_grad_p_update_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedRhieChowStoreGradPIncompressibleMomentum => generated :: rhie_chow_store_grad_p_incompressible_momentum :: create_pipeline_layout (device) , Self :: GenericCoupledSchurSetup => generic_coupled_schur_setup :: create_pipeline_layout (device) , Self :: GmresCgs => gmres_cgs :: create_pipeline_layout (device) , Self :: GmresLogic => gmres_logic :: create_pipeline_layout (device) , Self :: GmresOps => gmres_ops :: create_pipeline_layout (device) , Self :: LinearSolver => linear_solver :: create_pipeline_layout (device) , Self :: OuterConvergence => outer_convergence :: create_pipeline_layout (device) , Self :: Scalars => scalars :: create_pipeline_layout (device) , Self :: SchurPrecond => schur_precond :: create_pipeline_layout (device) , Self :: SchurPrecondGeneric => schur_precond_generic :: create_pipeline_layout (device) , }
    }
    pub fn create_shader_module_embed_source(&self, device: &wgpu::Device) -> wgpu::ShaderModule {
        match self { Self :: Amg => { amg :: create_shader_module_embed_source (device) } , Self :: AmgPack => { amg_pack :: create_shader_module_embed_source (device) } , Self :: BlockPrecond => { block_precond :: create_shader_module_embed_source (device) } , Self :: DotProduct => { dot_product :: create_shader_module_embed_source (device) } , Self :: DotProductPair => { dot_product_pair :: create_shader_module_embed_source (device) } , Self :: GeneratedDpInitIncompressibleMomentum => { generated :: dp_init_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedDpUpdateFromDiagIncompressibleMomentum => { generated :: dp_update_from_diag_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleCompressible => { generated :: flux_module_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleGradientsCompressible => { generated :: flux_module_gradients_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleGradientsIncompressibleMomentum => { generated :: flux_module_gradients_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleIncompressibleMomentum => { generated :: flux_module_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledApply => { generated :: generic_coupled_apply :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyCompressible => { generated :: generic_coupled_assembly_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemo => { generated :: generic_coupled_assembly_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann => { generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateCompressible => { generated :: generic_coupled_assembly_grad_state_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo => { generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann => { generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum => { generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyIncompressibleMomentum => { generated :: generic_coupled_assembly_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateCompressible => { generated :: generic_coupled_update_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemo => { generated :: generic_coupled_update_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann => { generated :: generic_coupled_update_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateIncompressibleMomentum => { generated :: generic_coupled_update_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsCompressible => { generated :: packed_state_gradients_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsGenericDiffusionDemo => { generated :: packed_state_gradients_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsGenericDiffusionDemoNeumann => { generated :: packed_state_gradients_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsIncompressibleMomentum => { generated :: packed_state_gradients_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum => { generated :: rhie_chow_correct_velocity_delta_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedRhieChowGradPUpdateIncompressibleMomentum => { generated :: rhie_chow_grad_p_update_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedRhieChowStoreGradPIncompressibleMomentum => { generated :: rhie_chow_store_grad_p_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GenericCoupledSchurSetup => { generic_coupled_schur_setup :: create_shader_module_embed_source (device) } , Self :: GmresCgs => { gmres_cgs :: create_shader_module_embed_source (device) } , Self :: GmresLogic => { gmres_logic :: create_shader_module_embed_source (device) } , Self :: GmresOps => { gmres_ops :: create_shader_module_embed_source (device) } , Self :: LinearSolver => { linear_solver :: create_shader_module_embed_source (device) } , Self :: OuterConvergence => { outer_convergence :: create_shader_module_embed_source (device) } , Self :: Scalars => { scalars :: create_shader_module_embed_source (device) } , Self :: SchurPrecond => { schur_precond :: create_shader_module_embed_source (device) } , Self :: SchurPrecondGeneric => { schur_precond_generic :: create_shader_module_embed_source (device) } , }
    }
}
mod _root {
    pub use super::*;
    pub trait SetBindGroup {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        );
    }
    impl SetBindGroup for wgpu::ComputePass<'_> {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        ) {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
}
pub mod layout_asserts {
    use super::{_root, _root::*};
    const WGSL_BASE_TYPE_ASSERTS: () = {};
    const AMG_AMG_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(amg::AmgParams, n) == 0);
        assert!(std::mem::offset_of!(amg::AmgParams, omega) == 4);
        assert!(std::mem::offset_of!(amg::AmgParams, padding) == 8);
        assert!(std::mem::size_of::<amg::AmgParams>() == 16);
    };
    const AMG_PACK_PACK_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(amg_pack::PackParams, num_cells) == 0);
        assert!(std::mem::offset_of!(amg_pack::PackParams, component) == 4);
        assert!(std::mem::offset_of!(amg_pack::PackParams, _pad1) == 8);
        assert!(std::mem::offset_of!(amg_pack::PackParams, _pad2) == 12);
        assert!(std::mem::size_of::<amg_pack::PackParams>() == 16);
    };
    const BLOCK_PRECOND_GMRES_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(block_precond::GmresParams, n) == 0);
        assert!(std::mem::offset_of!(block_precond::GmresParams, num_cells) == 4);
        assert!(std::mem::offset_of!(block_precond::GmresParams, num_iters) == 8);
        assert!(std::mem::offset_of!(block_precond::GmresParams, omega) == 12);
        assert!(std::mem::offset_of!(block_precond::GmresParams, dispatch_x) == 16);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad1) == 20);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad2) == 24);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad3) == 28);
        assert!(std::mem::size_of::<block_precond::GmresParams>() == 32);
    };
    const BLOCK_PRECOND_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(block_precond::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(block_precond::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(block_precond::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(block_precond::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<block_precond::IterParams>() == 16);
    };
    const DOT_PRODUCT_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(dot_product::SolverParams, n) == 0);
        assert!(std::mem::offset_of!(dot_product::SolverParams, num_groups) == 4);
        assert!(std::mem::offset_of!(dot_product::SolverParams, padding) == 8);
        assert!(std::mem::size_of::<dot_product::SolverParams>() == 16);
    };
    const DOT_PRODUCT_PAIR_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(dot_product_pair::SolverParams, n) == 0);
        assert!(std::mem::offset_of!(dot_product_pair::SolverParams, num_groups) == 4);
        assert!(std::mem::offset_of!(dot_product_pair::SolverParams, padding) == 8);
        assert!(std::mem::size_of::<dot_product_pair::SolverParams>() == 16);
    };
    const GENERATED_DP_INIT_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, dt) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, dtau) == 8
        );
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, time) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(std::mem::size_of::<generated::dp_init_incompressible_momentum::Constants>() == 48);
    };
    const GENERATED_DP_UPDATE_FROM_DIAG_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<generated::dp_update_from_diag_incompressible_momentum::Constants>(
            ) == 48
        );
    };
    const GENERATED_FLUX_MODULE_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Vector2, x) == 0);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Vector2, y) == 4);
        assert!(std::mem::size_of::<generated::flux_module_compressible::Vector2>() == 8);
    };
    const GENERATED_FLUX_MODULE_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, time) == 12);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, viscosity) == 16
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, density) == 20
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, component) == 24
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, alpha_p) == 28
        );
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, scheme) == 32);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, alpha_u) == 36
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, stride_x) == 40
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, time_scheme) == 44
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_gamma) == 48
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_gm1) == 52
        );
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_r) == 56);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_dp_drho) == 60
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_p_offset)
                == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(std::mem::size_of::<generated::flux_module_compressible::Constants>() == 72);
    };
    const GENERATED_FLUX_MODULE_COMPRESSIBLE_LOW_MACH_PARAMS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::LowMachParams, model) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_compressible::LowMachParams,
                theta_floor
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_compressible::LowMachParams,
                pressure_coupling_alpha
            ) == 8
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::LowMachParams, _pad0) == 12
        );
        assert!(std::mem::size_of::<generated::flux_module_compressible::LowMachParams>() == 16);
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::flux_module_gradients_compressible::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_gradients_compressible::Vector2, y) == 4
        );
        assert!(std::mem::size_of::<generated::flux_module_gradients_compressible::Vector2>() == 8);
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::flux_module_gradients_compressible::Constants, dt) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<generated::flux_module_gradients_compressible::Constants>() == 48
        );
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::flux_module_gradients_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<generated::flux_module_gradients_incompressible_momentum::Constants>(
            ) == 48
        );
    };
    const GENERATED_FLUX_MODULE_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::flux_module_incompressible_momentum::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_incompressible_momentum::Vector2, y) == 4
        );
        assert!(
            std::mem::size_of::<generated::flux_module_incompressible_momentum::Vector2>() == 8
        );
    };
    const GENERATED_FLUX_MODULE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::flux_module_incompressible_momentum::Constants>() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_APPLY_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, time) == 12);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, viscosity) == 16);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, density) == 20);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, component) == 24);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, alpha_p) == 28);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, scheme) == 32);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, alpha_u) == 36);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, stride_x) == 40);
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, time_scheme) == 44
        );
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_gamma) == 48);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_gm1) == 52);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_r) == 56);
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_dp_drho) == 60
        );
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_p_offset) == 64
        );
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_theta_ref) == 68
        );
        assert!(std::mem::size_of::<generated::generic_coupled_apply::Constants>() == 72);
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::generic_coupled_assembly_compressible::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::generic_coupled_assembly_compressible::Vector2, y) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_compressible::Vector2>() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_compressible::Constants>()
                == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_generic_diffusion_demo::Vector2>(
            ) == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_NEUMANN_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
            >() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_grad_state_compressible::Vector2>(
            ) == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2,
            >() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: (
    ) = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_NEUMANN_VECTOR2_ASSERTS : () = { assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Vector2 , x) == 0) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Vector2 , y) == 4) ; assert ! (std :: mem :: size_of :: < generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Vector2 > () == 8) ; } ;
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS : () = { assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , dt) == 0) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , dt_old) == 4) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , dtau) == 8) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , time) == 12) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , viscosity) == 16) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , density) == 20) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , component) == 24) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , alpha_p) == 28) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , scheme) == 32) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , alpha_u) == 36) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , stride_x) == 40) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , time_scheme) == 44) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_gamma) == 48) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_gm1) == 52) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_r) == 56) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_dp_drho) == 60) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_p_offset) == 64) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_theta_ref) == 68) ; assert ! (std :: mem :: size_of :: < generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants > () == 72) ; } ;
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: (
    ) = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2,
            >() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS : () = { assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , dt) == 0) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , dt_old) == 4) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , dtau) == 8) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , time) == 12) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , viscosity) == 16) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , density) == 20) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , component) == 24) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , alpha_p) == 28) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , scheme) == 32) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , alpha_u) == 36) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , stride_x) == 40) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , time_scheme) == 44) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_gamma) == 48) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_gm1) == 52) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_r) == 56) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_dp_drho) == 60) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_p_offset) == 64) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_theta_ref) == 68) ; assert ! (std :: mem :: size_of :: < generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants > () == 72) ; } ;
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_compressible::Constants>() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_generic_diffusion_demo::Constants>(
            ) == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_incompressible_momentum::Constants>(
            ) == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::packed_state_gradients_compressible::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::packed_state_gradients_compressible::Vector2, y) == 4
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_compressible::Vector2>() == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_compressible::Constants>() == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_generic_diffusion_demo::Vector2>(
            ) == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_generic_diffusion_demo::Constants>(
            ) == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_NEUMANN_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2,
            >() == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
            >() == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_incompressible_momentum::Constants>(
            ) == 72
        );
    };
    const GENERATED_RHIE_CHOW_CORRECT_VELOCITY_DELTA_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
            >() == 48
        );
    };
    const GENERATED_RHIE_CHOW_GRAD_P_UPDATE_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::rhie_chow_grad_p_update_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_RHIE_CHOW_GRAD_P_UPDATE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
            >() == 48
        );
    };
    const GENERATED_RHIE_CHOW_STORE_GRAD_P_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<generated::rhie_chow_store_grad_p_incompressible_momentum::Constants>(
            ) == 48
        );
    };
    const GENERIC_COUPLED_SCHUR_SETUP_SETUP_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, num_cells) == 0);
        assert!(
            std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, unknowns_per_cell) == 4
        );
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, p) == 8);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u_len) == 12);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u0123) == 16);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u4567) == 32);
        assert!(std::mem::size_of::<generic_coupled_schur_setup::SetupParams>() == 48);
    };
    const GMRES_CGS_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_cgs::Params, n) == 0);
        assert!(std::mem::offset_of!(gmres_cgs::Params, num_cells) == 4);
        assert!(std::mem::offset_of!(gmres_cgs::Params, num_iters) == 8);
        assert!(std::mem::offset_of!(gmres_cgs::Params, omega) == 12);
        assert!(std::mem::offset_of!(gmres_cgs::Params, dispatch_x) == 16);
        assert!(std::mem::offset_of!(gmres_cgs::Params, max_restart) == 20);
        assert!(std::mem::offset_of!(gmres_cgs::Params, column_offset) == 24);
        assert!(std::mem::offset_of!(gmres_cgs::Params, pad3) == 28);
        assert!(std::mem::size_of::<gmres_cgs::Params>() == 32);
    };
    const GMRES_LOGIC_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_logic::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<gmres_logic::IterParams>() == 16);
    };
    const GMRES_OPS_GMRES_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, n) == 0);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, num_cells) == 4);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, num_iters) == 8);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, omega) == 12);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, dispatch_x) == 16);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad1) == 20);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad2) == 24);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad3) == 28);
        assert!(std::mem::size_of::<gmres_ops::GmresParams>() == 32);
    };
    const GMRES_OPS_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_ops::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<gmres_ops::IterParams>() == 16);
    };
    const LINEAR_SOLVER_GPU_SCALARS_ASSERTS: () = {
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, rho_old) == 0);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, rho_new) == 4);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, alpha) == 8);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, beta) == 12);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, r0_v) == 16);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, r_r) == 20);
        assert!(std::mem::size_of::<linear_solver::GpuScalars>() == 24);
    };
    const LINEAR_SOLVER_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(linear_solver::SolverParams, n) == 0);
        assert!(std::mem::size_of::<linear_solver::SolverParams>() == 4);
    };
    const OUTER_CONVERGENCE_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(outer_convergence::Params, num_cells) == 0);
        assert!(std::mem::offset_of!(outer_convergence::Params, stride) == 4);
        assert!(std::mem::offset_of!(outer_convergence::Params, num_targets) == 8);
        assert!(std::mem::offset_of!(outer_convergence::Params, _pad0) == 12);
        assert!(std::mem::size_of::<outer_convergence::Params>() == 16);
    };
    const OUTER_CONVERGENCE_TARGET_DESC_ASSERTS: () = {
        assert!(std::mem::offset_of!(outer_convergence::TargetDesc, offsets) == 0);
        assert!(std::mem::offset_of!(outer_convergence::TargetDesc, num_comps) == 16);
        assert!(std::mem::offset_of!(outer_convergence::TargetDesc, _pad0) == 20);
        assert!(std::mem::size_of::<outer_convergence::TargetDesc>() == 32);
    };
    const SCALARS_GPU_SCALARS_ASSERTS: () = {
        assert!(std::mem::offset_of!(scalars::GpuScalars, rho_old) == 0);
        assert!(std::mem::offset_of!(scalars::GpuScalars, rho_new) == 4);
        assert!(std::mem::offset_of!(scalars::GpuScalars, alpha) == 8);
        assert!(std::mem::offset_of!(scalars::GpuScalars, beta) == 12);
        assert!(std::mem::offset_of!(scalars::GpuScalars, r0_v) == 16);
        assert!(std::mem::offset_of!(scalars::GpuScalars, r_r) == 20);
        assert!(std::mem::size_of::<scalars::GpuScalars>() == 24);
    };
    const SCALARS_REDUCE_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(scalars::ReduceParams, n) == 0);
        assert!(std::mem::offset_of!(scalars::ReduceParams, num_groups) == 4);
        assert!(std::mem::size_of::<scalars::ReduceParams>() == 8);
    };
    const SCHUR_PRECOND_PRECOND_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, n) == 0);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, num_cells) == 4);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, omega) == 8);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, unknowns_per_cell) == 12);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, u0) == 16);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, u1) == 20);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, p) == 24);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, _pad0) == 28);
        assert!(std::mem::size_of::<schur_precond::PrecondParams>() == 32);
    };
    const SCHUR_PRECOND_GENERIC_PRECOND_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, n) == 0);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, num_cells) == 4);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, omega) == 8);
        assert!(
            std::mem::offset_of!(schur_precond_generic::PrecondParams, unknowns_per_cell) == 12
        );
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, p) == 16);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u_len) == 20);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, _pad0) == 24);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, _pad1) == 28);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u0123) == 32);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u4567) == 48);
        assert!(std::mem::size_of::<schur_precond_generic::PrecondParams>() == 64);
    };
}
pub mod amg {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct AmgParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub padding: [u32; 2],
    }
    impl AmgParams {
        pub const fn new(n: u32, omega: f32, padding: [u32; 2]) -> Self {
            Self { n, omega, padding }
        }
    }
    pub const SCALAR_STOP: u32 = 8u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const SMOOTH_OP_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_smooth_op_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline smooth_op"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("smooth_op"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PROLONGATE_OP_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_prolongate_op_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline prolongate_op"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("prolongate_op"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const RESTRICT_RESIDUAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_restrict_residual_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline restrict_residual"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("restrict_residual"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CLEAR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_clear_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline clear"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("clear"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SMOOTH_OP: &str = "smooth_op";
    pub const ENTRY_PROLONGATE_OP: &str = "prolongate_op";
    pub const ENTRY_RESTRICT_RESIDUAL: &str = "restrict_residual";
    pub const ENTRY_CLEAR: &str = "clear";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub x: wgpu::BufferBinding<'a>,
        pub b: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub x: wgpu::BindGroupEntry<'a>,
        pub b: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.x),
                },
                b: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.b),
                },
                params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.x, self.b, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::amg::AmgParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub op_row_offsets: wgpu::BufferBinding<'a>,
        pub op_col_indices: wgpu::BufferBinding<'a>,
        pub op_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub op_row_offsets: wgpu::BindGroupEntry<'a>,
        pub op_col_indices: wgpu::BindGroupEntry<'a>,
        pub op_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                op_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.op_row_offsets),
                },
                op_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.op_col_indices),
                },
                op_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.op_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.op_row_offsets, self.op_col_indices, self.op_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"op_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"op_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"op_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub coarse_vec: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub coarse_vec: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                coarse_vec: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.coarse_vec),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
            [self.coarse_vec, self.scalars]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"coarse_vec\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Amg::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("amg.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct AmgParams {
    n: u32,
    omega: f32,
    padding: vec2<u32>,
}

const SCALAR_STOP: u32 = 8u;

@group(0) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> col_indices: array<u32>;
@group(0) @binding(2) 
var<storage> values: array<f32>;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> b: array<f32>;
@group(1) @binding(2) 
var<uniform> params: AmgParams;
@group(2) @binding(0) 
var<storage> op_row_offsets: array<u32>;
@group(2) @binding(1) 
var<storage> op_col_indices: array<u32>;
@group(2) @binding(2) 
var<storage> op_values: array<f32>;
@group(3) @binding(0) 
var<storage, read_write> coarse_vec: array<f32>;
@group(3) @binding(1) 
var<storage> scalars: array<f32>;

fn amg_should_stop() -> bool {
    let _e2 = scalars[8];
    return (_e2 > 0.5f);
}

@compute @workgroup_size(64, 1, 1) 
fn smooth_op(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sigma: f32 = 0f;
    var diag: f32 = 1f;
    var k: u32;

    let _e2 = amg_should_stop();
    if _e2 {
        return;
    }
    let stride_x = (num_workgroups.x * 64u);
    let i = ((global_id.y * stride_x) + global_id.x);
    let _e14 = params.n;
    if (i >= _e14) {
        return;
    }
    let start = row_offsets[i];
    let end = row_offsets[(i + 1u)];
    k = start;
    loop {
        let _e25 = k;
        if (_e25 < end) {
        } else {
            break;
        }
        {
            let _e28 = k;
            let col = col_indices[_e28];
            let _e32 = k;
            let val = values[_e32];
            if (col == i) {
                diag = val;
            } else {
                let _e40 = x[col];
                let _e42 = sigma;
                sigma = (_e42 + (val * _e40));
            }
        }
        continuing {
            let _e45 = k;
            k = (_e45 + 1u);
        }
    }
    let _e47 = diag;
    if (abs(_e47) < 0.00000000000001f) {
        diag = 1f;
    }
    let _e54 = b[i];
    let _e55 = sigma;
    let _e57 = diag;
    let x_new = ((_e54 - _e55) / _e57);
    let _e63 = x[i];
    let _e66 = params.omega;
    x[i] = mix(_e63, x_new, _e66);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn prolongate_op(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var correction: f32 = 0f;
    var k_1: u32;

    let _e1 = amg_should_stop();
    if _e1 {
        return;
    }
    let stride_x_1 = (num_workgroups_1.x * 64u);
    let i_1 = ((global_id_1.y * stride_x_1) + global_id_1.x);
    let _e13 = params.n;
    if (i_1 >= _e13) {
        return;
    }
    let start_1 = op_row_offsets[i_1];
    let end_1 = op_row_offsets[(i_1 + 1u)];
    k_1 = start_1;
    loop {
        let _e24 = k_1;
        if (_e24 < end_1) {
        } else {
            break;
        }
        {
            let _e27 = k_1;
            let coarse_idx = op_col_indices[_e27];
            let _e31 = k_1;
            let val_1 = op_values[_e31];
            let _e37 = coarse_vec[coarse_idx];
            let _e39 = correction;
            correction = (_e39 + (val_1 * _e37));
        }
        continuing {
            let _e42 = k_1;
            k_1 = (_e42 + 1u);
        }
    }
    let _e46 = correction;
    let _e47 = x[i_1];
    x[i_1] = (_e47 + _e46);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn restrict_residual(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var sum: f32 = 0f;
    var k_2: u32;
    var ax: f32;
    var j: u32;

    let _e1 = amg_should_stop();
    if _e1 {
        return;
    }
    let stride_x_2 = (num_workgroups_2.x * 64u);
    let i_2 = ((global_id_2.y * stride_x_2) + global_id_2.x);
    let _e13 = params.n;
    if (i_2 >= _e13) {
        return;
    }
    let start_2 = op_row_offsets[i_2];
    let end_2 = op_row_offsets[(i_2 + 1u)];
    k_2 = start_2;
    loop {
        let _e24 = k_2;
        if (_e24 < end_2) {
        } else {
            break;
        }
        {
            let _e27 = k_2;
            let fine_idx = op_col_indices[_e27];
            let _e31 = k_2;
            let r_val = op_values[_e31];
            let a_start = row_offsets[fine_idx];
            let a_end = row_offsets[(fine_idx + 1u)];
            ax = 0f;
            j = a_start;
            loop {
                let _e45 = j;
                if (_e45 < a_end) {
                } else {
                    break;
                }
                {
                    let _e48 = j;
                    let _e50 = values[_e48];
                    let _e53 = j;
                    let _e55 = col_indices[_e53];
                    let _e57 = x[_e55];
                    let _e59 = ax;
                    ax = (_e59 + (_e50 * _e57));
                }
                continuing {
                    let _e62 = j;
                    j = (_e62 + 1u);
                }
            }
            let _e66 = b[fine_idx];
            let _e67 = ax;
            let fine_r = (_e66 - _e67);
            let _e71 = sum;
            sum = (_e71 + (r_val * fine_r));
        }
        continuing {
            let _e74 = k_2;
            k_2 = (_e74 + 1u);
        }
    }
    let _e78 = sum;
    coarse_vec[i_2] = _e78;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn clear(@builtin(global_invocation_id) global_id_3: vec3<u32>, @builtin(num_workgroups) num_workgroups_3: vec3<u32>) {
    let _e0 = amg_should_stop();
    if _e0 {
        return;
    }
    let stride_x_3 = (num_workgroups_3.x * 64u);
    let i_3 = ((global_id_3.y * stride_x_3) + global_id_3.x);
    let _e12 = params.n;
    if (i_3 >= _e12) {
        return;
    }
    x[i_3] = 0f;
    return;
}
"#;
}
pub mod bytemuck_impls {
    use super::{_root, _root::*};
    unsafe impl bytemuck::Zeroable for amg::AmgParams {}
    unsafe impl bytemuck::Pod for amg::AmgParams {}
    unsafe impl bytemuck::Zeroable for amg_pack::PackParams {}
    unsafe impl bytemuck::Pod for amg_pack::PackParams {}
    unsafe impl bytemuck::Zeroable for block_precond::GmresParams {}
    unsafe impl bytemuck::Pod for block_precond::GmresParams {}
    unsafe impl bytemuck::Zeroable for block_precond::IterParams {}
    unsafe impl bytemuck::Pod for block_precond::IterParams {}
    unsafe impl bytemuck::Zeroable for dot_product::SolverParams {}
    unsafe impl bytemuck::Pod for dot_product::SolverParams {}
    unsafe impl bytemuck::Zeroable for dot_product_pair::SolverParams {}
    unsafe impl bytemuck::Pod for dot_product_pair::SolverParams {}
    unsafe impl bytemuck::Zeroable for generated::dp_init_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Pod for generated::dp_init_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::dp_update_from_diag_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::dp_update_from_diag_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::flux_module_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::flux_module_compressible::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_compressible::LowMachParams {}
    unsafe impl bytemuck::Pod for generated::flux_module_compressible::LowMachParams {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_gradients_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::flux_module_gradients_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_gradients_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::flux_module_gradients_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::flux_module_gradients_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::flux_module_gradients_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::flux_module_gradients_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::flux_module_gradients_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Pod for generated::flux_module_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Pod for generated::flux_module_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_apply::Constants {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_apply::Constants {}
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_assembly_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_assembly_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_generic_diffusion_demo::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_compressible::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_grad_state_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_compressible::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_compressible::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_update_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_generic_diffusion_demo::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::packed_state_gradients_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::packed_state_gradients_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_generic_diffusion_demo::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_generic_diffusion_demo::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::rhie_chow_grad_p_update_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::rhie_chow_grad_p_update_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::rhie_chow_grad_p_update_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::rhie_chow_grad_p_update_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::rhie_chow_store_grad_p_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::rhie_chow_store_grad_p_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generic_coupled_schur_setup::SetupParams {}
    unsafe impl bytemuck::Pod for generic_coupled_schur_setup::SetupParams {}
    unsafe impl bytemuck::Zeroable for gmres_cgs::Params {}
    unsafe impl bytemuck::Pod for gmres_cgs::Params {}
    unsafe impl bytemuck::Zeroable for gmres_logic::IterParams {}
    unsafe impl bytemuck::Pod for gmres_logic::IterParams {}
    unsafe impl bytemuck::Zeroable for gmres_ops::GmresParams {}
    unsafe impl bytemuck::Pod for gmres_ops::GmresParams {}
    unsafe impl bytemuck::Zeroable for gmres_ops::IterParams {}
    unsafe impl bytemuck::Pod for gmres_ops::IterParams {}
    unsafe impl bytemuck::Zeroable for linear_solver::GpuScalars {}
    unsafe impl bytemuck::Pod for linear_solver::GpuScalars {}
    unsafe impl bytemuck::Zeroable for linear_solver::SolverParams {}
    unsafe impl bytemuck::Pod for linear_solver::SolverParams {}
    unsafe impl bytemuck::Zeroable for outer_convergence::Params {}
    unsafe impl bytemuck::Pod for outer_convergence::Params {}
    unsafe impl bytemuck::Zeroable for outer_convergence::TargetDesc {}
    unsafe impl bytemuck::Pod for outer_convergence::TargetDesc {}
    unsafe impl bytemuck::Zeroable for scalars::GpuScalars {}
    unsafe impl bytemuck::Pod for scalars::GpuScalars {}
    unsafe impl bytemuck::Zeroable for scalars::ReduceParams {}
    unsafe impl bytemuck::Pod for scalars::ReduceParams {}
    unsafe impl bytemuck::Zeroable for schur_precond::PrecondParams {}
    unsafe impl bytemuck::Pod for schur_precond::PrecondParams {}
    unsafe impl bytemuck::Zeroable for schur_precond_generic::PrecondParams {}
    unsafe impl bytemuck::Pod for schur_precond_generic::PrecondParams {}
}
pub mod amg_pack {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PackParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub component: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl PackParams {
        pub const fn new(num_cells: u32, component: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                num_cells,
                component,
                _pad1,
                _pad2,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const PACK_COMPONENT_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_pack_component_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline pack_component"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("pack_component"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UNPACK_COMPONENT_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_unpack_component_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline unpack_component"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("unpack_component"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_PACK_COMPONENT: &str = "pack_component";
    pub const ENTRY_UNPACK_COMPONENT: &str = "unpack_component";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub input_buf: wgpu::BufferBinding<'a>,
        pub output_buf: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub input_buf: wgpu::BindGroupEntry<'a>,
        pub output_buf: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                input_buf: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.input_buf),
                },
                output_buf: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.output_buf),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
            [self.input_buf, self.output_buf]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("AmgPack::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"input_buf\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"output_buf\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("AmgPack::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("AmgPack::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::amg_pack::PackParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("AmgPack::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("AmgPack::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("amg_pack.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PackParams {
    num_cells: u32,
    component: u32,
    _pad1_: u32,
    _pad2_: u32,
}

@group(0) @binding(0) 
var<storage> input_buf: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> output_buf: array<f32>;
@group(1) @binding(0) 
var<uniform> params: PackParams;

@compute @workgroup_size(64, 1, 1) 
fn pack_component(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    let stride_x = (num_workgroups.x * 64u);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let _e11 = params.num_cells;
    if (idx >= _e11) {
        return;
    }
    let _e17 = params.component;
    let base = ((idx * 4u) + _e17);
    let _e23 = input_buf[base];
    output_buf[idx] = _e23;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn unpack_component(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    let stride_x_1 = (num_workgroups_1.x * 64u);
    let idx_1 = ((global_id_1.y * stride_x_1) + global_id_1.x);
    let _e11 = params.num_cells;
    if (idx_1 >= _e11) {
        return;
    }
    let _e17 = params.component;
    let base_1 = ((idx_1 * 4u) + _e17);
    let _e23 = input_buf[idx_1];
    output_buf[base_1] = _e23;
    return;
}
"#;
}
pub mod block_precond {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GmresParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad2: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad3: u32,
    }
    impl GmresParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            _pad1: u32,
            _pad2: u32,
            _pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                _pad1,
                _pad2,
                _pad3,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub const MAX_BLOCK: u32 = 16u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const BUILD_BLOCK_INV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_build_block_inv_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline build_block_inv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("build_block_inv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const APPLY_BLOCK_PRECOND_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_apply_block_precond_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline apply_block_precond"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("apply_block_precond"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_BUILD_BLOCK_INV: &str = "build_block_inv";
    pub const ENTRY_APPLY_BLOCK_PRECOND: &str = "apply_block_precond";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub vec_x: wgpu::BufferBinding<'a>,
        pub vec_y: wgpu::BufferBinding<'a>,
        pub vec_z: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub vec_x: wgpu::BindGroupEntry<'a>,
        pub vec_y: wgpu::BindGroupEntry<'a>,
        pub vec_z: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                vec_x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.vec_x),
                },
                vec_y: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.vec_y),
                },
                vec_z: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.vec_z),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.vec_x, self.vec_y, self.vec_z]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"vec_x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"vec_y\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"vec_z\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub block_inv: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub block_inv: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                block_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.block_inv),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.block_inv]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"block_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub iter_params: wgpu::BufferBinding<'a>,
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                iter_params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                hessenberg: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.scalars,
                self.iter_params,
                self.hessenberg,
                self.y_sol,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::block_precond::GmresParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::block_precond::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("BlockPrecond::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("block_precond.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GmresParams {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    _pad1_: u32,
    _pad2_: u32,
    _pad3_: u32,
}

struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

const MAX_BLOCK: u32 = 16u;

@group(0) @binding(0) 
var<storage> vec_x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> vec_y: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> vec_z: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> block_inv: array<f32>;
@group(3) @binding(0) 
var<uniform> params: GmresParams;
@group(3) @binding(1) 
var<storage, read_write> scalars: array<f32>;
@group(3) @binding(2) 
var<uniform> iter_params: IterParams;
@group(3) @binding(3) 
var<storage, read_write> hessenberg: array<f32>;
@group(3) @binding(4) 
var<storage> y_sol: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    let abs_val = abs(val);
    if (abs_val > 0.000000000001f) {
        return (1f / val);
    }
    if (abs_val > 0f) {
        return (sign(val) * 1000000000000f);
    }
    return 0f;
}

fn swap_rows(a_1: ptr<function, array<array<f32, 16>, 16>>, b: ptr<function, array<array<f32, 16>, 16>>, r0_: u32, r1_: u32, n: u32) {
    var c_6: u32 = 0u;

    if (r0_ == r1_) {
        return;
    }
    loop {
        let _e6 = c_6;
        if (_e6 < n) {
        } else {
            break;
        }
        {
            let _e10 = c_6;
            let tmp = (*a_1)[r0_][_e10];
            let _e14 = c_6;
            let _e17 = c_6;
            let _e19 = (*a_1)[r1_][_e17];
            (*a_1)[r0_][_e14] = _e19;
            let _e21 = c_6;
            (*a_1)[r1_][_e21] = tmp;
            let _e25 = c_6;
            let tmp_b = (*b)[r0_][_e25];
            let _e29 = c_6;
            let _e32 = c_6;
            let _e34 = (*b)[r1_][_e32];
            (*b)[r0_][_e29] = _e34;
            let _e36 = c_6;
            (*b)[r1_][_e36] = tmp_b;
        }
        continuing {
            let _e38 = c_6;
            c_6 = (_e38 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn build_block_inv(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var a: array<array<f32, 16>, 16>;
    var inv: array<array<f32, 16>, 16>;
    var diag_orig: array<f32, 16>;
    var r: u32 = 0u;
    var c: u32;
    var k: u32;
    var singular: bool = false;
    var i: u32 = 0u;
    var pivot: u32;
    var pivot_val: f32;
    var r_1: u32;
    var piv: f32;
    var c_1: u32;
    var r_2: u32;
    var c_2: u32;
    var r_3: u32 = 0u;
    var c_3: u32;
    var r_4: u32 = 0u;
    var c_4: u32;

    let stride_x = (num_workgroups.x * 64u);
    let cell = ((global_id.y * stride_x) + global_id.x);
    let _e13 = params.num_cells;
    if (cell >= _e13) {
        return;
    }
    let _e17 = params.num_cells;
    if (_e17 == 0u) {
        return;
    }
    let _e22 = params.n;
    let _e25 = params.num_cells;
    let b_1 = (_e22 / _e25);
    if ((b_1 == 0u) || (b_1 > MAX_BLOCK)) {
        return;
    }
    let base = (cell * b_1);
    loop {
        let _e34 = r;
        if (_e34 < b_1) {
        } else {
            break;
        }
        {
            c = 0u;
            loop {
                let _e38 = c;
                if (_e38 < b_1) {
                } else {
                    break;
                }
                {
                    let _e41 = r;
                    let _e43 = c;
                    a[_e41][_e43] = 0f;
                    let _e47 = r;
                    let _e49 = c;
                    inv[_e47][_e49] = 0f;
                }
                continuing {
                    let _e52 = c;
                    c = (_e52 + 1u);
                }
            }
            let _e55 = r;
            let row = (base + _e55);
            let start = row_offsets[row];
            let end = row_offsets[(row + 1u)];
            k = start;
            loop {
                let _e66 = k;
                if (_e66 < end) {
                } else {
                    break;
                }
                {
                    let _e69 = k;
                    let col = col_indices[_e69];
                    if ((col >= base) && (col < (base + b_1))) {
                        let local = (col - base);
                        let _e77 = r;
                        let _e81 = k;
                        let _e83 = matrix_values[_e81];
                        a[_e77][local] = _e83;
                    }
                }
                continuing {
                    let _e84 = k;
                    k = (_e84 + 1u);
                }
            }
            let _e87 = r;
            let _e89 = r;
            inv[_e87][_e89] = 1f;
            let _e93 = r;
            let _e95 = r;
            let _e97 = r;
            let _e99 = a[_e95][_e97];
            diag_orig[_e93] = _e99;
        }
        continuing {
            let _e100 = r;
            r = (_e100 + 1u);
        }
    }
    loop {
        let _e104 = i;
        if (_e104 < b_1) {
        } else {
            break;
        }
        {
            let _e106 = i;
            pivot = _e106;
            let _e108 = i;
            let _e110 = i;
            let _e112 = a[_e108][_e110];
            pivot_val = abs(_e112);
            let _e115 = i;
            r_1 = (_e115 + 1u);
            loop {
                let _e119 = r_1;
                if (_e119 < b_1) {
                } else {
                    break;
                }
                {
                    let _e121 = r_1;
                    let _e123 = i;
                    let _e125 = a[_e121][_e123];
                    let val_1 = abs(_e125);
                    let _e127 = pivot_val;
                    if (val_1 > _e127) {
                        pivot_val = val_1;
                        let _e129 = r_1;
                        pivot = _e129;
                    }
                }
                continuing {
                    let _e130 = r_1;
                    r_1 = (_e130 + 1u);
                }
            }
            let _e133 = pivot_val;
            if (_e133 < 0.000000000001f) {
                singular = true;
            }
            let _e138 = i;
            let _e139 = pivot;
            swap_rows((&a), (&inv), _e138, _e139, b_1);
            let _e140 = i;
            let _e142 = i;
            let _e144 = a[_e140][_e142];
            piv = _e144;
            let _e146 = piv;
            if (abs(_e146) < 0.000000000001f) {
                let _e150 = piv;
                piv = select(0.000000000001f, -0.000000000001f, (_e150 < 0f));
            }
            let _e156 = piv;
            let inv_piv = (1f / _e156);
            c_1 = 0u;
            loop {
                let _e161 = c_1;
                if (_e161 < b_1) {
                } else {
                    break;
                }
                {
                    let _e163 = i;
                    let _e165 = c_1;
                    let _e167 = i;
                    let _e169 = c_1;
                    let _e171 = a[_e167][_e169];
                    a[_e163][_e165] = (_e171 * inv_piv);
                    let _e173 = i;
                    let _e175 = c_1;
                    let _e177 = i;
                    let _e179 = c_1;
                    let _e181 = inv[_e177][_e179];
                    inv[_e173][_e175] = (_e181 * inv_piv);
                }
                continuing {
                    let _e183 = c_1;
                    c_1 = (_e183 + 1u);
                }
            }
            r_2 = 0u;
            loop {
                let _e188 = r_2;
                if (_e188 < b_1) {
                } else {
                    break;
                }
                {
                    let _e190 = r_2;
                    let _e191 = i;
                    if (_e190 == _e191) {
                        continue;
                    }
                    let _e193 = r_2;
                    let _e195 = i;
                    let factor = a[_e193][_e195];
                    c_2 = 0u;
                    loop {
                        let _e200 = c_2;
                        if (_e200 < b_1) {
                        } else {
                            break;
                        }
                        {
                            let _e202 = r_2;
                            let _e204 = c_2;
                            let _e206 = r_2;
                            let _e208 = c_2;
                            let _e210 = a[_e206][_e208];
                            let _e211 = i;
                            let _e213 = c_2;
                            let _e215 = a[_e211][_e213];
                            a[_e202][_e204] = (_e210 - (factor * _e215));
                            let _e218 = r_2;
                            let _e220 = c_2;
                            let _e222 = r_2;
                            let _e224 = c_2;
                            let _e226 = inv[_e222][_e224];
                            let _e227 = i;
                            let _e229 = c_2;
                            let _e231 = inv[_e227][_e229];
                            inv[_e218][_e220] = (_e226 - (factor * _e231));
                        }
                        continuing {
                            let _e234 = c_2;
                            c_2 = (_e234 + 1u);
                        }
                    }
                }
                continuing {
                    let _e237 = r_2;
                    r_2 = (_e237 + 1u);
                }
            }
        }
        continuing {
            let _e240 = i;
            i = (_e240 + 1u);
        }
    }
    let _e243 = singular;
    if _e243 {
        loop {
            let _e245 = r_3;
            if (_e245 < b_1) {
            } else {
                break;
            }
            {
                c_3 = 0u;
                loop {
                    let _e249 = c_3;
                    if (_e249 < b_1) {
                    } else {
                        break;
                    }
                    {
                        let _e251 = r_3;
                        let _e253 = c_3;
                        inv[_e251][_e253] = 0f;
                    }
                    continuing {
                        let _e256 = c_3;
                        c_3 = (_e256 + 1u);
                    }
                }
                let _e259 = r_3;
                let _e261 = r_3;
                let _e263 = r_3;
                let _e265 = diag_orig[_e263];
                let _e266 = safe_inverse(_e265);
                inv[_e259][_e261] = _e266;
            }
            continuing {
                let _e267 = r_3;
                r_3 = (_e267 + 1u);
            }
        }
    }
    let offset = (cell * (b_1 * b_1));
    loop {
        let _e273 = r_4;
        if (_e273 < b_1) {
        } else {
            break;
        }
        {
            c_4 = 0u;
            loop {
                let _e277 = c_4;
                if (_e277 < b_1) {
                } else {
                    break;
                }
                {
                    let _e280 = r_4;
                    let _e283 = c_4;
                    let _e286 = r_4;
                    let _e288 = c_4;
                    let _e290 = inv[_e286][_e288];
                    block_inv[((offset + (_e280 * b_1)) + _e283)] = _e290;
                }
                continuing {
                    let _e291 = c_4;
                    c_4 = (_e291 + 1u);
                }
            }
        }
        continuing {
            let _e294 = r_4;
            r_4 = (_e294 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn apply_block_precond(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var r_5: u32 = 0u;
    var sum: f32;
    var c_5: u32;

    let stride_x_1 = (num_workgroups_1.x * 64u);
    let cell_1 = ((global_id_1.y * stride_x_1) + global_id_1.x);
    let _e12 = params.num_cells;
    if (cell_1 >= _e12) {
        return;
    }
    let _e16 = params.num_cells;
    if (_e16 == 0u) {
        return;
    }
    let _e21 = params.n;
    let _e24 = params.num_cells;
    let b_2 = (_e21 / _e24);
    if ((b_2 == 0u) || (b_2 > MAX_BLOCK)) {
        return;
    }
    let base_1 = (cell_1 * b_2);
    let offset_1 = (cell_1 * (b_2 * b_2));
    loop {
        let _e35 = r_5;
        if (_e35 < b_2) {
        } else {
            break;
        }
        {
            sum = 0f;
            c_5 = 0u;
            loop {
                let _e41 = c_5;
                if (_e41 < b_2) {
                } else {
                    break;
                }
                {
                    let _e44 = r_5;
                    let _e47 = c_5;
                    let _e50 = block_inv[((offset_1 + (_e44 * b_2)) + _e47)];
                    let _e52 = c_5;
                    let _e55 = vec_x[(base_1 + _e52)];
                    let _e57 = sum;
                    sum = (_e57 + (_e50 * _e55));
                }
                continuing {
                    let _e59 = c_5;
                    c_5 = (_e59 + 1u);
                }
            }
            let _e63 = r_5;
            let _e66 = sum;
            vec_y[(base_1 + _e63)] = _e66;
        }
        continuing {
            let _e67 = r_5;
            r_5 = (_e67 + 1u);
        }
    }
    return;
}
"#;
}
pub mod dot_product {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_groups: u32,
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub padding: [u32; 2],
    }
    impl SolverParams {
        pub const fn new(n: u32, num_groups: u32, padding: [u32; 2]) -> Self {
            Self {
                n,
                num_groups,
                padding,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProduct::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::dot_product::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProduct::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub dot_result: wgpu::BufferBinding<'a>,
        pub dot_a: wgpu::BufferBinding<'a>,
        pub dot_b: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub dot_result: wgpu::BindGroupEntry<'a>,
        pub dot_a: wgpu::BindGroupEntry<'a>,
        pub dot_b: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                dot_result: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.dot_result),
                },
                dot_a: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_a),
                },
                dot_b: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_b),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.dot_result, self.dot_a, self.dot_b]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProduct::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"dot_result\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_a\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProduct::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("DotProduct::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("dot_product.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SolverParams {
    n: u32,
    num_groups: u32,
    padding: vec2<u32>,
}

@group(0) @binding(0) 
var<uniform> params: SolverParams;
@group(1) @binding(0) 
var<storage, read_write> dot_result: array<f32>;
@group(1) @binding(1) 
var<storage> dot_a: array<f32>;
@group(1) @binding(2) 
var<storage> dot_b: array<f32>;
var<workgroup> scratch: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var val: f32 = 0f;
    var i: u32 = 32u;

    let stride_x = (num_workgroups.x * 64u);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let lid = local_id.x;
    let _e15 = params.n;
    if (idx < _e15) {
        let _e19 = dot_a[idx];
        let _e22 = dot_b[idx];
        val = (_e19 * _e22);
    }
    let _e27 = val;
    scratch[lid] = _e27;
    workgroupBarrier();
    loop {
        let _e29 = i;
        if (_e29 > 0u) {
        } else {
            break;
        }
        {
            let _e32 = i;
            if (lid < _e32) {
                let _e37 = i;
                let _e40 = scratch[(lid + _e37)];
                let _e41 = scratch[lid];
                scratch[lid] = (_e41 + _e40);
            }
            workgroupBarrier();
        }
        continuing {
            let _e44 = i;
            i = (_e44 >> 1u);
        }
    }
    if (lid == 0u) {
        let group_flat = ((group_id.y * num_workgroups.x) + group_id.x);
        let _e56 = params.num_groups;
        if (group_flat < _e56) {
            let _e62 = scratch[0];
            dot_result[group_flat] = _e62;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}
"#;
}
pub mod dot_product_pair {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_groups: u32,
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub padding: [u32; 2],
    }
    impl SolverParams {
        pub const fn new(n: u32, num_groups: u32, padding: [u32; 2]) -> Self {
            Self {
                n,
                num_groups,
                padding,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProductPair::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::dot_product_pair::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProductPair::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub dot_result_a: wgpu::BufferBinding<'a>,
        pub dot_result_b: wgpu::BufferBinding<'a>,
        pub dot_a0: wgpu::BufferBinding<'a>,
        pub dot_b0: wgpu::BufferBinding<'a>,
        pub dot_a1: wgpu::BufferBinding<'a>,
        pub dot_b1: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub dot_result_a: wgpu::BindGroupEntry<'a>,
        pub dot_result_b: wgpu::BindGroupEntry<'a>,
        pub dot_a0: wgpu::BindGroupEntry<'a>,
        pub dot_b0: wgpu::BindGroupEntry<'a>,
        pub dot_a1: wgpu::BindGroupEntry<'a>,
        pub dot_b1: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                dot_result_a: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_a),
                },
                dot_result_b: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_b),
                },
                dot_a0: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_a0),
                },
                dot_b0: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.dot_b0),
                },
                dot_a1: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.dot_a1),
                },
                dot_b1: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.dot_b1),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
            [
                self.dot_result_a,
                self.dot_result_b,
                self.dot_a0,
                self.dot_b0,
                self.dot_a1,
                self.dot_b1,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProductPair::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"dot_result_a\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_result_b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_a0\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"dot_b0\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"dot_a1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"dot_b1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProductPair::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("DotProductPair::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("dot_product_pair.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SolverParams {
    n: u32,
    num_groups: u32,
    padding: vec2<u32>,
}

@group(0) @binding(0) 
var<uniform> params: SolverParams;
@group(1) @binding(0) 
var<storage, read_write> dot_result_a: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> dot_result_b: array<f32>;
@group(1) @binding(2) 
var<storage> dot_a0_: array<f32>;
@group(1) @binding(3) 
var<storage> dot_b0_: array<f32>;
@group(1) @binding(4) 
var<storage> dot_a1_: array<f32>;
@group(1) @binding(5) 
var<storage> dot_b1_: array<f32>;
var<workgroup> scratch_a: array<f32, 64>;
var<workgroup> scratch_b: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var val0_: f32 = 0f;
    var val1_: f32 = 0f;
    var offset: u32 = 32u;

    let stride_x = (num_workgroups.x * 64u);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let lid = local_id.x;
    let _e15 = params.n;
    if (idx < _e15) {
        let _e19 = dot_a0_[idx];
        let _e22 = dot_b0_[idx];
        val0_ = (_e19 * _e22);
        let _e27 = dot_a1_[idx];
        let _e30 = dot_b1_[idx];
        val1_ = (_e27 * _e30);
    }
    let _e35 = val0_;
    scratch_a[lid] = _e35;
    let _e38 = val1_;
    scratch_b[lid] = _e38;
    workgroupBarrier();
    loop {
        let _e40 = offset;
        if (lid < _e40) {
            let _e45 = offset;
            let _e48 = scratch_a[(lid + _e45)];
            let _e49 = scratch_a[lid];
            scratch_a[lid] = (_e49 + _e48);
            let _e54 = offset;
            let _e57 = scratch_b[(lid + _e54)];
            let _e58 = scratch_b[lid];
            scratch_b[lid] = (_e58 + _e57);
        }
        workgroupBarrier();
        let _e60 = offset;
        if (_e60 == 1u) {
            break;
        }
        let _e63 = offset;
        offset = (_e63 >> 1u);
    }
    if (lid == 0u) {
        let group_flat = ((group_id.y * num_workgroups.x) + group_id.x);
        let _e76 = params.num_groups;
        if (group_flat < _e76) {
            let _e82 = scratch_a[0];
            dot_result_a[group_flat] = _e82;
            let _e87 = scratch_b[0];
            dot_result_b[group_flat] = _e87;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}
"#;
}
pub mod generated {
    use super::{_root, _root::*};
    pub mod dp_init_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    state: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.cell_vols, self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedDpInitIncompressibleMomentum::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::dp_init_incompressible_momentum::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedDpInitIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedDpInitIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("dp_init_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(2) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let _e15 = constants.density;
    let rho = max(_e15, 0.000000000001f);
    let _e20 = constants.dt;
    let dt = max(_e20, 0f);
    let _e25 = cell_vols[idx];
    let vol = max(_e25, 0.000000000001f);
    let _e30 = constants.alpha_u;
    let d_p = ((_e30 * dt) / rho);
    state[((idx * 8u) + 3u)] = d_p;
    return;
}
"#;
    }
    pub mod dp_update_from_diag_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    state: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.scalar_row_offsets,
                    self.diagonal_indices,
                    self.matrix_values,
                    self.state,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedDpUpdateFromDiagIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: dp_update_from_diag_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedDpUpdateFromDiagIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedDpUpdateFromDiagIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("dp_update_from_diag_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage> scalar_row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(4) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&scalar_row_offsets)) - 1u);
    if (idx >= num_cells) {
        return;
    }
    let _e15 = constants.density;
    let rho = max(_e15, 0.000000000001f);
    let _e20 = constants.dt;
    let dt = max(_e20, 0f);
    let _e25 = constants.alpha_u;
    let d_p = ((_e25 * dt) / rho);
    state[((idx * 8u) + 3u)] = d_p;
    return;
}
"#;
    }
    pub mod flux_module_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct LowMachParams {
            #[doc = "offset: 0, size: 4, type: `u32`"]
            pub model: u32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub theta_floor: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub pressure_coupling_alpha: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub _pad0: f32,
        }
        impl LowMachParams {
            pub const fn new(
                model: u32,
                theta_floor: f32,
                pressure_coupling_alpha: f32,
                _pad0: f32,
            ) -> Self {
                Self {
                    model,
                    theta_floor,
                    pressure_coupling_alpha,
                    _pad0,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub low_mach_params: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub low_mach_params: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    low_mach_params: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.low_mach_params),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                    self.low_mach_params,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"state_old_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"fluxes\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::flux_module_compressible::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"low_mach_params\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::flux_module_compressible::LowMachParams,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup2::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

struct LowMachParams {
    model: u32,
    theta_floor: f32,
    pressure_coupling_alpha: f32,
    _pad0_: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(1) @binding(5) 
var<uniform> low_mach_params: LowMachParams;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

fn bc_neighbor_scalar(interior: f32, owner: f32, kind: u32, value: f32, d_own: f32, is_boundary: bool) -> f32 {
    var boundary: f32;

    boundary = owner;
    if (kind == 1u) {
        boundary = value;
    }
    if (kind == 2u) {
        boundary = (owner + (value * d_own));
    }
    let _e13 = boundary;
    return select(interior, _e13, is_boundary);
}

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var neigh_idx: u32;
    var normal_vec: vec2<f32>;
    var c_neigh_vec: vec2<f32>;
    var lambda: f32 = 0.5f;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;
    var phi_3_: f32;
    var phi_4_: f32 = 0f;
    var phi_5_: f32 = 0f;
    var phi_6_: f32 = 0f;
    var phi_7_: f32 = 0f;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&face_areas))) {
        return;
    }
    let owner_1 = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let is_boundary_1 = (neighbor == -1i);
    neigh_idx = owner_1;
    if (neighbor != -1i) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let _e37 = face_normals[idx].x;
    let _e41 = face_normals[idx].y;
    normal_vec = vec2<f32>(_e37, _e41);
    let c_owner = cell_centers[owner_1];
    let c_owner_vec = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec = vec2<f32>(face_center.x, face_center.y);
    let _e54 = normal_vec;
    if (dot((face_center_vec - c_owner_vec), _e54) < 0f) {
        let _e58 = normal_vec;
        normal_vec = -(_e58);
    }
    let _e61 = neigh_idx;
    let c_neigh = cell_centers[_e61];
    c_neigh_vec = vec2<f32>(c_neigh.x, c_neigh.y);
    let c_neigh_cell_vec = c_neigh_vec;
    if is_boundary_1 {
        c_neigh_vec = face_center_vec;
    }
    let _e70 = normal_vec;
    let d_own_1 = abs(dot((face_center_vec - c_owner_vec), _e70));
    let _e73 = c_neigh_vec;
    let _e75 = normal_vec;
    let d_neigh = abs(dot((_e73 - face_center_vec), _e75));
    let total_dist = (d_own_1 + d_neigh);
    if (total_dist > 0.000001f) {
        lambda = (d_neigh / total_dist);
    }
    let _e83 = lambda;
    let lambda_other = (1f - _e83);
    let _e86 = c_neigh_vec;
    let d_vec = (_e86 - c_owner_vec);
    let _e88 = normal_vec;
    let dist_proj = abs(dot(d_vec, _e88));
    let dist = max(dist_proj, 0.000001f);
    let _e99 = state[((owner_1 * 22u) + 9u)];
    let _e106 = state[((owner_1 * 22u) + 9u)];
    let _e113 = bc_kind[((idx * 8u) + 7u)];
    let _e120 = bc_value[((idx * 8u) + 7u)];
    let _e121 = bc_neighbor_scalar(_e99, _e106, _e113, _e120, d_own_1, is_boundary_1);
    let s_own_grad_T_x = state[((owner_1 * 22u) + 16u)];
    let s_own_grad_T_y = state[((owner_1 * 22u) + 17u)];
    let s_own_grad_rho_x = state[((owner_1 * 22u) + 12u)];
    let s_own_grad_rho_y = state[((owner_1 * 22u) + 13u)];
    let s_own_grad_rho_u_x_x = state[((owner_1 * 22u) + 3u)];
    let s_own_grad_rho_u_x_y = state[((owner_1 * 22u) + 4u)];
    let s_own_grad_rho_u_y_x = state[((owner_1 * 22u) + 5u)];
    let s_own_grad_rho_u_y_y = state[((owner_1 * 22u) + 6u)];
    let s_own_grad_u_x_x = state[((owner_1 * 22u) + 18u)];
    let s_own_grad_u_x_y = state[((owner_1 * 22u) + 19u)];
    let s_own_grad_u_y_x = state[((owner_1 * 22u) + 20u)];
    let s_own_grad_u_y_y = state[((owner_1 * 22u) + 21u)];
    let _e212 = state[((owner_1 * 22u) + 0u)];
    let _e219 = state[((owner_1 * 22u) + 0u)];
    let _e226 = bc_kind[((idx * 8u) + 0u)];
    let _e233 = bc_value[((idx * 8u) + 0u)];
    let _e234 = bc_neighbor_scalar(_e212, _e219, _e226, _e233, d_own_1, is_boundary_1);
    let _e241 = state[((owner_1 * 22u) + 1u)];
    let _e248 = state[((owner_1 * 22u) + 1u)];
    let _e255 = bc_kind[((idx * 8u) + 1u)];
    let _e262 = bc_value[((idx * 8u) + 1u)];
    let _e263 = bc_neighbor_scalar(_e241, _e248, _e255, _e262, d_own_1, is_boundary_1);
    let _e270 = state[((owner_1 * 22u) + 1u)];
    let _e277 = state[((owner_1 * 22u) + 1u)];
    let _e279 = normal_vec.x;
    let _e287 = state[((owner_1 * 22u) + 2u)];
    let _e289 = normal_vec.y;
    let _e293 = normal_vec.x;
    let _cse_4_ = select(_e263, (_e270 - (((_e277 * _e279) + (_e287 * _e289)) * _e293)), (is_boundary_1 && (boundary_type == 4u)));
    let _e306 = state[((owner_1 * 22u) + 2u)];
    let _e313 = state[((owner_1 * 22u) + 2u)];
    let _e320 = bc_kind[((idx * 8u) + 2u)];
    let _e327 = bc_value[((idx * 8u) + 2u)];
    let _e328 = bc_neighbor_scalar(_e306, _e313, _e320, _e327, d_own_1, is_boundary_1);
    let _e335 = state[((owner_1 * 22u) + 2u)];
    let _e342 = state[((owner_1 * 22u) + 1u)];
    let _e344 = normal_vec.x;
    let _e352 = state[((owner_1 * 22u) + 2u)];
    let _e354 = normal_vec.y;
    let _e358 = normal_vec.y;
    let _cse_5_ = select(_e328, (_e335 - (((_e342 * _e344) + (_e352 * _e354)) * _e358)), (is_boundary_1 && (boundary_type == 4u)));
    let _e371 = state[((owner_1 * 22u) + 10u)];
    let _e378 = state[((owner_1 * 22u) + 10u)];
    let _e385 = bc_kind[((idx * 8u) + 4u)];
    let _e392 = bc_value[((idx * 8u) + 4u)];
    let _e393 = bc_neighbor_scalar(_e371, _e378, _e385, _e392, d_own_1, is_boundary_1);
    let _e400 = state[((owner_1 * 22u) + 10u)];
    let _e407 = state[((owner_1 * 22u) + 10u)];
    let _e409 = normal_vec.x;
    let _e417 = state[((owner_1 * 22u) + 11u)];
    let _e419 = normal_vec.y;
    let _e423 = normal_vec.x;
    let s_own_u_x = select(_e393, (_e400 - (((_e407 * _e409) + (_e417 * _e419)) * _e423)), (is_boundary_1 && (boundary_type == 4u)));
    let _e436 = state[((owner_1 * 22u) + 11u)];
    let _e443 = state[((owner_1 * 22u) + 11u)];
    let _e450 = bc_kind[((idx * 8u) + 5u)];
    let _e457 = bc_value[((idx * 8u) + 5u)];
    let _e458 = bc_neighbor_scalar(_e436, _e443, _e450, _e457, d_own_1, is_boundary_1);
    let _e465 = state[((owner_1 * 22u) + 11u)];
    let _e472 = state[((owner_1 * 22u) + 10u)];
    let _e474 = normal_vec.x;
    let _e482 = state[((owner_1 * 22u) + 11u)];
    let _e484 = normal_vec.y;
    let _e488 = normal_vec.y;
    let s_own_u_y = select(_e458, (_e465 - (((_e472 * _e474) + (_e482 * _e484)) * _e488)), (is_boundary_1 && (boundary_type == 4u)));
    let _e495 = neigh_idx;
    let _e502 = state[((_e495 * 22u) + 9u)];
    let _e509 = state[((owner_1 * 22u) + 9u)];
    let _e516 = bc_kind[((idx * 8u) + 7u)];
    let _e523 = bc_value[((idx * 8u) + 7u)];
    let _e524 = bc_neighbor_scalar(_e502, _e509, _e516, _e523, d_own_1, is_boundary_1);
    let _e525 = neigh_idx;
    let _e532 = state[((_e525 * 22u) + 16u)];
    let _e539 = state[((owner_1 * 22u) + 16u)];
    let s_neigh_grad_T_x = select(_e532, _e539, is_boundary_1);
    let _e541 = neigh_idx;
    let _e548 = state[((_e541 * 22u) + 17u)];
    let _e555 = state[((owner_1 * 22u) + 17u)];
    let s_neigh_grad_T_y = select(_e548, _e555, is_boundary_1);
    let _e557 = neigh_idx;
    let _e564 = state[((_e557 * 22u) + 12u)];
    let _e571 = state[((owner_1 * 22u) + 12u)];
    let s_neigh_grad_rho_x = select(_e564, _e571, is_boundary_1);
    let _e573 = neigh_idx;
    let _e580 = state[((_e573 * 22u) + 13u)];
    let _e587 = state[((owner_1 * 22u) + 13u)];
    let s_neigh_grad_rho_y = select(_e580, _e587, is_boundary_1);
    let _e589 = neigh_idx;
    let _e596 = state[((_e589 * 22u) + 3u)];
    let _e603 = state[((owner_1 * 22u) + 3u)];
    let s_neigh_grad_rho_u_x_x = select(_e596, _e603, is_boundary_1);
    let _e605 = neigh_idx;
    let _e612 = state[((_e605 * 22u) + 4u)];
    let _e619 = state[((owner_1 * 22u) + 4u)];
    let s_neigh_grad_rho_u_x_y = select(_e612, _e619, is_boundary_1);
    let _e621 = neigh_idx;
    let _e628 = state[((_e621 * 22u) + 5u)];
    let _e635 = state[((owner_1 * 22u) + 5u)];
    let s_neigh_grad_rho_u_y_x = select(_e628, _e635, is_boundary_1);
    let _e637 = neigh_idx;
    let _e644 = state[((_e637 * 22u) + 6u)];
    let _e651 = state[((owner_1 * 22u) + 6u)];
    let s_neigh_grad_rho_u_y_y = select(_e644, _e651, is_boundary_1);
    let _e653 = neigh_idx;
    let _e660 = state[((_e653 * 22u) + 18u)];
    let _e667 = state[((owner_1 * 22u) + 18u)];
    let s_neigh_grad_u_x_x = select(_e660, _e667, is_boundary_1);
    let _e669 = neigh_idx;
    let _e676 = state[((_e669 * 22u) + 19u)];
    let _e683 = state[((owner_1 * 22u) + 19u)];
    let s_neigh_grad_u_x_y = select(_e676, _e683, is_boundary_1);
    let _e685 = neigh_idx;
    let _e692 = state[((_e685 * 22u) + 20u)];
    let _e699 = state[((owner_1 * 22u) + 20u)];
    let s_neigh_grad_u_y_x = select(_e692, _e699, is_boundary_1);
    let _e701 = neigh_idx;
    let _e708 = state[((_e701 * 22u) + 21u)];
    let _e715 = state[((owner_1 * 22u) + 21u)];
    let s_neigh_grad_u_y_y = select(_e708, _e715, is_boundary_1);
    let _e717 = neigh_idx;
    let _e724 = state[((_e717 * 22u) + 0u)];
    let _e731 = state[((owner_1 * 22u) + 0u)];
    let _e738 = bc_kind[((idx * 8u) + 0u)];
    let _e745 = bc_value[((idx * 8u) + 0u)];
    let _e746 = bc_neighbor_scalar(_e724, _e731, _e738, _e745, d_own_1, is_boundary_1);
    let _e747 = neigh_idx;
    let _e754 = state[((_e747 * 22u) + 1u)];
    let _e761 = state[((owner_1 * 22u) + 1u)];
    let _e768 = bc_kind[((idx * 8u) + 1u)];
    let _e775 = bc_value[((idx * 8u) + 1u)];
    let _e776 = bc_neighbor_scalar(_e754, _e761, _e768, _e775, d_own_1, is_boundary_1);
    let _e783 = state[((owner_1 * 22u) + 1u)];
    let _e790 = state[((owner_1 * 22u) + 1u)];
    let _e792 = normal_vec.x;
    let _e800 = state[((owner_1 * 22u) + 2u)];
    let _e802 = normal_vec.y;
    let _e806 = normal_vec.x;
    let _cse_33_ = select(_e776, (_e783 - (((_e790 * _e792) + (_e800 * _e802)) * _e806)), (is_boundary_1 && (boundary_type == 4u)));
    let _e813 = neigh_idx;
    let _e820 = state[((_e813 * 22u) + 2u)];
    let _e827 = state[((owner_1 * 22u) + 2u)];
    let _e834 = bc_kind[((idx * 8u) + 2u)];
    let _e841 = bc_value[((idx * 8u) + 2u)];
    let _e842 = bc_neighbor_scalar(_e820, _e827, _e834, _e841, d_own_1, is_boundary_1);
    let _e849 = state[((owner_1 * 22u) + 2u)];
    let _e856 = state[((owner_1 * 22u) + 1u)];
    let _e858 = normal_vec.x;
    let _e866 = state[((owner_1 * 22u) + 2u)];
    let _e868 = normal_vec.y;
    let _e872 = normal_vec.y;
    let _cse_34_ = select(_e842, (_e849 - (((_e856 * _e858) + (_e866 * _e868)) * _e872)), (is_boundary_1 && (boundary_type == 4u)));
    let _cse_3_ = vec2<f32>(_cse_4_, _cse_5_);
    let _cse_2_ = ((_cse_3_ * 1f) / vec2(_e234));
    let _e886 = constants.dtau;
    let _e889 = constants.dtau;
    let _cse_17_ = max(0f, (_e886 / (_e889 + 0.000000000001f)));
    let _cse_16_ = min(1f, _cse_17_);
    let _e899 = constants.eos_r;
    let _cse_23_ = ((_e234 * _e899) * _e121);
    let _e904 = constants.eos_gamma;
    let _cse_22_ = (_e904 * _cse_23_);
    let _cse_21_ = (_cse_22_ / _e234);
    let _e909 = constants.eos_dp_drho;
    let _cse_20_ = (_cse_21_ + _e909);
    let _cse_26_ = dot(_cse_2_, _cse_2_);
    let _cse_25_ = min(_cse_26_, _cse_20_);
    let _e915 = low_mach_params.model;
    let _cse_24_ = (max(0f, (1f - abs(f32(_e915)))) * _cse_25_);
    let _e925 = low_mach_params.model;
    let _cse_19_ = ((max(0f, (1f - abs((f32(_e925) - 2f)))) * _cse_20_) + _cse_24_);
    let _e938 = low_mach_params.theta_floor;
    let _cse_29_ = max(_cse_26_, (_e938 * _cse_20_));
    let _cse_28_ = min(_cse_29_, _cse_20_);
    let _e944 = low_mach_params.model;
    let _cse_27_ = (max(0f, (1f - abs((f32(_e944) - 1f)))) * _cse_28_);
    let _cse_18_ = (_cse_19_ + _cse_27_);
    let _cse_15_ = (_cse_16_ * _cse_18_);
    let _cse_14_ = (_cse_15_ + ((1f - _cse_16_) * _cse_20_));
    let _cse_13_ = (_cse_14_ / max(_cse_20_, 0.000000000001f));
    let _cse_12_ = sqrt(_cse_13_);
    let _e966 = constants.eos_gamma;
    let _e969 = constants.eos_r;
    let _cse_11_ = (sqrt(((_e966 * _e969) * _e121)) * _cse_12_);
    let _cse_10_ = (_cse_11_ * area);
    let _e975 = normal_vec;
    let _cse_9_ = (dot(_cse_2_, (_e975 * area)) + _cse_10_);
    let _cse_32_ = vec2<f32>(_cse_33_, _cse_34_);
    let _cse_31_ = ((_cse_32_ * 1f) / vec2(_e746));
    let _e986 = constants.eos_r;
    let _cse_46_ = ((_e746 * _e986) * _e524);
    let _e991 = constants.eos_gamma;
    let _cse_45_ = (_e991 * _cse_46_);
    let _cse_44_ = (_cse_45_ / _e746);
    let _e996 = constants.eos_dp_drho;
    let _cse_43_ = (_cse_44_ + _e996);
    let _cse_49_ = dot(_cse_31_, _cse_31_);
    let _cse_48_ = min(_cse_49_, _cse_43_);
    let _e1002 = low_mach_params.model;
    let _cse_47_ = (max(0f, (1f - abs(f32(_e1002)))) * _cse_48_);
    let _e1012 = low_mach_params.model;
    let _cse_42_ = ((max(0f, (1f - abs((f32(_e1012) - 2f)))) * _cse_43_) + _cse_47_);
    let _e1025 = low_mach_params.theta_floor;
    let _cse_52_ = max(_cse_49_, (_e1025 * _cse_43_));
    let _cse_51_ = min(_cse_52_, _cse_43_);
    let _e1031 = low_mach_params.model;
    let _cse_50_ = (max(0f, (1f - abs((f32(_e1031) - 1f)))) * _cse_51_);
    let _cse_41_ = (_cse_42_ + _cse_50_);
    let _cse_40_ = (_cse_16_ * _cse_41_);
    let _cse_39_ = (_cse_40_ + ((1f - _cse_16_) * _cse_43_));
    let _cse_38_ = (_cse_39_ / max(_cse_43_, 0.000000000001f));
    let _cse_37_ = sqrt(_cse_38_);
    let _e1053 = constants.eos_gamma;
    let _e1056 = constants.eos_r;
    let _cse_36_ = (sqrt(((_e1053 * _e1056) * _e524)) * _cse_37_);
    let _cse_35_ = (_cse_36_ * area);
    let _e1062 = normal_vec;
    let _cse_30_ = (dot(_cse_31_, (_e1062 * area)) + _cse_35_);
    let _cse_8_ = max(_cse_9_, _cse_30_);
    let _cse_7_ = max(_cse_8_, 0f);
    let _e1069 = normal_vec;
    let _cse_57_ = (dot(_cse_2_, (_e1069 * area)) - _cse_10_);
    let _e1073 = normal_vec;
    let _cse_58_ = (dot(_cse_31_, (_e1073 * area)) - _cse_35_);
    let _cse_56_ = min(_cse_57_, _cse_58_);
    let _cse_55_ = min(_cse_56_, 0f);
    let _cse_54_ = (_cse_7_ - _cse_55_);
    let _cse_53_ = max(_cse_54_, 0.000001f);
    let _cse_6_ = (_cse_7_ / _cse_53_);
    let _e1084 = normal_vec;
    let _cse_1_ = (dot(_cse_2_, (_e1084 * area)) * _cse_6_);
    let _cse_59_ = (_cse_55_ * _cse_6_);
    let _cse_0_ = (_cse_1_ - _cse_59_);
    let _cse_62_ = (1f - _cse_6_);
    let _e1092 = normal_vec;
    let _cse_61_ = (dot(_cse_31_, (_e1092 * area)) * _cse_62_);
    let _cse_60_ = (_cse_61_ + _cse_59_);
    let _cse_63_ = ((_cse_6_ * _cse_23_) + (_cse_62_ * _cse_46_));
    let _e1105 = low_mach_params.pressure_coupling_alpha;
    let _e1123 = low_mach_params.model;
    phi_0_ = (((_cse_0_ * _e234) + (_cse_60_ * _e746)) + ((((((_e1105 * (_cse_23_ - _cse_46_)) * 0.5f) * ((1f / max(_cse_20_, 0.000000000001f)) + (1f / max(_cse_43_, 0.000000000001f)))) * _cse_16_) * (1f - max(0f, (1f - abs((f32(_e1123) - 2f)))))) * area));
    let _e1145 = normal_vec.x;
    let _e1150 = constants.viscosity;
    let _e1164 = normal_vec.x;
    let _e1172 = normal_vec.y;
    let _e1176 = lambda;
    let _e1180 = constants.viscosity;
    let _e1188 = normal_vec.x;
    let _e1192 = normal_vec.y;
    phi_1_ = ((((_cse_0_ * _cse_3_.x) + (_cse_60_ * _cse_32_.x)) + ((_cse_63_ * area) * _e1145)) - ((((_e1150 * ((((2f * select(s_neigh_grad_u_x_x, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e1164) + ((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e1172))) * _e1176) + ((_e1180 * ((((2f * s_own_grad_u_x_x) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e1188) + ((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e1192))) * lambda_other)) * area));
    let _e1208 = normal_vec.y;
    let _e1213 = constants.viscosity;
    let _e1220 = normal_vec.x;
    let _e1235 = normal_vec.y;
    let _e1239 = lambda;
    let _e1243 = constants.viscosity;
    let _e1246 = normal_vec.x;
    let _e1255 = normal_vec.y;
    phi_2_ = ((((_cse_0_ * _cse_3_.y) + (_cse_60_ * _cse_32_.y)) + ((_cse_63_ * area) * _e1208)) - ((((_e1213 * (((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e1220) + (((2f * select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e1235))) * _e1239) + ((_e1243 * (((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e1246) + (((2f * s_own_grad_u_y_y) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e1255))) * lambda_other)) * area));
    let _e1266 = constants.eos_gm1_;
    let _e1278 = constants.eos_gm1_;
    let _e1297 = lambda;
    let _e1302 = normal_vec;
    let _e1313 = state[((owner_1 * 22u) + 10u)];
    let _e1318 = normal_vec;
    let _e1324 = lambda;
    let _e1333 = normal_vec;
    let _e1340 = lambda;
    let _e1345 = normal_vec;
    let _e1356 = state[((owner_1 * 22u) + 11u)];
    let _e1361 = normal_vec;
    let _e1367 = lambda;
    let _e1376 = normal_vec;
    let _e1381 = constants.viscosity;
    let _e1385 = constants.viscosity;
    let _e1399 = normal_vec.x;
    let _e1407 = normal_vec.y;
    let _e1411 = lambda;
    let _e1415 = constants.viscosity;
    let _e1423 = normal_vec.x;
    let _e1427 = normal_vec.y;
    let _e1435 = constants.viscosity;
    let _e1442 = normal_vec.x;
    let _e1457 = normal_vec.y;
    let _e1461 = lambda;
    let _e1465 = constants.viscosity;
    let _e1468 = normal_vec.x;
    let _e1477 = normal_vec.y;
    phi_3_ = ((((_cse_0_ * (((_cse_23_ / max(_e1266, 0.000000000001f)) + ((0.5f * _e234) * _cse_26_)) + _cse_23_)) + (_cse_60_ * (((_cse_46_ / max(_e1278, 0.000000000001f)) + ((0.5f * _e746) * _cse_49_)) + _cse_46_))) + (_cse_59_ * (_cse_23_ - _cse_46_))) - (dot(((vec2<f32>(dot((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e1297) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e1302 * select(0f, 1f, is_boundary_1)) * (((s_own_u_x - _e1313) / max(dist, 0.000001f)) - dot(_e1318, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e1324) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))), _e1333), dot((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e1340) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e1345 * select(0f, 1f, is_boundary_1)) * (((s_own_u_y - _e1356) / max(dist, 0.000001f)) - dot(_e1361, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e1367) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))), _e1376)) * _e1381) + vec2<f32>((((_e1385 * ((((2f * select(s_neigh_grad_u_x_x, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e1399) + ((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e1407))) * _e1411) + ((_e1415 * ((((2f * s_own_grad_u_x_x) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e1423) + ((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e1427))) * lambda_other)), (((_e1435 * (((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e1442) + (((2f * select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e1457))) * _e1461) + ((_e1465 * (((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e1468) + (((2f * s_own_grad_u_y_y) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e1477))) * lambda_other)))), ((_cse_2_ * _cse_6_) + (_cse_31_ * _cse_62_))) * area));
    let _e1494 = constants.scheme;
    if ((_e1494 == 1u) && !(is_boundary_1)) {
        let _cse_67_ = vec2<f32>((_cse_4_ + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec))), (_cse_5_ + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec))));
        let _cse_69_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec));
        let _cse_68_ = (_e234 + _cse_69_);
        let _cse_66_ = ((_cse_67_ * 1f) / vec2(_cse_68_));
        let _e1518 = constants.eos_r;
        let _cse_85_ = ((_cse_68_ * _e1518) * (_e121 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec))));
        let _e1527 = constants.eos_gamma;
        let _cse_84_ = (_e1527 * _cse_85_);
        let _cse_83_ = (_cse_84_ / _cse_68_);
        let _e1532 = constants.eos_dp_drho;
        let _cse_82_ = (_cse_83_ + _e1532);
        let _cse_88_ = dot(_cse_66_, _cse_66_);
        let _cse_87_ = min(_cse_88_, _cse_82_);
        let _e1538 = low_mach_params.model;
        let _cse_86_ = (max(0f, (1f - abs(f32(_e1538)))) * _cse_87_);
        let _e1548 = low_mach_params.model;
        let _cse_81_ = ((max(0f, (1f - abs((f32(_e1548) - 2f)))) * _cse_82_) + _cse_86_);
        let _e1561 = low_mach_params.theta_floor;
        let _cse_91_ = max(_cse_88_, (_e1561 * _cse_82_));
        let _cse_90_ = min(_cse_91_, _cse_82_);
        let _e1567 = low_mach_params.model;
        let _cse_89_ = (max(0f, (1f - abs((f32(_e1567) - 1f)))) * _cse_90_);
        let _cse_80_ = (_cse_81_ + _cse_89_);
        let _e1580 = constants.dtau;
        let _e1583 = constants.dtau;
        let _cse_79_ = (min(1f, max(0f, (_e1580 / (_e1583 + 0.000000000001f)))) * _cse_80_);
        let _e1594 = constants.dtau;
        let _e1597 = constants.dtau;
        let _cse_78_ = (_cse_79_ + ((1f - min(1f, max(0f, (_e1594 / (_e1597 + 0.000000000001f))))) * _cse_82_));
        let _cse_77_ = (_cse_78_ / max(_cse_82_, 0.000000000001f));
        let _cse_76_ = sqrt(_cse_77_);
        let _e1615 = constants.eos_gamma;
        let _e1618 = constants.eos_r;
        let _e1627 = constants.eos_gamma;
        let _e1631 = constants.eos_r;
        let _e1635 = constants.eos_gamma;
        let _e1638 = constants.eos_r;
        let _cse_75_ = ((sqrt(((_e1615 * _e1618) * _e121)) + dot(((((vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5f) * _e1627) * _e1631) / vec2(max(sqrt(((_e1635 * _e1638) * _e121)), 0.000000000001f))), (face_center_vec - c_owner_vec))) * _cse_76_);
        let _cse_74_ = (_cse_75_ * area);
        let _e1651 = normal_vec;
        let _cse_73_ = (dot(_cse_66_, (_e1651 * area)) + _cse_74_);
        let _cse_95_ = (_cse_33_ + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)));
        let _cse_96_ = (_cse_34_ + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)));
        let _cse_94_ = vec2<f32>(_cse_95_, _cse_96_);
        let _cse_99_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_98_ = dot(_cse_99_, (face_center_vec - c_neigh_cell_vec));
        let _cse_97_ = (_e746 + _cse_98_);
        let _cse_93_ = ((_cse_94_ * 1f) / vec2(_cse_97_));
        let _e1686 = constants.eos_r;
        let _cse_111_ = ((_cse_97_ * _e1686) * (_e524 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec))));
        let _e1699 = constants.eos_gamma;
        let _cse_110_ = (_e1699 * _cse_111_);
        let _cse_109_ = (_cse_110_ / _cse_97_);
        let _e1704 = constants.eos_dp_drho;
        let _cse_108_ = (_cse_109_ + _e1704);
        let _cse_114_ = dot(_cse_93_, _cse_93_);
        let _cse_113_ = min(_cse_114_, _cse_108_);
        let _e1710 = low_mach_params.model;
        let _cse_112_ = (max(0f, (1f - abs(f32(_e1710)))) * _cse_113_);
        let _e1720 = low_mach_params.model;
        let _cse_107_ = ((max(0f, (1f - abs((f32(_e1720) - 2f)))) * _cse_108_) + _cse_112_);
        let _e1733 = low_mach_params.theta_floor;
        let _cse_117_ = max(_cse_114_, (_e1733 * _cse_108_));
        let _cse_116_ = min(_cse_117_, _cse_108_);
        let _e1739 = low_mach_params.model;
        let _cse_115_ = (max(0f, (1f - abs((f32(_e1739) - 1f)))) * _cse_116_);
        let _cse_106_ = (_cse_107_ + _cse_115_);
        let _e1752 = constants.dtau;
        let _e1755 = constants.dtau;
        let _cse_105_ = (min(1f, max(0f, (_e1752 / (_e1755 + 0.000000000001f)))) * _cse_106_);
        let _e1766 = constants.dtau;
        let _e1769 = constants.dtau;
        let _cse_104_ = (_cse_105_ + ((1f - min(1f, max(0f, (_e1766 / (_e1769 + 0.000000000001f))))) * _cse_108_));
        let _cse_103_ = (_cse_104_ / max(_cse_108_, 0.000000000001f));
        let _cse_102_ = sqrt(_cse_103_);
        let _e1787 = constants.eos_gamma;
        let _e1790 = constants.eos_r;
        let _e1803 = constants.eos_gamma;
        let _e1807 = constants.eos_r;
        let _e1811 = constants.eos_gamma;
        let _e1814 = constants.eos_r;
        let _cse_101_ = ((sqrt(((_e1787 * _e1790) * _e524)) + dot(((((vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)) * 0.5f) * _e1803) * _e1807) / vec2(max(sqrt(((_e1811 * _e1814) * _e524)), 0.000000000001f))), (face_center_vec - c_neigh_cell_vec))) * _cse_102_);
        let _cse_100_ = (_cse_101_ * area);
        let _e1827 = normal_vec;
        let _cse_92_ = (dot(_cse_93_, (_e1827 * area)) + _cse_100_);
        let _cse_72_ = max(_cse_73_, _cse_92_);
        let _cse_71_ = max(_cse_72_, 0f);
        let _e1834 = normal_vec;
        let _cse_122_ = (dot(_cse_66_, (_e1834 * area)) - _cse_74_);
        let _e1838 = normal_vec;
        let _cse_123_ = (dot(_cse_93_, (_e1838 * area)) - _cse_100_);
        let _cse_121_ = min(_cse_122_, _cse_123_);
        let _cse_120_ = min(_cse_121_, 0f);
        let _cse_119_ = (_cse_71_ - _cse_120_);
        let _cse_118_ = max(_cse_119_, 0.000001f);
        let _cse_70_ = (_cse_71_ / _cse_118_);
        let _e1849 = normal_vec;
        let _cse_65_ = (dot(_cse_66_, (_e1849 * area)) * _cse_70_);
        let _cse_124_ = (_cse_120_ * _cse_70_);
        let _cse_64_ = (_cse_65_ - _cse_124_);
        let _cse_127_ = (1f - _cse_70_);
        let _e1857 = normal_vec;
        let _cse_126_ = (dot(_cse_93_, (_e1857 * area)) * _cse_127_);
        let _cse_125_ = (_cse_126_ + _cse_124_);
        let _e1867 = low_mach_params.pressure_coupling_alpha;
        let _e1884 = constants.dtau;
        let _e1887 = constants.dtau;
        let _e1898 = low_mach_params.model;
        phi_0_ = (((_cse_64_ * _cse_68_) + (_cse_125_ * _cse_97_)) + ((((((_e1867 * (_cse_85_ - _cse_111_)) * 0.5f) * ((1f / max(_cse_82_, 0.000000000001f)) + (1f / max(_cse_108_, 0.000000000001f)))) * min(1f, max(0f, (_e1884 / (_e1887 + 0.000000000001f))))) * (1f - max(0f, (1f - abs((f32(_e1898) - 2f)))))) * area));
        let _e1922 = normal_vec.x;
        let _e1927 = constants.viscosity;
        let _e1941 = normal_vec.x;
        let _e1949 = normal_vec.y;
        let _e1953 = lambda;
        let _e1957 = constants.viscosity;
        let _e1965 = normal_vec.x;
        let _e1969 = normal_vec.y;
        phi_1_ = ((((_cse_64_ * _cse_67_.x) + (_cse_125_ * _cse_94_.x)) + ((((_cse_70_ * _cse_85_) + (_cse_127_ * _cse_111_)) * area) * _e1922)) - ((((_e1927 * ((((2f * select(s_neigh_grad_u_x_x, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e1941) + ((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e1949))) * _e1953) + ((_e1957 * ((((2f * s_own_grad_u_x_x) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e1965) + ((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e1969))) * lambda_other)) * area));
        let _e1987 = normal_vec.y;
        let _e1992 = constants.viscosity;
        let _e1999 = normal_vec.x;
        let _e2014 = normal_vec.y;
        let _e2018 = lambda;
        let _e2022 = constants.viscosity;
        let _e2025 = normal_vec.x;
        let _e2034 = normal_vec.y;
        phi_2_ = ((((_cse_64_ * _cse_67_.y) + (_cse_125_ * _cse_94_.y)) + ((((_cse_70_ * _cse_85_) + (_cse_127_ * _cse_111_)) * area) * _e1987)) - ((((_e1992 * (((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e1999) + (((2f * select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e2014))) * _e2018) + ((_e2022 * (((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e2025) + (((2f * s_own_grad_u_y_y) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e2034))) * lambda_other)) * area));
        let _e2044 = constants.eos_gm1_;
        let _e2056 = constants.eos_gm1_;
        let _e2075 = lambda;
        let _e2080 = normal_vec;
        let _e2091 = state[((owner_1 * 22u) + 10u)];
        let _e2096 = normal_vec;
        let _e2102 = lambda;
        let _e2111 = normal_vec;
        let _e2118 = lambda;
        let _e2123 = normal_vec;
        let _e2134 = state[((owner_1 * 22u) + 11u)];
        let _e2139 = normal_vec;
        let _e2145 = lambda;
        let _e2154 = normal_vec;
        let _e2159 = constants.viscosity;
        let _e2163 = constants.viscosity;
        let _e2177 = normal_vec.x;
        let _e2185 = normal_vec.y;
        let _e2189 = lambda;
        let _e2193 = constants.viscosity;
        let _e2201 = normal_vec.x;
        let _e2205 = normal_vec.y;
        let _e2213 = constants.viscosity;
        let _e2220 = normal_vec.x;
        let _e2235 = normal_vec.y;
        let _e2239 = lambda;
        let _e2243 = constants.viscosity;
        let _e2246 = normal_vec.x;
        let _e2255 = normal_vec.y;
        phi_3_ = ((((_cse_64_ * (((_cse_85_ / max(_e2044, 0.000000000001f)) + ((0.5f * _cse_68_) * _cse_88_)) + _cse_85_)) + (_cse_125_ * (((_cse_111_ / max(_e2056, 0.000000000001f)) + ((0.5f * _cse_97_) * _cse_114_)) + _cse_111_))) + (_cse_124_ * (_cse_85_ - _cse_111_))) - (dot(((vec2<f32>(dot((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e2075) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e2080 * select(0f, 1f, is_boundary_1)) * (((s_own_u_x - _e2091) / max(dist, 0.000001f)) - dot(_e2096, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e2102) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))), _e2111), dot((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e2118) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e2123 * select(0f, 1f, is_boundary_1)) * (((s_own_u_y - _e2134) / max(dist, 0.000001f)) - dot(_e2139, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e2145) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))), _e2154)) * _e2159) + vec2<f32>((((_e2163 * ((((2f * select(s_neigh_grad_u_x_x, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e2177) + ((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e2185))) * _e2189) + ((_e2193 * ((((2f * s_own_grad_u_x_x) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e2201) + ((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e2205))) * lambda_other)), (((_e2213 * (((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e2220) + (((2f * select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e2235))) * _e2239) + ((_e2243 * (((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e2246) + (((2f * s_own_grad_u_y_y) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e2255))) * lambda_other)))), ((_cse_66_ * _cse_70_) + (_cse_93_ * _cse_127_))) * area));
        phi_4_ = 0f;
        phi_5_ = 0f;
        phi_6_ = 0f;
        phi_7_ = 0f;
    }
    let _e2279 = constants.scheme;
    if ((_e2279 == 2u) && !(is_boundary_1)) {
        let _cse_131_ = vec2<f32>(((((_cse_4_ + (_cse_4_ * 0.625f)) + (_cse_33_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_4_), ((((_cse_5_ + (_cse_5_ * 0.625f)) + (_cse_34_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_5_));
        let _cse_134_ = (((_e234 * 0.625f) + (_e746 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_133_ = (_cse_134_ - _e234);
        let _cse_132_ = (_e234 + _cse_133_);
        let _cse_130_ = ((_cse_131_ * 1f) / vec2(_cse_132_));
        let _e2330 = constants.eos_gamma;
        let _e2334 = constants.eos_r;
        let _cse_148_ = ((((_e2330 * _cse_132_) * _e2334) * ((((_e121 + (_e121 * 0.625f)) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) / _cse_132_);
        let _e2353 = constants.eos_dp_drho;
        let _cse_147_ = (_cse_148_ + _e2353);
        let _cse_151_ = dot(_cse_130_, _cse_130_);
        let _cse_150_ = min(_cse_151_, _cse_147_);
        let _e2359 = low_mach_params.model;
        let _cse_149_ = (max(0f, (1f - abs(f32(_e2359)))) * _cse_150_);
        let _e2369 = low_mach_params.model;
        let _cse_146_ = ((max(0f, (1f - abs((f32(_e2369) - 2f)))) * _cse_147_) + _cse_149_);
        let _e2382 = low_mach_params.theta_floor;
        let _cse_154_ = max(_cse_151_, (_e2382 * _cse_147_));
        let _cse_153_ = min(_cse_154_, _cse_147_);
        let _e2388 = low_mach_params.model;
        let _cse_152_ = (max(0f, (1f - abs((f32(_e2388) - 1f)))) * _cse_153_);
        let _cse_145_ = (_cse_146_ + _cse_152_);
        let _e2401 = constants.dtau;
        let _e2404 = constants.dtau;
        let _cse_144_ = (min(1f, max(0f, (_e2401 / (_e2404 + 0.000000000001f)))) * _cse_145_);
        let _e2415 = constants.dtau;
        let _e2418 = constants.dtau;
        let _cse_143_ = (_cse_144_ + ((1f - min(1f, max(0f, (_e2415 / (_e2418 + 0.000000000001f))))) * _cse_147_));
        let _cse_142_ = (_cse_143_ / max(_cse_147_, 0.000000000001f));
        let _cse_141_ = sqrt(_cse_142_);
        let _e2436 = constants.eos_gamma;
        let _e2439 = constants.eos_r;
        let _e2445 = constants.eos_gamma;
        let _e2448 = constants.eos_r;
        let _e2457 = constants.eos_gamma;
        let _e2460 = constants.eos_r;
        let _e2472 = constants.eos_gamma;
        let _e2476 = constants.eos_r;
        let _e2480 = constants.eos_gamma;
        let _e2483 = constants.eos_r;
        let _e2498 = constants.eos_gamma;
        let _e2501 = constants.eos_r;
        let _cse_140_ = (((((sqrt(((_e2436 * _e2439) * _e121)) + (sqrt(((_e2445 * _e2448) * _e121)) * 0.625f)) + (sqrt(((_e2457 * _e2460) * _e524)) * 0.375f)) + (dot(((((vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5f) * _e2472) * _e2476) / vec2(max(sqrt(((_e2480 * _e2483) * _e121)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - sqrt(((_e2498 * _e2501) * _e121))) * _cse_141_);
        let _cse_139_ = (_cse_140_ * area);
        let _e2508 = normal_vec;
        let _cse_138_ = (dot(_cse_130_, (_e2508 * area)) + _cse_139_);
        let _cse_158_ = ((((_cse_33_ + (_cse_33_ * 0.625f)) + (_cse_4_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_33_);
        let _cse_159_ = ((((_cse_34_ + (_cse_34_ * 0.625f)) + (_cse_5_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_34_);
        let _cse_157_ = vec2<f32>(_cse_158_, _cse_159_);
        let _cse_163_ = (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f);
        let _cse_162_ = (((_e746 * 0.625f) + (_e234 * 0.375f)) + _cse_163_);
        let _cse_161_ = (_cse_162_ - _e746);
        let _cse_160_ = (_e746 + _cse_161_);
        let _cse_156_ = ((_cse_157_ * 1f) / vec2(_cse_160_));
        let _e2570 = constants.eos_r;
        let _cse_175_ = ((_cse_160_ * _e2570) * ((((_e524 + (_e524 * 0.625f)) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e524));
        let _e2592 = constants.eos_gamma;
        let _cse_174_ = (_e2592 * _cse_175_);
        let _cse_173_ = (_cse_174_ / _cse_160_);
        let _e2597 = constants.eos_dp_drho;
        let _cse_172_ = (_cse_173_ + _e2597);
        let _cse_178_ = dot(_cse_156_, _cse_156_);
        let _cse_177_ = min(_cse_178_, _cse_172_);
        let _e2603 = low_mach_params.model;
        let _cse_176_ = (max(0f, (1f - abs(f32(_e2603)))) * _cse_177_);
        let _e2613 = low_mach_params.model;
        let _cse_171_ = ((max(0f, (1f - abs((f32(_e2613) - 2f)))) * _cse_172_) + _cse_176_);
        let _e2626 = low_mach_params.theta_floor;
        let _cse_181_ = max(_cse_178_, (_e2626 * _cse_172_));
        let _cse_180_ = min(_cse_181_, _cse_172_);
        let _e2632 = low_mach_params.model;
        let _cse_179_ = (max(0f, (1f - abs((f32(_e2632) - 1f)))) * _cse_180_);
        let _cse_170_ = (_cse_171_ + _cse_179_);
        let _e2645 = constants.dtau;
        let _e2648 = constants.dtau;
        let _cse_169_ = (min(1f, max(0f, (_e2645 / (_e2648 + 0.000000000001f)))) * _cse_170_);
        let _e2659 = constants.dtau;
        let _e2662 = constants.dtau;
        let _cse_168_ = (_cse_169_ + ((1f - min(1f, max(0f, (_e2659 / (_e2662 + 0.000000000001f))))) * _cse_172_));
        let _cse_167_ = (_cse_168_ / max(_cse_172_, 0.000000000001f));
        let _cse_166_ = sqrt(_cse_167_);
        let _e2680 = constants.eos_gamma;
        let _e2683 = constants.eos_r;
        let _e2689 = constants.eos_gamma;
        let _e2692 = constants.eos_r;
        let _e2701 = constants.eos_gamma;
        let _e2704 = constants.eos_r;
        let _e2720 = constants.eos_gamma;
        let _e2724 = constants.eos_r;
        let _e2728 = constants.eos_gamma;
        let _e2731 = constants.eos_r;
        let _e2746 = constants.eos_gamma;
        let _e2749 = constants.eos_r;
        let _cse_165_ = (((((sqrt(((_e2680 * _e2683) * _e524)) + (sqrt(((_e2689 * _e2692) * _e524)) * 0.625f)) + (sqrt(((_e2701 * _e2704) * _e121)) * 0.375f)) + (dot(((((vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)) * 0.5f) * _e2720) * _e2724) / vec2(max(sqrt(((_e2728 * _e2731) * _e524)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - sqrt(((_e2746 * _e2749) * _e524))) * _cse_166_);
        let _cse_164_ = (_cse_165_ * area);
        let _e2756 = normal_vec;
        let _cse_155_ = (dot(_cse_156_, (_e2756 * area)) + _cse_164_);
        let _cse_137_ = max(_cse_138_, _cse_155_);
        let _cse_136_ = max(_cse_137_, 0f);
        let _e2763 = normal_vec;
        let _cse_186_ = (dot(_cse_130_, (_e2763 * area)) - _cse_139_);
        let _e2767 = normal_vec;
        let _cse_187_ = (dot(_cse_156_, (_e2767 * area)) - _cse_164_);
        let _cse_185_ = min(_cse_186_, _cse_187_);
        let _cse_184_ = min(_cse_185_, 0f);
        let _cse_183_ = (_cse_136_ - _cse_184_);
        let _cse_182_ = max(_cse_183_, 0.000001f);
        let _cse_135_ = (_cse_136_ / _cse_182_);
        let _e2778 = normal_vec;
        let _cse_129_ = (dot(_cse_130_, (_e2778 * area)) * _cse_135_);
        let _cse_188_ = (_cse_184_ * _cse_135_);
        let _cse_128_ = (_cse_129_ - _cse_188_);
        let _cse_191_ = (1f - _cse_135_);
        let _e2786 = normal_vec;
        let _cse_190_ = (dot(_cse_156_, (_e2786 * area)) * _cse_191_);
        let _cse_189_ = (_cse_190_ + _cse_188_);
        let _e2796 = low_mach_params.pressure_coupling_alpha;
        let _e2799 = constants.eos_r;
        let _e2831 = constants.dtau;
        let _e2834 = constants.dtau;
        let _e2845 = low_mach_params.model;
        phi_0_ = (((_cse_128_ * _cse_132_) + (_cse_189_ * _cse_160_)) + ((((((_e2796 * (((_cse_132_ * _e2799) * ((((_e121 + (_e121 * 0.625f)) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) - _cse_175_)) * 0.5f) * ((1f / max(_cse_147_, 0.000000000001f)) + (1f / max(_cse_172_, 0.000000000001f)))) * min(1f, max(0f, (_e2831 / (_e2834 + 0.000000000001f))))) * (1f - max(0f, (1f - abs((f32(_e2845) - 2f)))))) * area));
        let _e2867 = constants.eos_r;
        let _e2887 = normal_vec.x;
        let _e2892 = constants.viscosity;
        let _e2906 = normal_vec.x;
        let _e2914 = normal_vec.y;
        let _e2918 = lambda;
        let _e2922 = constants.viscosity;
        let _e2930 = normal_vec.x;
        let _e2934 = normal_vec.y;
        phi_1_ = ((((_cse_128_ * _cse_131_.x) + (_cse_189_ * _cse_157_.x)) + ((((((_cse_135_ * _cse_132_) * _e2867) * ((((_e121 + (_e121 * 0.625f)) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + (_cse_191_ * _cse_175_)) * area) * _e2887)) - ((((_e2892 * ((((2f * select(s_neigh_grad_u_x_x, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e2906) + ((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e2914))) * _e2918) + ((_e2922 * ((((2f * s_own_grad_u_x_x) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e2930) + ((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e2934))) * lambda_other)) * area));
        let _e2950 = constants.eos_r;
        let _e2970 = normal_vec.y;
        let _e2975 = constants.viscosity;
        let _e2982 = normal_vec.x;
        let _e2997 = normal_vec.y;
        let _e3001 = lambda;
        let _e3005 = constants.viscosity;
        let _e3008 = normal_vec.x;
        let _e3017 = normal_vec.y;
        phi_2_ = ((((_cse_128_ * _cse_131_.y) + (_cse_189_ * _cse_157_.y)) + ((((((_cse_135_ * _cse_132_) * _e2950) * ((((_e121 + (_e121 * 0.625f)) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + (_cse_191_ * _cse_175_)) * area) * _e2970)) - ((((_e2975 * (((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e2982) + (((2f * select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e2997))) * _e3001) + ((_e3005 * (((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e3008) + (((2f * s_own_grad_u_y_y) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e3017))) * lambda_other)) * area));
        let _e3027 = constants.eos_r;
        let _e3045 = constants.eos_gm1_;
        let _e3055 = constants.eos_r;
        let _e3075 = constants.eos_gm1_;
        let _e3088 = constants.eos_r;
        let _e3112 = lambda;
        let _e3117 = normal_vec;
        let _e3128 = state[((owner_1 * 22u) + 10u)];
        let _e3133 = normal_vec;
        let _e3139 = lambda;
        let _e3148 = normal_vec;
        let _e3155 = lambda;
        let _e3160 = normal_vec;
        let _e3171 = state[((owner_1 * 22u) + 11u)];
        let _e3176 = normal_vec;
        let _e3182 = lambda;
        let _e3191 = normal_vec;
        let _e3196 = constants.viscosity;
        let _e3200 = constants.viscosity;
        let _e3214 = normal_vec.x;
        let _e3222 = normal_vec.y;
        let _e3226 = lambda;
        let _e3230 = constants.viscosity;
        let _e3238 = normal_vec.x;
        let _e3242 = normal_vec.y;
        let _e3250 = constants.viscosity;
        let _e3257 = normal_vec.x;
        let _e3272 = normal_vec.y;
        let _e3276 = lambda;
        let _e3280 = constants.viscosity;
        let _e3283 = normal_vec.x;
        let _e3292 = normal_vec.y;
        phi_3_ = ((((_cse_128_ * (((((_cse_132_ * _e3027) * ((((_e121 + (_e121 * 0.625f)) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) / max(_e3045, 0.000000000001f)) + ((0.5f * _cse_132_) * _cse_151_)) + ((_cse_132_ * _e3055) * ((((_e121 + (_e121 * 0.625f)) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)))) + (_cse_189_ * (((_cse_175_ / max(_e3075, 0.000000000001f)) + ((0.5f * _cse_160_) * _cse_178_)) + _cse_175_))) + (_cse_188_ * (((_cse_132_ * _e3088) * ((((_e121 + (_e121 * 0.625f)) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) - _cse_175_))) - (dot(((vec2<f32>(dot((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e3112) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e3117 * select(0f, 1f, is_boundary_1)) * (((s_own_u_x - _e3128) / max(dist, 0.000001f)) - dot(_e3133, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e3139) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))), _e3148), dot((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e3155) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e3160 * select(0f, 1f, is_boundary_1)) * (((s_own_u_y - _e3171) / max(dist, 0.000001f)) - dot(_e3176, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e3182) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))), _e3191)) * _e3196) + vec2<f32>((((_e3200 * ((((2f * select(s_neigh_grad_u_x_x, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e3214) + ((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e3222))) * _e3226) + ((_e3230 * ((((2f * s_own_grad_u_x_x) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e3238) + ((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e3242))) * lambda_other)), (((_e3250 * (((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e3257) + (((2f * select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e3272))) * _e3276) + ((_e3280 * (((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e3283) + (((2f * s_own_grad_u_y_y) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e3292))) * lambda_other)))), ((_cse_130_ * _cse_135_) + (_cse_156_ * _cse_191_))) * area));
        phi_4_ = 0f;
        phi_5_ = 0f;
        phi_6_ = 0f;
        phi_7_ = 0f;
    }
    let _e3312 = constants.scheme;
    if ((_e3312 == 3u) && !(is_boundary_1)) {
        let _cse_196_ = (_cse_4_ + min(max(dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec)), min((_cse_33_ - _cse_4_), 0f)), max((_cse_33_ - _cse_4_), 0f)));
        let _cse_197_ = (_cse_5_ + min(max(dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec)), min((_cse_34_ - _cse_5_), 0f)), max((_cse_34_ - _cse_5_), 0f)));
        let _cse_195_ = vec2<f32>(_cse_196_, _cse_197_);
        let _cse_199_ = min(max(dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec)), min((_e746 - _e234), 0f)), max((_e746 - _e234), 0f));
        let _cse_198_ = (_e234 + _cse_199_);
        let _cse_194_ = ((_cse_195_ * 1f) / vec2(_cse_198_));
        let _e3360 = constants.eos_gamma;
        let _e3364 = constants.eos_r;
        let _cse_213_ = ((((_e3360 * _cse_198_) * _e3364) * (_e121 + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)), min((_e524 - _e121), 0f)), max((_e524 - _e121), 0f)))) / _cse_198_);
        let _e3382 = constants.eos_dp_drho;
        let _cse_212_ = (_cse_213_ + _e3382);
        let _cse_216_ = dot(_cse_194_, _cse_194_);
        let _cse_215_ = min(_cse_216_, _cse_212_);
        let _e3388 = low_mach_params.model;
        let _cse_214_ = (max(0f, (1f - abs(f32(_e3388)))) * _cse_215_);
        let _e3398 = low_mach_params.model;
        let _cse_211_ = ((max(0f, (1f - abs((f32(_e3398) - 2f)))) * _cse_212_) + _cse_214_);
        let _e3411 = low_mach_params.theta_floor;
        let _cse_219_ = max(_cse_216_, (_e3411 * _cse_212_));
        let _cse_218_ = min(_cse_219_, _cse_212_);
        let _e3417 = low_mach_params.model;
        let _cse_217_ = (max(0f, (1f - abs((f32(_e3417) - 1f)))) * _cse_218_);
        let _cse_210_ = (_cse_211_ + _cse_217_);
        let _e3430 = constants.dtau;
        let _e3433 = constants.dtau;
        let _cse_209_ = (min(1f, max(0f, (_e3430 / (_e3433 + 0.000000000001f)))) * _cse_210_);
        let _e3444 = constants.dtau;
        let _e3447 = constants.dtau;
        let _cse_208_ = (_cse_209_ + ((1f - min(1f, max(0f, (_e3444 / (_e3447 + 0.000000000001f))))) * _cse_212_));
        let _cse_207_ = (_cse_208_ / max(_cse_212_, 0.000000000001f));
        let _cse_206_ = sqrt(_cse_207_);
        let _e3465 = constants.eos_gamma;
        let _e3468 = constants.eos_r;
        let _e3477 = constants.eos_gamma;
        let _e3481 = constants.eos_r;
        let _e3485 = constants.eos_gamma;
        let _e3488 = constants.eos_r;
        let _e3500 = constants.eos_gamma;
        let _e3503 = constants.eos_r;
        let _e3509 = constants.eos_gamma;
        let _e3512 = constants.eos_r;
        let _e3522 = constants.eos_gamma;
        let _e3525 = constants.eos_r;
        let _e3531 = constants.eos_gamma;
        let _e3534 = constants.eos_r;
        let _cse_205_ = ((sqrt(((_e3465 * _e3468) * _e121)) + min(max(dot(((((vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5f) * _e3477) * _e3481) / vec2(max(sqrt(((_e3485 * _e3488) * _e121)), 0.000000000001f))), (face_center_vec - c_owner_vec)), min((sqrt(((_e3500 * _e3503) * _e524)) - sqrt(((_e3509 * _e3512) * _e121))), 0f)), max((sqrt(((_e3522 * _e3525) * _e524)) - sqrt(((_e3531 * _e3534) * _e121))), 0f))) * _cse_206_);
        let _cse_204_ = (_cse_205_ * area);
        let _e3545 = normal_vec;
        let _cse_203_ = (dot(_cse_194_, (_e3545 * area)) + _cse_204_);
        let _cse_223_ = (_cse_33_ + min(max(dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_cse_4_ - _cse_33_), 0f)), max((_cse_4_ - _cse_33_), 0f)));
        let _cse_224_ = (_cse_34_ + min(max(dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_cse_5_ - _cse_34_), 0f)), max((_cse_5_ - _cse_34_), 0f)));
        let _cse_222_ = vec2<f32>(_cse_223_, _cse_224_);
        let _cse_227_ = max(dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_e234 - _e746), 0f));
        let _cse_226_ = min(_cse_227_, max((_e234 - _e746), 0f));
        let _cse_225_ = (_e746 + _cse_226_);
        let _cse_221_ = ((_cse_222_ * 1f) / vec2(_cse_225_));
        let _e3604 = constants.eos_r;
        let _cse_239_ = ((_cse_225_ * _e3604) * (_e524 + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_e121 - _e524), 0f)), max((_e121 - _e524), 0f))));
        let _e3625 = constants.eos_gamma;
        let _cse_238_ = (_e3625 * _cse_239_);
        let _cse_237_ = (_cse_238_ / _cse_225_);
        let _e3630 = constants.eos_dp_drho;
        let _cse_236_ = (_cse_237_ + _e3630);
        let _cse_242_ = dot(_cse_221_, _cse_221_);
        let _cse_241_ = min(_cse_242_, _cse_236_);
        let _e3636 = low_mach_params.model;
        let _cse_240_ = (max(0f, (1f - abs(f32(_e3636)))) * _cse_241_);
        let _e3646 = low_mach_params.model;
        let _cse_235_ = ((max(0f, (1f - abs((f32(_e3646) - 2f)))) * _cse_236_) + _cse_240_);
        let _e3659 = low_mach_params.theta_floor;
        let _cse_245_ = max(_cse_242_, (_e3659 * _cse_236_));
        let _cse_244_ = min(_cse_245_, _cse_236_);
        let _e3665 = low_mach_params.model;
        let _cse_243_ = (max(0f, (1f - abs((f32(_e3665) - 1f)))) * _cse_244_);
        let _cse_234_ = (_cse_235_ + _cse_243_);
        let _e3678 = constants.dtau;
        let _e3681 = constants.dtau;
        let _cse_233_ = (min(1f, max(0f, (_e3678 / (_e3681 + 0.000000000001f)))) * _cse_234_);
        let _e3692 = constants.dtau;
        let _e3695 = constants.dtau;
        let _cse_232_ = (_cse_233_ + ((1f - min(1f, max(0f, (_e3692 / (_e3695 + 0.000000000001f))))) * _cse_236_));
        let _cse_231_ = (_cse_232_ / max(_cse_236_, 0.000000000001f));
        let _cse_230_ = sqrt(_cse_231_);
        let _e3713 = constants.eos_gamma;
        let _e3716 = constants.eos_r;
        let _e3729 = constants.eos_gamma;
        let _e3733 = constants.eos_r;
        let _e3737 = constants.eos_gamma;
        let _e3740 = constants.eos_r;
        let _e3752 = constants.eos_gamma;
        let _e3755 = constants.eos_r;
        let _e3761 = constants.eos_gamma;
        let _e3764 = constants.eos_r;
        let _e3774 = constants.eos_gamma;
        let _e3777 = constants.eos_r;
        let _e3783 = constants.eos_gamma;
        let _e3786 = constants.eos_r;
        let _cse_229_ = ((sqrt(((_e3713 * _e3716) * _e524)) + min(max(dot(((((vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)) * 0.5f) * _e3729) * _e3733) / vec2(max(sqrt(((_e3737 * _e3740) * _e524)), 0.000000000001f))), (face_center_vec - c_neigh_cell_vec)), min((sqrt(((_e3752 * _e3755) * _e121)) - sqrt(((_e3761 * _e3764) * _e524))), 0f)), max((sqrt(((_e3774 * _e3777) * _e121)) - sqrt(((_e3783 * _e3786) * _e524))), 0f))) * _cse_230_);
        let _cse_228_ = (_cse_229_ * area);
        let _e3797 = normal_vec;
        let _cse_220_ = (dot(_cse_221_, (_e3797 * area)) + _cse_228_);
        let _cse_202_ = max(_cse_203_, _cse_220_);
        let _cse_201_ = max(_cse_202_, 0f);
        let _e3804 = normal_vec;
        let _cse_250_ = (dot(_cse_194_, (_e3804 * area)) - _cse_204_);
        let _e3808 = normal_vec;
        let _cse_251_ = (dot(_cse_221_, (_e3808 * area)) - _cse_228_);
        let _cse_249_ = min(_cse_250_, _cse_251_);
        let _cse_248_ = min(_cse_249_, 0f);
        let _cse_247_ = (_cse_201_ - _cse_248_);
        let _cse_246_ = max(_cse_247_, 0.000001f);
        let _cse_200_ = (_cse_201_ / _cse_246_);
        let _e3819 = normal_vec;
        let _cse_193_ = (dot(_cse_194_, (_e3819 * area)) * _cse_200_);
        let _cse_252_ = (_cse_248_ * _cse_200_);
        let _cse_192_ = (_cse_193_ - _cse_252_);
        let _cse_255_ = (1f - _cse_200_);
        let _e3827 = normal_vec;
        let _cse_254_ = (dot(_cse_221_, (_e3827 * area)) * _cse_255_);
        let _cse_253_ = (_cse_254_ + _cse_252_);
        let _e3837 = low_mach_params.pressure_coupling_alpha;
        let _e3840 = constants.eos_r;
        let _e3871 = constants.dtau;
        let _e3874 = constants.dtau;
        let _e3885 = low_mach_params.model;
        phi_0_ = (((_cse_192_ * _cse_198_) + (_cse_253_ * _cse_225_)) + ((((((_e3837 * (((_cse_198_ * _e3840) * (_e121 + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)), min((_e524 - _e121), 0f)), max((_e524 - _e121), 0f)))) - _cse_239_)) * 0.5f) * ((1f / max(_cse_212_, 0.000000000001f)) + (1f / max(_cse_236_, 0.000000000001f)))) * min(1f, max(0f, (_e3871 / (_e3874 + 0.000000000001f))))) * (1f - max(0f, (1f - abs((f32(_e3885) - 2f)))))) * area));
        let _e3907 = constants.eos_r;
        let _e3926 = normal_vec.x;
        let _e3931 = constants.viscosity;
        let _e3945 = normal_vec.x;
        let _e3953 = normal_vec.y;
        let _e3957 = lambda;
        let _e3961 = constants.viscosity;
        let _e3969 = normal_vec.x;
        let _e3973 = normal_vec.y;
        phi_1_ = ((((_cse_192_ * _cse_195_.x) + (_cse_253_ * _cse_222_.x)) + ((((((_cse_200_ * _cse_198_) * _e3907) * (_e121 + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)), min((_e524 - _e121), 0f)), max((_e524 - _e121), 0f)))) + (_cse_255_ * _cse_239_)) * area) * _e3926)) - ((((_e3931 * ((((2f * select(s_neigh_grad_u_x_x, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e3945) + ((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e3953))) * _e3957) + ((_e3961 * ((((2f * s_own_grad_u_x_x) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e3969) + ((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e3973))) * lambda_other)) * area));
        let _e3989 = constants.eos_r;
        let _e4008 = normal_vec.y;
        let _e4013 = constants.viscosity;
        let _e4020 = normal_vec.x;
        let _e4035 = normal_vec.y;
        let _e4039 = lambda;
        let _e4043 = constants.viscosity;
        let _e4046 = normal_vec.x;
        let _e4055 = normal_vec.y;
        phi_2_ = ((((_cse_192_ * _cse_195_.y) + (_cse_253_ * _cse_222_.y)) + ((((((_cse_200_ * _cse_198_) * _e3989) * (_e121 + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)), min((_e524 - _e121), 0f)), max((_e524 - _e121), 0f)))) + (_cse_255_ * _cse_239_)) * area) * _e4008)) - ((((_e4013 * (((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e4020) + (((2f * select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e4035))) * _e4039) + ((_e4043 * (((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e4046) + (((2f * s_own_grad_u_y_y) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e4055))) * lambda_other)) * area));
        let _e4065 = constants.eos_r;
        let _e4082 = constants.eos_gm1_;
        let _e4092 = constants.eos_r;
        let _e4111 = constants.eos_gm1_;
        let _e4124 = constants.eos_r;
        let _e4147 = lambda;
        let _e4152 = normal_vec;
        let _e4163 = state[((owner_1 * 22u) + 10u)];
        let _e4168 = normal_vec;
        let _e4174 = lambda;
        let _e4183 = normal_vec;
        let _e4190 = lambda;
        let _e4195 = normal_vec;
        let _e4206 = state[((owner_1 * 22u) + 11u)];
        let _e4211 = normal_vec;
        let _e4217 = lambda;
        let _e4226 = normal_vec;
        let _e4231 = constants.viscosity;
        let _e4235 = constants.viscosity;
        let _e4249 = normal_vec.x;
        let _e4257 = normal_vec.y;
        let _e4261 = lambda;
        let _e4265 = constants.viscosity;
        let _e4273 = normal_vec.x;
        let _e4277 = normal_vec.y;
        let _e4285 = constants.viscosity;
        let _e4292 = normal_vec.x;
        let _e4307 = normal_vec.y;
        let _e4311 = lambda;
        let _e4315 = constants.viscosity;
        let _e4318 = normal_vec.x;
        let _e4327 = normal_vec.y;
        phi_3_ = ((((_cse_192_ * (((((_cse_198_ * _e4065) * (_e121 + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)), min((_e524 - _e121), 0f)), max((_e524 - _e121), 0f)))) / max(_e4082, 0.000000000001f)) + ((0.5f * _cse_198_) * _cse_216_)) + ((_cse_198_ * _e4092) * (_e121 + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)), min((_e524 - _e121), 0f)), max((_e524 - _e121), 0f)))))) + (_cse_253_ * (((_cse_239_ / max(_e4111, 0.000000000001f)) + ((0.5f * _cse_225_) * _cse_242_)) + _cse_239_))) + (_cse_252_ * (((_cse_198_ * _e4124) * (_e121 + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)), min((_e524 - _e121), 0f)), max((_e524 - _e121), 0f)))) - _cse_239_))) - (dot(((vec2<f32>(dot((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e4147) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e4152 * select(0f, 1f, is_boundary_1)) * (((s_own_u_x - _e4163) / max(dist, 0.000001f)) - dot(_e4168, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e4174) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))), _e4183), dot((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e4190) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e4195 * select(0f, 1f, is_boundary_1)) * (((s_own_u_y - _e4206) / max(dist, 0.000001f)) - dot(_e4211, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e4217) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))), _e4226)) * _e4231) + vec2<f32>((((_e4235 * ((((2f * select(s_neigh_grad_u_x_x, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e4249) + ((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e4257))) * _e4261) + ((_e4265 * ((((2f * s_own_grad_u_x_x) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e4273) + ((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e4277))) * lambda_other)), (((_e4285 * (((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e4292) + (((2f * select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e4307))) * _e4311) + ((_e4315 * (((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e4318) + (((2f * s_own_grad_u_y_y) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e4327))) * lambda_other)))), ((_cse_194_ * _cse_200_) + (_cse_221_ * _cse_255_))) * area));
        phi_4_ = 0f;
        phi_5_ = 0f;
        phi_6_ = 0f;
        phi_7_ = 0f;
    }
    let _e4347 = constants.scheme;
    if ((_e4347 == 4u) && !(is_boundary_1)) {
        let _cse_260_ = (vec2<f32>(_cse_33_, _cse_34_) - vec2<f32>(_cse_4_, _cse_5_));
        let _cse_261_ = dot(_cse_260_, _cse_260_);
        let _cse_259_ = (((_cse_260_ * (max(-2001f, min(((((2f * dot(_cse_260_, vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y))))) * _cse_261_) / ((_cse_261_ * _cse_261_) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot(_cse_260_, vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y))))) * _cse_261_) / ((_cse_261_ * _cse_261_) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) / vec2((1f + abs(max(-2001f, min(((((2f * dot(_cse_260_, vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y))))) * _cse_261_) / ((_cse_261_ * _cse_261_) + 0.000000000000000000000000000001f)) - 1f), 1999f)))))) * lambda_other);
        let _cse_258_ = (vec2<f32>(_cse_4_, _cse_5_) + _cse_259_);
        let _cse_265_ = ((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y))) * (_e746 - _e234)) / (((_e746 - _e234) * (_e746 - _e234)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y))) * (_e746 - _e234)) / (((_e746 - _e234) * (_e746 - _e234)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y))) * (_e746 - _e234)) / (((_e746 - _e234) * (_e746 - _e234)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))));
        let _cse_264_ = (_cse_265_ * lambda_other);
        let _cse_263_ = (_cse_264_ * (_e746 - _e234));
        let _cse_262_ = (_e234 + _cse_263_);
        let _cse_257_ = ((_cse_258_ * 1f) / vec2(_cse_262_));
        let _e4503 = constants.eos_gamma;
        let _e4507 = constants.eos_r;
        let _cse_278_ = ((((_e4503 * _cse_262_) * _e4507) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e524 - _e121)))) / _cse_262_);
        let _e4580 = constants.eos_dp_drho;
        let _cse_277_ = (_cse_278_ + _e4580);
        let _cse_279_ = dot(_cse_257_, _cse_257_);
        let _e4585 = low_mach_params.model;
        let _e4597 = low_mach_params.model;
        let _e4609 = low_mach_params.model;
        let _e4620 = low_mach_params.theta_floor;
        let _cse_276_ = (((max(0f, (1f - abs((f32(_e4585) - 2f)))) * _cse_277_) + (max(0f, (1f - abs(f32(_e4597)))) * min(_cse_279_, _cse_277_))) + (max(0f, (1f - abs((f32(_e4609) - 1f)))) * min(max(_cse_279_, (_e4620 * _cse_277_)), _cse_277_)));
        let _e4628 = constants.dtau;
        let _e4631 = constants.dtau;
        let _cse_275_ = (min(1f, max(0f, (_e4628 / (_e4631 + 0.000000000001f)))) * _cse_276_);
        let _e4642 = constants.dtau;
        let _e4645 = constants.dtau;
        let _cse_274_ = (_cse_275_ + ((1f - min(1f, max(0f, (_e4642 / (_e4645 + 0.000000000001f))))) * _cse_277_));
        let _cse_273_ = (_cse_274_ / max(_cse_277_, 0.000000000001f));
        let _cse_272_ = sqrt(_cse_273_);
        let _e4663 = constants.eos_gamma;
        let _e4666 = constants.eos_r;
        let _e4676 = constants.eos_gamma;
        let _e4680 = constants.eos_r;
        let _e4684 = constants.eos_gamma;
        let _e4687 = constants.eos_r;
        let _e4700 = constants.eos_gamma;
        let _e4703 = constants.eos_r;
        let _e4709 = constants.eos_gamma;
        let _e4712 = constants.eos_r;
        let _e4720 = constants.eos_gamma;
        let _e4723 = constants.eos_r;
        let _e4729 = constants.eos_gamma;
        let _e4732 = constants.eos_r;
        let _e4739 = constants.eos_gamma;
        let _e4742 = constants.eos_r;
        let _e4748 = constants.eos_gamma;
        let _e4751 = constants.eos_r;
        let _e4772 = constants.eos_gamma;
        let _e4776 = constants.eos_r;
        let _e4780 = constants.eos_gamma;
        let _e4783 = constants.eos_r;
        let _e4796 = constants.eos_gamma;
        let _e4799 = constants.eos_r;
        let _e4805 = constants.eos_gamma;
        let _e4808 = constants.eos_r;
        let _e4816 = constants.eos_gamma;
        let _e4819 = constants.eos_r;
        let _e4825 = constants.eos_gamma;
        let _e4828 = constants.eos_r;
        let _e4835 = constants.eos_gamma;
        let _e4838 = constants.eos_r;
        let _e4844 = constants.eos_gamma;
        let _e4847 = constants.eos_r;
        let _e4870 = constants.eos_gamma;
        let _e4874 = constants.eos_r;
        let _e4878 = constants.eos_gamma;
        let _e4881 = constants.eos_r;
        let _e4894 = constants.eos_gamma;
        let _e4897 = constants.eos_r;
        let _e4903 = constants.eos_gamma;
        let _e4906 = constants.eos_r;
        let _e4914 = constants.eos_gamma;
        let _e4917 = constants.eos_r;
        let _e4923 = constants.eos_gamma;
        let _e4926 = constants.eos_r;
        let _e4933 = constants.eos_gamma;
        let _e4936 = constants.eos_r;
        let _e4942 = constants.eos_gamma;
        let _e4945 = constants.eos_r;
        let _e4967 = constants.eos_gamma;
        let _e4970 = constants.eos_r;
        let _e4976 = constants.eos_gamma;
        let _e4979 = constants.eos_r;
        let _cse_271_ = ((sqrt(((_e4663 * _e4666) * _e121)) + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), ((((vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5f) * _e4676) * _e4680) / vec2(max(sqrt(((_e4684 * _e4687) * _e121)), 0.000000000001f))))) * (sqrt(((_e4700 * _e4703) * _e524)) - sqrt(((_e4709 * _e4712) * _e121)))) / (((sqrt(((_e4720 * _e4723) * _e524)) - sqrt(((_e4729 * _e4732) * _e121))) * (sqrt(((_e4739 * _e4742) * _e524)) - sqrt(((_e4748 * _e4751) * _e121)))) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), ((((vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5f) * _e4772) * _e4776) / vec2(max(sqrt(((_e4780 * _e4783) * _e121)), 0.000000000001f))))) * (sqrt(((_e4796 * _e4799) * _e524)) - sqrt(((_e4805 * _e4808) * _e121)))) / (((sqrt(((_e4816 * _e4819) * _e524)) - sqrt(((_e4825 * _e4828) * _e121))) * (sqrt(((_e4835 * _e4838) * _e524)) - sqrt(((_e4844 * _e4847) * _e121)))) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), ((((vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5f) * _e4870) * _e4874) / vec2(max(sqrt(((_e4878 * _e4881) * _e121)), 0.000000000001f))))) * (sqrt(((_e4894 * _e4897) * _e524)) - sqrt(((_e4903 * _e4906) * _e121)))) / (((sqrt(((_e4914 * _e4917) * _e524)) - sqrt(((_e4923 * _e4926) * _e121))) * (sqrt(((_e4933 * _e4936) * _e524)) - sqrt(((_e4942 * _e4945) * _e121)))) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (sqrt(((_e4967 * _e4970) * _e524)) - sqrt(((_e4976 * _e4979) * _e121))))) * _cse_272_);
        let _cse_270_ = (_cse_271_ * area);
        let _e4988 = normal_vec;
        let _cse_269_ = (dot(_cse_257_, (_e4988 * area)) + _cse_270_);
        let _cse_290_ = ((dot(_cse_260_, vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1))), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1))))) * _cse_261_) / ((_cse_261_ * _cse_261_) + 0.000000000000000000000000000001f));
        let _cse_289_ = (2f * _cse_290_);
        let _cse_288_ = (_cse_289_ - 1f);
        let _cse_287_ = min(_cse_288_, 1999f);
        let _cse_286_ = max(-2001f, _cse_287_);
        let _cse_285_ = ((_cse_286_ + abs(_cse_286_)) / (1f + abs(_cse_286_)));
        let _e5027 = lambda;
        let _cse_284_ = (_cse_285_ * _e5027);
        let _cse_283_ = (_cse_260_ * _cse_284_);
        let _cse_282_ = (vec2<f32>(_cse_33_, _cse_34_) - _cse_283_);
        let _cse_297_ = ((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)))) * (_e746 - _e234)) / (((_e746 - _e234) * (_e746 - _e234)) + 0.000000000000000000000000000001f)) - 1f);
        let _cse_296_ = min(_cse_297_, 1999f);
        let _cse_295_ = max(-2001f, _cse_296_);
        let _cse_294_ = ((_cse_295_ + abs(_cse_295_)) / (1f + abs(_cse_295_)));
        let _e5061 = lambda;
        let _cse_293_ = (_cse_294_ * _e5061);
        let _cse_292_ = (_cse_293_ * (_e746 - _e234));
        let _cse_291_ = (_e746 - _cse_292_);
        let _cse_281_ = ((_cse_282_ * 1f) / vec2(_cse_291_));
        let _e5072 = constants.eos_gamma;
        let _e5076 = constants.eos_r;
        let _e5153 = lambda;
        let _cse_307_ = ((((_e5072 * _cse_291_) * _e5076) * (_e524 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e5153) * (_e524 - _e121)))) / _cse_291_);
        let _e5162 = constants.eos_dp_drho;
        let _cse_306_ = (_cse_307_ + _e5162);
        let _cse_308_ = dot(_cse_281_, _cse_281_);
        let _e5167 = low_mach_params.model;
        let _e5179 = low_mach_params.model;
        let _cse_305_ = ((max(0f, (1f - abs((f32(_e5167) - 2f)))) * _cse_306_) + (max(0f, (1f - abs(f32(_e5179)))) * min(_cse_308_, _cse_306_)));
        let _e5191 = low_mach_params.theta_floor;
        let _cse_310_ = min(max(_cse_308_, (_e5191 * _cse_306_)), _cse_306_);
        let _e5197 = low_mach_params.model;
        let _cse_309_ = (max(0f, (1f - abs((f32(_e5197) - 1f)))) * _cse_310_);
        let _cse_304_ = (_cse_305_ + _cse_309_);
        let _e5210 = constants.dtau;
        let _e5213 = constants.dtau;
        let _cse_303_ = (min(1f, max(0f, (_e5210 / (_e5213 + 0.000000000001f)))) * _cse_304_);
        let _e5224 = constants.dtau;
        let _e5227 = constants.dtau;
        let _cse_302_ = (_cse_303_ + ((1f - min(1f, max(0f, (_e5224 / (_e5227 + 0.000000000001f))))) * _cse_306_));
        let _cse_301_ = (_cse_302_ / max(_cse_306_, 0.000000000001f));
        let _cse_300_ = sqrt(_cse_301_);
        let _e5245 = constants.eos_gamma;
        let _e5248 = constants.eos_r;
        let _e5262 = constants.eos_gamma;
        let _e5266 = constants.eos_r;
        let _e5270 = constants.eos_gamma;
        let _e5273 = constants.eos_r;
        let _e5286 = constants.eos_gamma;
        let _e5289 = constants.eos_r;
        let _e5295 = constants.eos_gamma;
        let _e5298 = constants.eos_r;
        let _e5306 = constants.eos_gamma;
        let _e5309 = constants.eos_r;
        let _e5315 = constants.eos_gamma;
        let _e5318 = constants.eos_r;
        let _e5325 = constants.eos_gamma;
        let _e5328 = constants.eos_r;
        let _e5334 = constants.eos_gamma;
        let _e5337 = constants.eos_r;
        let _e5362 = constants.eos_gamma;
        let _e5366 = constants.eos_r;
        let _e5370 = constants.eos_gamma;
        let _e5373 = constants.eos_r;
        let _e5386 = constants.eos_gamma;
        let _e5389 = constants.eos_r;
        let _e5395 = constants.eos_gamma;
        let _e5398 = constants.eos_r;
        let _e5406 = constants.eos_gamma;
        let _e5409 = constants.eos_r;
        let _e5415 = constants.eos_gamma;
        let _e5418 = constants.eos_r;
        let _e5425 = constants.eos_gamma;
        let _e5428 = constants.eos_r;
        let _e5434 = constants.eos_gamma;
        let _e5437 = constants.eos_r;
        let _e5464 = constants.eos_gamma;
        let _e5468 = constants.eos_r;
        let _e5472 = constants.eos_gamma;
        let _e5475 = constants.eos_r;
        let _e5488 = constants.eos_gamma;
        let _e5491 = constants.eos_r;
        let _e5497 = constants.eos_gamma;
        let _e5500 = constants.eos_r;
        let _e5508 = constants.eos_gamma;
        let _e5511 = constants.eos_r;
        let _e5517 = constants.eos_gamma;
        let _e5520 = constants.eos_r;
        let _e5527 = constants.eos_gamma;
        let _e5530 = constants.eos_r;
        let _e5536 = constants.eos_gamma;
        let _e5539 = constants.eos_r;
        let _e5558 = lambda;
        let _e5562 = constants.eos_gamma;
        let _e5565 = constants.eos_r;
        let _e5571 = constants.eos_gamma;
        let _e5574 = constants.eos_r;
        let _cse_299_ = ((sqrt(((_e5245 * _e5248) * _e524)) - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), ((((vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)) * 0.5f) * _e5262) * _e5266) / vec2(max(sqrt(((_e5270 * _e5273) * _e524)), 0.000000000001f))))) * (sqrt(((_e5286 * _e5289) * _e524)) - sqrt(((_e5295 * _e5298) * _e121)))) / (((sqrt(((_e5306 * _e5309) * _e524)) - sqrt(((_e5315 * _e5318) * _e121))) * (sqrt(((_e5325 * _e5328) * _e524)) - sqrt(((_e5334 * _e5337) * _e121)))) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), ((((vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)) * 0.5f) * _e5362) * _e5366) / vec2(max(sqrt(((_e5370 * _e5373) * _e524)), 0.000000000001f))))) * (sqrt(((_e5386 * _e5389) * _e524)) - sqrt(((_e5395 * _e5398) * _e121)))) / (((sqrt(((_e5406 * _e5409) * _e524)) - sqrt(((_e5415 * _e5418) * _e121))) * (sqrt(((_e5425 * _e5428) * _e524)) - sqrt(((_e5434 * _e5437) * _e121)))) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), ((((vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)) * 0.5f) * _e5464) * _e5468) / vec2(max(sqrt(((_e5472 * _e5475) * _e524)), 0.000000000001f))))) * (sqrt(((_e5488 * _e5491) * _e524)) - sqrt(((_e5497 * _e5500) * _e121)))) / (((sqrt(((_e5508 * _e5511) * _e524)) - sqrt(((_e5517 * _e5520) * _e121))) * (sqrt(((_e5527 * _e5530) * _e524)) - sqrt(((_e5536 * _e5539) * _e121)))) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e5558) * (sqrt(((_e5562 * _e5565) * _e524)) - sqrt(((_e5571 * _e5574) * _e121))))) * _cse_300_);
        let _cse_298_ = (_cse_299_ * area);
        let _e5583 = normal_vec;
        let _cse_280_ = (dot(_cse_281_, (_e5583 * area)) + _cse_298_);
        let _cse_268_ = max(_cse_269_, _cse_280_);
        let _cse_267_ = max(_cse_268_, 0f);
        let _e5590 = normal_vec;
        let _cse_315_ = (dot(_cse_257_, (_e5590 * area)) - _cse_270_);
        let _e5594 = normal_vec;
        let _cse_316_ = (dot(_cse_281_, (_e5594 * area)) - _cse_298_);
        let _cse_314_ = min(_cse_315_, _cse_316_);
        let _cse_313_ = min(_cse_314_, 0f);
        let _cse_312_ = (_cse_267_ - _cse_313_);
        let _cse_311_ = max(_cse_312_, 0.000001f);
        let _cse_266_ = (_cse_267_ / _cse_311_);
        let _cse_317_ = (_cse_313_ * _cse_266_);
        let _e5606 = normal_vec;
        let _cse_256_ = ((dot(_cse_257_, (_e5606 * area)) * _cse_266_) - _cse_317_);
        let _cse_319_ = (1f - _cse_266_);
        let _e5613 = normal_vec;
        let _cse_318_ = ((dot(_cse_281_, (_e5613 * area)) * _cse_319_) + _cse_317_);
        let _e5623 = low_mach_params.pressure_coupling_alpha;
        let _e5626 = constants.eos_r;
        let _e5698 = constants.eos_r;
        let _e5775 = lambda;
        let _e5797 = constants.dtau;
        let _e5800 = constants.dtau;
        let _e5811 = low_mach_params.model;
        phi_0_ = (((_cse_256_ * _cse_262_) + (_cse_318_ * _cse_291_)) + ((((((_e5623 * (((_cse_262_ * _e5626) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e524 - _e121)))) - ((_cse_291_ * _e5698) * (_e524 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e5775) * (_e524 - _e121)))))) * 0.5f) * ((1f / max(_cse_277_, 0.000000000001f)) + (1f / max(_cse_306_, 0.000000000001f)))) * min(1f, max(0f, (_e5797 / (_e5800 + 0.000000000001f))))) * (1f - max(0f, (1f - abs((f32(_e5811) - 2f)))))) * area));
        let _e5833 = constants.eos_r;
        let _e5906 = constants.eos_r;
        let _e5983 = lambda;
        let _e5992 = normal_vec.x;
        let _e5997 = constants.viscosity;
        let _e6011 = normal_vec.x;
        let _e6019 = normal_vec.y;
        let _e6023 = lambda;
        let _e6027 = constants.viscosity;
        let _e6035 = normal_vec.x;
        let _e6039 = normal_vec.y;
        phi_1_ = ((((_cse_256_ * _cse_258_.x) + (_cse_318_ * _cse_282_.x)) + ((((((_cse_266_ * _cse_262_) * _e5833) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e524 - _e121)))) + (((_cse_319_ * _cse_291_) * _e5906) * (_e524 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e5983) * (_e524 - _e121))))) * area) * _e5992)) - ((((_e5997 * ((((2f * select(s_neigh_grad_u_x_x, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e6011) + ((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e6019))) * _e6023) + ((_e6027 * ((((2f * s_own_grad_u_x_x) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e6035) + ((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e6039))) * lambda_other)) * area));
        let _e6055 = constants.eos_r;
        let _e6128 = constants.eos_r;
        let _e6205 = lambda;
        let _e6214 = normal_vec.y;
        let _e6219 = constants.viscosity;
        let _e6226 = normal_vec.x;
        let _e6241 = normal_vec.y;
        let _e6245 = lambda;
        let _e6249 = constants.viscosity;
        let _e6252 = normal_vec.x;
        let _e6261 = normal_vec.y;
        phi_2_ = ((((_cse_256_ * _cse_258_.y) + (_cse_318_ * _cse_282_.y)) + ((((((_cse_266_ * _cse_262_) * _e6055) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e524 - _e121)))) + (((_cse_319_ * _cse_291_) * _e6128) * (_e524 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e6205) * (_e524 - _e121))))) * area) * _e6214)) - ((((_e6219 * (((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e6226) + (((2f * select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e6241))) * _e6245) + ((_e6249 * (((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e6252) + (((2f * s_own_grad_u_y_y) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e6261))) * lambda_other)) * area));
        let _e6271 = constants.eos_r;
        let _e6343 = constants.eos_gm1_;
        let _e6353 = constants.eos_r;
        let _e6427 = constants.eos_r;
        let _e6504 = lambda;
        let _e6512 = constants.eos_gm1_;
        let _e6522 = constants.eos_r;
        let _e6599 = lambda;
        let _e6610 = constants.eos_r;
        let _e6682 = constants.eos_r;
        let _e6759 = lambda;
        let _e6773 = lambda;
        let _e6778 = normal_vec;
        let _e6789 = state[((owner_1 * 22u) + 10u)];
        let _e6794 = normal_vec;
        let _e6800 = lambda;
        let _e6809 = normal_vec;
        let _e6816 = lambda;
        let _e6821 = normal_vec;
        let _e6832 = state[((owner_1 * 22u) + 11u)];
        let _e6837 = normal_vec;
        let _e6843 = lambda;
        let _e6852 = normal_vec;
        let _e6857 = constants.viscosity;
        let _e6861 = constants.viscosity;
        let _e6875 = normal_vec.x;
        let _e6883 = normal_vec.y;
        let _e6887 = lambda;
        let _e6891 = constants.viscosity;
        let _e6899 = normal_vec.x;
        let _e6903 = normal_vec.y;
        let _e6911 = constants.viscosity;
        let _e6918 = normal_vec.x;
        let _e6933 = normal_vec.y;
        let _e6937 = lambda;
        let _e6941 = constants.viscosity;
        let _e6944 = normal_vec.x;
        let _e6953 = normal_vec.y;
        phi_3_ = ((((_cse_256_ * (((((_cse_262_ * _e6271) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e524 - _e121)))) / max(_e6343, 0.000000000001f)) + ((0.5f * _cse_262_) * _cse_279_)) + ((_cse_262_ * _e6353) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e524 - _e121)))))) + (_cse_318_ * (((((_cse_291_ * _e6427) * (_e524 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e6504) * (_e524 - _e121)))) / max(_e6512, 0.000000000001f)) + ((0.5f * _cse_291_) * _cse_308_)) + ((_cse_291_ * _e6522) * (_e524 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e6599) * (_e524 - _e121))))))) + (_cse_317_ * (((_cse_262_ * _e6610) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e524 - _e121)))) - ((_cse_291_ * _e6682) * (_e524 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e524 - _e121)) / (((_e524 - _e121) * (_e524 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e6759) * (_e524 - _e121))))))) - (dot(((vec2<f32>(dot((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e6773) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e6778 * select(0f, 1f, is_boundary_1)) * (((s_own_u_x - _e6789) / max(dist, 0.000001f)) - dot(_e6794, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e6800) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))), _e6809), dot((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e6816) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e6821 * select(0f, 1f, is_boundary_1)) * (((s_own_u_y - _e6832) / max(dist, 0.000001f)) - dot(_e6837, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e6843) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))), _e6852)) * _e6857) + vec2<f32>((((_e6861 * ((((2f * select(s_neigh_grad_u_x_x, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e6875) + ((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e6883))) * _e6887) + ((_e6891 * ((((2f * s_own_grad_u_x_x) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e6899) + ((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e6903))) * lambda_other)), (((_e6911 * (((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e6918) + (((2f * select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e6933))) * _e6937) + ((_e6941 * (((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e6944) + (((2f * s_own_grad_u_y_y) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e6953))) * lambda_other)))), ((_cse_257_ * _cse_266_) + (_cse_281_ * _cse_319_))) * area));
        phi_4_ = 0f;
        phi_5_ = 0f;
        phi_6_ = 0f;
        phi_7_ = 0f;
    }
    let _e6973 = constants.scheme;
    if ((_e6973 == 5u) && !(is_boundary_1)) {
        let _cse_324_ = (_cse_4_ + min(max(((((_cse_4_ * 0.625f) + (_cse_33_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_4_), min((_cse_33_ - _cse_4_), 0f)), max((_cse_33_ - _cse_4_), 0f)));
        let _cse_325_ = (_cse_5_ + min(max(((((_cse_5_ * 0.625f) + (_cse_34_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_5_), min((_cse_34_ - _cse_5_), 0f)), max((_cse_34_ - _cse_5_), 0f)));
        let _cse_323_ = vec2<f32>(_cse_324_, _cse_325_);
        let _cse_327_ = min(max(((((_e234 * 0.625f) + (_e746 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234), min((_e746 - _e234), 0f)), max((_e746 - _e234), 0f));
        let _cse_326_ = (_e234 + _cse_327_);
        let _cse_322_ = ((_cse_323_ * 1f) / vec2(_cse_326_));
        let _e7048 = constants.eos_gamma;
        let _e7052 = constants.eos_r;
        let _cse_341_ = ((((_e7048 * _cse_326_) * _e7052) * (_e121 + min(max(((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e524 - _e121), 0f)), max((_e524 - _e121), 0f)))) / _cse_326_);
        let _e7079 = constants.eos_dp_drho;
        let _cse_340_ = (_cse_341_ + _e7079);
        let _cse_344_ = dot(_cse_322_, _cse_322_);
        let _cse_343_ = min(_cse_344_, _cse_340_);
        let _e7085 = low_mach_params.model;
        let _cse_342_ = (max(0f, (1f - abs(f32(_e7085)))) * _cse_343_);
        let _e7095 = low_mach_params.model;
        let _cse_339_ = ((max(0f, (1f - abs((f32(_e7095) - 2f)))) * _cse_340_) + _cse_342_);
        let _e7108 = low_mach_params.theta_floor;
        let _cse_347_ = max(_cse_344_, (_e7108 * _cse_340_));
        let _cse_346_ = min(_cse_347_, _cse_340_);
        let _e7114 = low_mach_params.model;
        let _cse_345_ = (max(0f, (1f - abs((f32(_e7114) - 1f)))) * _cse_346_);
        let _cse_338_ = (_cse_339_ + _cse_345_);
        let _e7127 = constants.dtau;
        let _e7130 = constants.dtau;
        let _cse_337_ = (min(1f, max(0f, (_e7127 / (_e7130 + 0.000000000001f)))) * _cse_338_);
        let _e7141 = constants.dtau;
        let _e7144 = constants.dtau;
        let _cse_336_ = (_cse_337_ + ((1f - min(1f, max(0f, (_e7141 / (_e7144 + 0.000000000001f))))) * _cse_340_));
        let _cse_335_ = (_cse_336_ / max(_cse_340_, 0.000000000001f));
        let _cse_334_ = sqrt(_cse_335_);
        let _e7162 = constants.eos_gamma;
        let _e7165 = constants.eos_r;
        let _e7171 = constants.eos_gamma;
        let _e7174 = constants.eos_r;
        let _e7182 = constants.eos_gamma;
        let _e7185 = constants.eos_r;
        let _e7197 = constants.eos_gamma;
        let _e7201 = constants.eos_r;
        let _e7205 = constants.eos_gamma;
        let _e7208 = constants.eos_r;
        let _e7223 = constants.eos_gamma;
        let _e7226 = constants.eos_r;
        let _e7233 = constants.eos_gamma;
        let _e7236 = constants.eos_r;
        let _e7242 = constants.eos_gamma;
        let _e7245 = constants.eos_r;
        let _e7255 = constants.eos_gamma;
        let _e7258 = constants.eos_r;
        let _e7264 = constants.eos_gamma;
        let _e7267 = constants.eos_r;
        let _cse_333_ = ((sqrt(((_e7162 * _e7165) * _e121)) + min(max(((((sqrt(((_e7171 * _e7174) * _e121)) * 0.625f) + (sqrt(((_e7182 * _e7185) * _e524)) * 0.375f)) + (dot(((((vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5f) * _e7197) * _e7201) / vec2(max(sqrt(((_e7205 * _e7208) * _e121)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - sqrt(((_e7223 * _e7226) * _e121))), min((sqrt(((_e7233 * _e7236) * _e524)) - sqrt(((_e7242 * _e7245) * _e121))), 0f)), max((sqrt(((_e7255 * _e7258) * _e524)) - sqrt(((_e7264 * _e7267) * _e121))), 0f))) * _cse_334_);
        let _cse_332_ = (_cse_333_ * area);
        let _e7278 = normal_vec;
        let _cse_331_ = (dot(_cse_322_, (_e7278 * area)) + _cse_332_);
        let _cse_351_ = (_cse_33_ + min(max(((((_cse_33_ * 0.625f) + (_cse_4_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_33_), min((_cse_4_ - _cse_33_), 0f)), max((_cse_4_ - _cse_33_), 0f)));
        let _cse_352_ = (_cse_34_ + min(max(((((_cse_34_ * 0.625f) + (_cse_5_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_34_), min((_cse_5_ - _cse_34_), 0f)), max((_cse_5_ - _cse_34_), 0f)));
        let _cse_350_ = vec2<f32>(_cse_351_, _cse_352_);
        let _cse_355_ = max(((((_e746 * 0.625f) + (_e234 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e746), min((_e234 - _e746), 0f));
        let _cse_354_ = min(_cse_355_, max((_e234 - _e746), 0f));
        let _cse_353_ = (_e746 + _cse_354_);
        let _cse_349_ = ((_cse_350_ * 1f) / vec2(_cse_353_));
        let _e7364 = constants.eos_r;
        let _cse_367_ = ((_cse_353_ * _e7364) * (_e524 + min(max(((((_e524 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e524), min((_e121 - _e524), 0f)), max((_e121 - _e524), 0f))));
        let _e7394 = constants.eos_gamma;
        let _cse_366_ = (_e7394 * _cse_367_);
        let _cse_365_ = (_cse_366_ / _cse_353_);
        let _e7399 = constants.eos_dp_drho;
        let _cse_364_ = (_cse_365_ + _e7399);
        let _cse_370_ = dot(_cse_349_, _cse_349_);
        let _cse_369_ = min(_cse_370_, _cse_364_);
        let _e7405 = low_mach_params.model;
        let _cse_368_ = (max(0f, (1f - abs(f32(_e7405)))) * _cse_369_);
        let _e7415 = low_mach_params.model;
        let _cse_363_ = ((max(0f, (1f - abs((f32(_e7415) - 2f)))) * _cse_364_) + _cse_368_);
        let _e7428 = low_mach_params.theta_floor;
        let _cse_373_ = max(_cse_370_, (_e7428 * _cse_364_));
        let _cse_372_ = min(_cse_373_, _cse_364_);
        let _e7434 = low_mach_params.model;
        let _cse_371_ = (max(0f, (1f - abs((f32(_e7434) - 1f)))) * _cse_372_);
        let _cse_362_ = (_cse_363_ + _cse_371_);
        let _e7447 = constants.dtau;
        let _e7450 = constants.dtau;
        let _cse_361_ = (min(1f, max(0f, (_e7447 / (_e7450 + 0.000000000001f)))) * _cse_362_);
        let _e7461 = constants.dtau;
        let _e7464 = constants.dtau;
        let _cse_360_ = (_cse_361_ + ((1f - min(1f, max(0f, (_e7461 / (_e7464 + 0.000000000001f))))) * _cse_364_));
        let _cse_359_ = (_cse_360_ / max(_cse_364_, 0.000000000001f));
        let _cse_358_ = sqrt(_cse_359_);
        let _e7482 = constants.eos_gamma;
        let _e7485 = constants.eos_r;
        let _e7491 = constants.eos_gamma;
        let _e7494 = constants.eos_r;
        let _e7502 = constants.eos_gamma;
        let _e7505 = constants.eos_r;
        let _e7521 = constants.eos_gamma;
        let _e7525 = constants.eos_r;
        let _e7529 = constants.eos_gamma;
        let _e7532 = constants.eos_r;
        let _e7547 = constants.eos_gamma;
        let _e7550 = constants.eos_r;
        let _e7557 = constants.eos_gamma;
        let _e7560 = constants.eos_r;
        let _e7566 = constants.eos_gamma;
        let _e7569 = constants.eos_r;
        let _e7579 = constants.eos_gamma;
        let _e7582 = constants.eos_r;
        let _e7588 = constants.eos_gamma;
        let _e7591 = constants.eos_r;
        let _cse_357_ = ((sqrt(((_e7482 * _e7485) * _e524)) + min(max(((((sqrt(((_e7491 * _e7494) * _e524)) * 0.625f) + (sqrt(((_e7502 * _e7505) * _e121)) * 0.375f)) + (dot(((((vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)) * 0.5f) * _e7521) * _e7525) / vec2(max(sqrt(((_e7529 * _e7532) * _e524)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - sqrt(((_e7547 * _e7550) * _e524))), min((sqrt(((_e7557 * _e7560) * _e121)) - sqrt(((_e7566 * _e7569) * _e524))), 0f)), max((sqrt(((_e7579 * _e7582) * _e121)) - sqrt(((_e7588 * _e7591) * _e524))), 0f))) * _cse_358_);
        let _cse_356_ = (_cse_357_ * area);
        let _e7602 = normal_vec;
        let _cse_348_ = (dot(_cse_349_, (_e7602 * area)) + _cse_356_);
        let _cse_330_ = max(_cse_331_, _cse_348_);
        let _cse_329_ = max(_cse_330_, 0f);
        let _e7609 = normal_vec;
        let _cse_378_ = (dot(_cse_322_, (_e7609 * area)) - _cse_332_);
        let _e7613 = normal_vec;
        let _cse_379_ = (dot(_cse_349_, (_e7613 * area)) - _cse_356_);
        let _cse_377_ = min(_cse_378_, _cse_379_);
        let _cse_376_ = min(_cse_377_, 0f);
        let _cse_375_ = (_cse_329_ - _cse_376_);
        let _cse_374_ = max(_cse_375_, 0.000001f);
        let _cse_328_ = (_cse_329_ / _cse_374_);
        let _e7624 = normal_vec;
        let _cse_321_ = (dot(_cse_322_, (_e7624 * area)) * _cse_328_);
        let _cse_380_ = (_cse_376_ * _cse_328_);
        let _cse_320_ = (_cse_321_ - _cse_380_);
        let _cse_383_ = (1f - _cse_328_);
        let _e7632 = normal_vec;
        let _cse_382_ = (dot(_cse_349_, (_e7632 * area)) * _cse_383_);
        let _cse_381_ = (_cse_382_ + _cse_380_);
        let _e7642 = low_mach_params.pressure_coupling_alpha;
        let _e7645 = constants.eos_r;
        let _e7685 = constants.dtau;
        let _e7688 = constants.dtau;
        let _e7699 = low_mach_params.model;
        phi_0_ = (((_cse_320_ * _cse_326_) + (_cse_381_ * _cse_353_)) + ((((((_e7642 * (((_cse_326_ * _e7645) * (_e121 + min(max(((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e524 - _e121), 0f)), max((_e524 - _e121), 0f)))) - _cse_367_)) * 0.5f) * ((1f / max(_cse_340_, 0.000000000001f)) + (1f / max(_cse_364_, 0.000000000001f)))) * min(1f, max(0f, (_e7685 / (_e7688 + 0.000000000001f))))) * (1f - max(0f, (1f - abs((f32(_e7699) - 2f)))))) * area));
        let _e7721 = constants.eos_r;
        let _e7749 = normal_vec.x;
        let _e7754 = constants.viscosity;
        let _e7768 = normal_vec.x;
        let _e7776 = normal_vec.y;
        let _e7780 = lambda;
        let _e7784 = constants.viscosity;
        let _e7792 = normal_vec.x;
        let _e7796 = normal_vec.y;
        phi_1_ = ((((_cse_320_ * _cse_323_.x) + (_cse_381_ * _cse_350_.x)) + ((((((_cse_328_ * _cse_326_) * _e7721) * (_e121 + min(max(((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e524 - _e121), 0f)), max((_e524 - _e121), 0f)))) + (_cse_383_ * _cse_367_)) * area) * _e7749)) - ((((_e7754 * ((((2f * select(s_neigh_grad_u_x_x, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e7768) + ((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e7776))) * _e7780) + ((_e7784 * ((((2f * s_own_grad_u_x_x) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e7792) + ((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e7796))) * lambda_other)) * area));
        let _e7812 = constants.eos_r;
        let _e7840 = normal_vec.y;
        let _e7845 = constants.viscosity;
        let _e7852 = normal_vec.x;
        let _e7867 = normal_vec.y;
        let _e7871 = lambda;
        let _e7875 = constants.viscosity;
        let _e7878 = normal_vec.x;
        let _e7887 = normal_vec.y;
        phi_2_ = ((((_cse_320_ * _cse_323_.y) + (_cse_381_ * _cse_350_.y)) + ((((((_cse_328_ * _cse_326_) * _e7812) * (_e121 + min(max(((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e524 - _e121), 0f)), max((_e524 - _e121), 0f)))) + (_cse_383_ * _cse_367_)) * area) * _e7840)) - ((((_e7845 * (((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e7852) + (((2f * select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e7867))) * _e7871) + ((_e7875 * (((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e7878) + (((2f * s_own_grad_u_y_y) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e7887))) * lambda_other)) * area));
        let _e7897 = constants.eos_r;
        let _e7923 = constants.eos_gm1_;
        let _e7933 = constants.eos_r;
        let _e7961 = constants.eos_gm1_;
        let _e7974 = constants.eos_r;
        let _e8006 = lambda;
        let _e8011 = normal_vec;
        let _e8022 = state[((owner_1 * 22u) + 10u)];
        let _e8027 = normal_vec;
        let _e8033 = lambda;
        let _e8042 = normal_vec;
        let _e8049 = lambda;
        let _e8054 = normal_vec;
        let _e8065 = state[((owner_1 * 22u) + 11u)];
        let _e8070 = normal_vec;
        let _e8076 = lambda;
        let _e8085 = normal_vec;
        let _e8090 = constants.viscosity;
        let _e8094 = constants.viscosity;
        let _e8108 = normal_vec.x;
        let _e8116 = normal_vec.y;
        let _e8120 = lambda;
        let _e8124 = constants.viscosity;
        let _e8132 = normal_vec.x;
        let _e8136 = normal_vec.y;
        let _e8144 = constants.viscosity;
        let _e8151 = normal_vec.x;
        let _e8166 = normal_vec.y;
        let _e8170 = lambda;
        let _e8174 = constants.viscosity;
        let _e8177 = normal_vec.x;
        let _e8186 = normal_vec.y;
        phi_3_ = ((((_cse_320_ * (((((_cse_326_ * _e7897) * (_e121 + min(max(((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e524 - _e121), 0f)), max((_e524 - _e121), 0f)))) / max(_e7923, 0.000000000001f)) + ((0.5f * _cse_326_) * _cse_344_)) + ((_cse_326_ * _e7933) * (_e121 + min(max(((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e524 - _e121), 0f)), max((_e524 - _e121), 0f)))))) + (_cse_381_ * (((_cse_367_ / max(_e7961, 0.000000000001f)) + ((0.5f * _cse_353_) * _cse_370_)) + _cse_367_))) + (_cse_380_ * (((_cse_326_ * _e7974) * (_e121 + min(max(((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e524 - _e121), 0f)), max((_e524 - _e121), 0f)))) - _cse_367_))) - (dot(((vec2<f32>(dot((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e8006) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e8011 * select(0f, 1f, is_boundary_1)) * (((s_own_u_x - _e8022) / max(dist, 0.000001f)) - dot(_e8027, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e8033) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))), _e8042), dot((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e8049) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e8054 * select(0f, 1f, is_boundary_1)) * (((s_own_u_y - _e8065) / max(dist, 0.000001f)) - dot(_e8070, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e8076) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))), _e8085)) * _e8090) + vec2<f32>((((_e8094 * ((((2f * select(s_neigh_grad_u_x_x, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e8108) + ((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e8116))) * _e8120) + ((_e8124 * ((((2f * s_own_grad_u_x_x) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e8132) + ((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e8136))) * lambda_other)), (((_e8144 * (((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e8151) + (((2f * select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e8166))) * _e8170) + ((_e8174 * (((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e8177) + (((2f * s_own_grad_u_y_y) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e8186))) * lambda_other)))), ((_cse_322_ * _cse_328_) + (_cse_349_ * _cse_383_))) * area));
        phi_4_ = 0f;
        phi_5_ = 0f;
        phi_6_ = 0f;
        phi_7_ = 0f;
    }
    let _e8206 = constants.scheme;
    if ((_e8206 == 6u) && !(is_boundary_1)) {
        let _cse_386_ = vec2<f32>((_cse_4_ + ((((((((_cse_4_ * 0.625f) + (_cse_33_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_4_) * abs((_cse_33_ - _cse_4_))) / max(abs((_cse_33_ - _cse_4_)), (abs(((((_cse_4_ * 0.625f) + (_cse_33_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_4_)) + 0.00000001f))) * max(((_cse_33_ - _cse_4_) * ((((_cse_4_ * 0.625f) + (_cse_33_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_4_)), 0f)) / max(abs(((_cse_33_ - _cse_4_) * ((((_cse_4_ * 0.625f) + (_cse_33_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_4_))), 0.00000001f))), (_cse_5_ + ((((((((_cse_5_ * 0.625f) + (_cse_34_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_5_) * abs((_cse_34_ - _cse_5_))) / max(abs((_cse_34_ - _cse_5_)), (abs(((((_cse_5_ * 0.625f) + (_cse_34_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_5_)) + 0.00000001f))) * max(((_cse_34_ - _cse_5_) * ((((_cse_5_ * 0.625f) + (_cse_34_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_5_)), 0f)) / max(abs(((_cse_34_ - _cse_5_) * ((((_cse_5_ * 0.625f) + (_cse_34_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_5_))), 0.00000001f))));
        let _cse_388_ = ((((((((_e234 * 0.625f) + (_e746 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234) * abs((_e746 - _e234))) / max(abs((_e746 - _e234)), (abs(((((_e234 * 0.625f) + (_e746 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)) + 0.00000001f))) * max(((_e746 - _e234) * ((((_e234 * 0.625f) + (_e746 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)), 0f)) / max(abs(((_e746 - _e234) * ((((_e234 * 0.625f) + (_e746 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234))), 0.00000001f));
        let _cse_387_ = (_e234 + _cse_388_);
        let _cse_385_ = ((_cse_386_ * 1f) / vec2(_cse_387_));
        let _e8428 = constants.eos_gamma;
        let _e8432 = constants.eos_r;
        let _cse_402_ = ((((_e8428 * _cse_387_) * _e8432) * (_e121 + ((((((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e524 - _e121))) / max(abs((_e524 - _e121)), (abs(((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e524 - _e121) * ((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e524 - _e121) * ((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f)))) / _cse_387_);
        let _e8508 = constants.eos_dp_drho;
        let _cse_401_ = (_cse_402_ + _e8508);
        let _cse_405_ = dot(_cse_385_, _cse_385_);
        let _cse_404_ = min(_cse_405_, _cse_401_);
        let _e8514 = low_mach_params.model;
        let _cse_403_ = (max(0f, (1f - abs(f32(_e8514)))) * _cse_404_);
        let _e8524 = low_mach_params.model;
        let _cse_400_ = ((max(0f, (1f - abs((f32(_e8524) - 2f)))) * _cse_401_) + _cse_403_);
        let _e8537 = low_mach_params.theta_floor;
        let _cse_408_ = max(_cse_405_, (_e8537 * _cse_401_));
        let _cse_407_ = min(_cse_408_, _cse_401_);
        let _e8543 = low_mach_params.model;
        let _cse_406_ = (max(0f, (1f - abs((f32(_e8543) - 1f)))) * _cse_407_);
        let _cse_399_ = (_cse_400_ + _cse_406_);
        let _e8556 = constants.dtau;
        let _e8559 = constants.dtau;
        let _cse_398_ = (min(1f, max(0f, (_e8556 / (_e8559 + 0.000000000001f)))) * _cse_399_);
        let _e8570 = constants.dtau;
        let _e8573 = constants.dtau;
        let _cse_397_ = (_cse_398_ + ((1f - min(1f, max(0f, (_e8570 / (_e8573 + 0.000000000001f))))) * _cse_401_));
        let _cse_396_ = (_cse_397_ / max(_cse_401_, 0.000000000001f));
        let _cse_395_ = sqrt(_cse_396_);
        let _e8591 = constants.eos_gamma;
        let _e8594 = constants.eos_r;
        let _e8600 = constants.eos_gamma;
        let _e8603 = constants.eos_r;
        let _e8611 = constants.eos_gamma;
        let _e8614 = constants.eos_r;
        let _e8626 = constants.eos_gamma;
        let _e8630 = constants.eos_r;
        let _e8634 = constants.eos_gamma;
        let _e8637 = constants.eos_r;
        let _e8652 = constants.eos_gamma;
        let _e8655 = constants.eos_r;
        let _e8662 = constants.eos_gamma;
        let _e8665 = constants.eos_r;
        let _e8671 = constants.eos_gamma;
        let _e8674 = constants.eos_r;
        let _e8683 = constants.eos_gamma;
        let _e8686 = constants.eos_r;
        let _e8692 = constants.eos_gamma;
        let _e8695 = constants.eos_r;
        let _e8703 = constants.eos_gamma;
        let _e8706 = constants.eos_r;
        let _e8714 = constants.eos_gamma;
        let _e8717 = constants.eos_r;
        let _e8729 = constants.eos_gamma;
        let _e8733 = constants.eos_r;
        let _e8737 = constants.eos_gamma;
        let _e8740 = constants.eos_r;
        let _e8755 = constants.eos_gamma;
        let _e8758 = constants.eos_r;
        let _e8770 = constants.eos_gamma;
        let _e8773 = constants.eos_r;
        let _e8779 = constants.eos_gamma;
        let _e8782 = constants.eos_r;
        let _e8789 = constants.eos_gamma;
        let _e8792 = constants.eos_r;
        let _e8800 = constants.eos_gamma;
        let _e8803 = constants.eos_r;
        let _e8815 = constants.eos_gamma;
        let _e8819 = constants.eos_r;
        let _e8823 = constants.eos_gamma;
        let _e8826 = constants.eos_r;
        let _e8841 = constants.eos_gamma;
        let _e8844 = constants.eos_r;
        let _e8855 = constants.eos_gamma;
        let _e8858 = constants.eos_r;
        let _e8864 = constants.eos_gamma;
        let _e8867 = constants.eos_r;
        let _e8874 = constants.eos_gamma;
        let _e8877 = constants.eos_r;
        let _e8885 = constants.eos_gamma;
        let _e8888 = constants.eos_r;
        let _e8900 = constants.eos_gamma;
        let _e8904 = constants.eos_r;
        let _e8908 = constants.eos_gamma;
        let _e8911 = constants.eos_r;
        let _e8926 = constants.eos_gamma;
        let _e8929 = constants.eos_r;
        let _cse_394_ = ((sqrt(((_e8591 * _e8594) * _e121)) + ((((((((sqrt(((_e8600 * _e8603) * _e121)) * 0.625f) + (sqrt(((_e8611 * _e8614) * _e524)) * 0.375f)) + (dot(((((vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5f) * _e8626) * _e8630) / vec2(max(sqrt(((_e8634 * _e8637) * _e121)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - sqrt(((_e8652 * _e8655) * _e121))) * abs((sqrt(((_e8662 * _e8665) * _e524)) - sqrt(((_e8671 * _e8674) * _e121))))) / max(abs((sqrt(((_e8683 * _e8686) * _e524)) - sqrt(((_e8692 * _e8695) * _e121)))), (abs(((((sqrt(((_e8703 * _e8706) * _e121)) * 0.625f) + (sqrt(((_e8714 * _e8717) * _e524)) * 0.375f)) + (dot(((((vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5f) * _e8729) * _e8733) / vec2(max(sqrt(((_e8737 * _e8740) * _e121)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - sqrt(((_e8755 * _e8758) * _e121)))) + 0.00000001f))) * max(((sqrt(((_e8770 * _e8773) * _e524)) - sqrt(((_e8779 * _e8782) * _e121))) * ((((sqrt(((_e8789 * _e8792) * _e121)) * 0.625f) + (sqrt(((_e8800 * _e8803) * _e524)) * 0.375f)) + (dot(((((vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5f) * _e8815) * _e8819) / vec2(max(sqrt(((_e8823 * _e8826) * _e121)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - sqrt(((_e8841 * _e8844) * _e121)))), 0f)) / max(abs(((sqrt(((_e8855 * _e8858) * _e524)) - sqrt(((_e8864 * _e8867) * _e121))) * ((((sqrt(((_e8874 * _e8877) * _e121)) * 0.625f) + (sqrt(((_e8885 * _e8888) * _e524)) * 0.375f)) + (dot(((((vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5f) * _e8900) * _e8904) / vec2(max(sqrt(((_e8908 * _e8911) * _e121)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - sqrt(((_e8926 * _e8929) * _e121))))), 0.00000001f))) * _cse_395_);
        let _cse_393_ = (_cse_394_ * area);
        let _e8942 = normal_vec;
        let _cse_392_ = (dot(_cse_385_, (_e8942 * area)) + _cse_393_);
        let _cse_413_ = ((((((((_cse_33_ * 0.625f) + (_cse_4_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_33_) * abs((_cse_4_ - _cse_33_))) / max(abs((_cse_4_ - _cse_33_)), (abs(((((_cse_33_ * 0.625f) + (_cse_4_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_33_)) + 0.00000001f))) * max(((_cse_4_ - _cse_33_) * ((((_cse_33_ * 0.625f) + (_cse_4_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_33_)), 0f)) / max(abs(((_cse_4_ - _cse_33_) * ((((_cse_33_ * 0.625f) + (_cse_4_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_33_))), 0.00000001f));
        let _cse_412_ = (_cse_33_ + _cse_413_);
        let _cse_415_ = ((((((((_cse_34_ * 0.625f) + (_cse_5_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_34_) * abs((_cse_5_ - _cse_34_))) / max(abs((_cse_5_ - _cse_34_)), (abs(((((_cse_34_ * 0.625f) + (_cse_5_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_34_)) + 0.00000001f))) * max(((_cse_5_ - _cse_34_) * ((((_cse_34_ * 0.625f) + (_cse_5_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_34_)), 0f)) / max(abs(((_cse_5_ - _cse_34_) * ((((_cse_34_ * 0.625f) + (_cse_5_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_34_))), 0.00000001f));
        let _cse_414_ = (_cse_34_ + _cse_415_);
        let _cse_411_ = vec2<f32>(_cse_412_, _cse_414_);
        let _cse_419_ = (((_e746 * 0.625f) + (_e234 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_418_ = (_cse_419_ - _e746);
        let _cse_417_ = ((((_cse_418_ * abs((_e234 - _e746))) / max(abs((_e234 - _e746)), (abs(_cse_418_) + 0.00000001f))) * max(((_e234 - _e746) * _cse_418_), 0f)) / max(abs(((_e234 - _e746) * _cse_418_)), 0.00000001f));
        let _cse_416_ = (_e746 + _cse_417_);
        let _cse_410_ = ((_cse_411_ * 1f) / vec2(_cse_416_));
        let _e9163 = constants.eos_r;
        let _cse_431_ = ((_cse_416_ * _e9163) * (_e524 + ((((((((_e524 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e524) * abs((_e121 - _e524))) / max(abs((_e121 - _e524)), (abs(((((_e524 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e524)) + 0.00000001f))) * max(((_e121 - _e524) * ((((_e524 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e524)), 0f)) / max(abs(((_e121 - _e524) * ((((_e524 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e524))), 0.00000001f))));
        let _e9254 = constants.eos_gamma;
        let _cse_430_ = (_e9254 * _cse_431_);
        let _cse_429_ = (_cse_430_ / _cse_416_);
        let _e9259 = constants.eos_dp_drho;
        let _cse_428_ = (_cse_429_ + _e9259);
        let _cse_434_ = dot(_cse_410_, _cse_410_);
        let _cse_433_ = min(_cse_434_, _cse_428_);
        let _e9265 = low_mach_params.model;
        let _cse_432_ = (max(0f, (1f - abs(f32(_e9265)))) * _cse_433_);
        let _e9275 = low_mach_params.model;
        let _cse_427_ = ((max(0f, (1f - abs((f32(_e9275) - 2f)))) * _cse_428_) + _cse_432_);
        let _e9288 = low_mach_params.theta_floor;
        let _cse_437_ = max(_cse_434_, (_e9288 * _cse_428_));
        let _cse_436_ = min(_cse_437_, _cse_428_);
        let _e9294 = low_mach_params.model;
        let _cse_435_ = (max(0f, (1f - abs((f32(_e9294) - 1f)))) * _cse_436_);
        let _cse_426_ = (_cse_427_ + _cse_435_);
        let _e9307 = constants.dtau;
        let _e9310 = constants.dtau;
        let _cse_425_ = (min(1f, max(0f, (_e9307 / (_e9310 + 0.000000000001f)))) * _cse_426_);
        let _e9321 = constants.dtau;
        let _e9324 = constants.dtau;
        let _cse_424_ = (_cse_425_ + ((1f - min(1f, max(0f, (_e9321 / (_e9324 + 0.000000000001f))))) * _cse_428_));
        let _cse_423_ = (_cse_424_ / max(_cse_428_, 0.000000000001f));
        let _cse_422_ = sqrt(_cse_423_);
        let _e9342 = constants.eos_gamma;
        let _e9345 = constants.eos_r;
        let _e9351 = constants.eos_gamma;
        let _e9354 = constants.eos_r;
        let _e9362 = constants.eos_gamma;
        let _e9365 = constants.eos_r;
        let _e9381 = constants.eos_gamma;
        let _e9385 = constants.eos_r;
        let _e9389 = constants.eos_gamma;
        let _e9392 = constants.eos_r;
        let _e9407 = constants.eos_gamma;
        let _e9410 = constants.eos_r;
        let _e9417 = constants.eos_gamma;
        let _e9420 = constants.eos_r;
        let _e9426 = constants.eos_gamma;
        let _e9429 = constants.eos_r;
        let _e9438 = constants.eos_gamma;
        let _e9441 = constants.eos_r;
        let _e9447 = constants.eos_gamma;
        let _e9450 = constants.eos_r;
        let _e9458 = constants.eos_gamma;
        let _e9461 = constants.eos_r;
        let _e9469 = constants.eos_gamma;
        let _e9472 = constants.eos_r;
        let _e9488 = constants.eos_gamma;
        let _e9492 = constants.eos_r;
        let _e9496 = constants.eos_gamma;
        let _e9499 = constants.eos_r;
        let _e9514 = constants.eos_gamma;
        let _e9517 = constants.eos_r;
        let _e9529 = constants.eos_gamma;
        let _e9532 = constants.eos_r;
        let _e9538 = constants.eos_gamma;
        let _e9541 = constants.eos_r;
        let _e9548 = constants.eos_gamma;
        let _e9551 = constants.eos_r;
        let _e9559 = constants.eos_gamma;
        let _e9562 = constants.eos_r;
        let _e9578 = constants.eos_gamma;
        let _e9582 = constants.eos_r;
        let _e9586 = constants.eos_gamma;
        let _e9589 = constants.eos_r;
        let _e9604 = constants.eos_gamma;
        let _e9607 = constants.eos_r;
        let _e9618 = constants.eos_gamma;
        let _e9621 = constants.eos_r;
        let _e9627 = constants.eos_gamma;
        let _e9630 = constants.eos_r;
        let _e9637 = constants.eos_gamma;
        let _e9640 = constants.eos_r;
        let _e9648 = constants.eos_gamma;
        let _e9651 = constants.eos_r;
        let _e9667 = constants.eos_gamma;
        let _e9671 = constants.eos_r;
        let _e9675 = constants.eos_gamma;
        let _e9678 = constants.eos_r;
        let _e9693 = constants.eos_gamma;
        let _e9696 = constants.eos_r;
        let _cse_421_ = ((sqrt(((_e9342 * _e9345) * _e524)) + ((((((((sqrt(((_e9351 * _e9354) * _e524)) * 0.625f) + (sqrt(((_e9362 * _e9365) * _e121)) * 0.375f)) + (dot(((((vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)) * 0.5f) * _e9381) * _e9385) / vec2(max(sqrt(((_e9389 * _e9392) * _e524)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - sqrt(((_e9407 * _e9410) * _e524))) * abs((sqrt(((_e9417 * _e9420) * _e121)) - sqrt(((_e9426 * _e9429) * _e524))))) / max(abs((sqrt(((_e9438 * _e9441) * _e121)) - sqrt(((_e9447 * _e9450) * _e524)))), (abs(((((sqrt(((_e9458 * _e9461) * _e524)) * 0.625f) + (sqrt(((_e9469 * _e9472) * _e121)) * 0.375f)) + (dot(((((vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)) * 0.5f) * _e9488) * _e9492) / vec2(max(sqrt(((_e9496 * _e9499) * _e524)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - sqrt(((_e9514 * _e9517) * _e524)))) + 0.00000001f))) * max(((sqrt(((_e9529 * _e9532) * _e121)) - sqrt(((_e9538 * _e9541) * _e524))) * ((((sqrt(((_e9548 * _e9551) * _e524)) * 0.625f) + (sqrt(((_e9559 * _e9562) * _e121)) * 0.375f)) + (dot(((((vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)) * 0.5f) * _e9578) * _e9582) / vec2(max(sqrt(((_e9586 * _e9589) * _e524)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - sqrt(((_e9604 * _e9607) * _e524)))), 0f)) / max(abs(((sqrt(((_e9618 * _e9621) * _e121)) - sqrt(((_e9627 * _e9630) * _e524))) * ((((sqrt(((_e9637 * _e9640) * _e524)) * 0.625f) + (sqrt(((_e9648 * _e9651) * _e121)) * 0.375f)) + (dot(((((vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)) * 0.5f) * _e9667) * _e9671) / vec2(max(sqrt(((_e9675 * _e9678) * _e524)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - sqrt(((_e9693 * _e9696) * _e524))))), 0.00000001f))) * _cse_422_);
        let _cse_420_ = (_cse_421_ * area);
        let _e9709 = normal_vec;
        let _cse_409_ = (dot(_cse_410_, (_e9709 * area)) + _cse_420_);
        let _cse_391_ = max(_cse_392_, _cse_409_);
        let _cse_390_ = max(_cse_391_, 0f);
        let _e9716 = normal_vec;
        let _cse_442_ = (dot(_cse_385_, (_e9716 * area)) - _cse_393_);
        let _e9720 = normal_vec;
        let _cse_443_ = (dot(_cse_410_, (_e9720 * area)) - _cse_420_);
        let _cse_441_ = min(_cse_442_, _cse_443_);
        let _cse_440_ = min(_cse_441_, 0f);
        let _cse_439_ = (_cse_390_ - _cse_440_);
        let _cse_438_ = max(_cse_439_, 0.000001f);
        let _cse_389_ = (_cse_390_ / _cse_438_);
        let _cse_444_ = (_cse_440_ * _cse_389_);
        let _e9732 = normal_vec;
        let _cse_384_ = ((dot(_cse_385_, (_e9732 * area)) * _cse_389_) - _cse_444_);
        let _cse_447_ = (1f - _cse_389_);
        let _e9739 = normal_vec;
        let _cse_446_ = (dot(_cse_410_, (_e9739 * area)) * _cse_447_);
        let _cse_445_ = (_cse_446_ + _cse_444_);
        let _e9749 = low_mach_params.pressure_coupling_alpha;
        let _e9752 = constants.eos_r;
        let _e9841 = constants.dtau;
        let _e9844 = constants.dtau;
        let _e9855 = low_mach_params.model;
        phi_0_ = (((_cse_384_ * _cse_387_) + (_cse_445_ * _cse_416_)) + ((((((_e9749 * (((_cse_387_ * _e9752) * (_e121 + ((((((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e524 - _e121))) / max(abs((_e524 - _e121)), (abs(((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e524 - _e121) * ((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e524 - _e121) * ((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f)))) - _cse_431_)) * 0.5f) * ((1f / max(_cse_401_, 0.000000000001f)) + (1f / max(_cse_428_, 0.000000000001f)))) * min(1f, max(0f, (_e9841 / (_e9844 + 0.000000000001f))))) * (1f - max(0f, (1f - abs((f32(_e9855) - 2f)))))) * area));
        let _e9877 = constants.eos_r;
        let _e9954 = normal_vec.x;
        let _e9959 = constants.viscosity;
        let _e9973 = normal_vec.x;
        let _e9981 = normal_vec.y;
        let _e9985 = lambda;
        let _e9989 = constants.viscosity;
        let _e9997 = normal_vec.x;
        let _e10001 = normal_vec.y;
        phi_1_ = ((((_cse_384_ * _cse_386_.x) + (_cse_445_ * _cse_411_.x)) + ((((((_cse_389_ * _cse_387_) * _e9877) * (_e121 + ((((((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e524 - _e121))) / max(abs((_e524 - _e121)), (abs(((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e524 - _e121) * ((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e524 - _e121) * ((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f)))) + (_cse_447_ * _cse_431_)) * area) * _e9954)) - ((((_e9959 * ((((2f * select(s_neigh_grad_u_x_x, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e9973) + ((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e9981))) * _e9985) + ((_e9989 * ((((2f * s_own_grad_u_x_x) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e9997) + ((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e10001))) * lambda_other)) * area));
        let _e10017 = constants.eos_r;
        let _e10094 = normal_vec.y;
        let _e10099 = constants.viscosity;
        let _e10106 = normal_vec.x;
        let _e10121 = normal_vec.y;
        let _e10125 = lambda;
        let _e10129 = constants.viscosity;
        let _e10132 = normal_vec.x;
        let _e10141 = normal_vec.y;
        phi_2_ = ((((_cse_384_ * _cse_386_.y) + (_cse_445_ * _cse_411_.y)) + ((((((_cse_389_ * _cse_387_) * _e10017) * (_e121 + ((((((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e524 - _e121))) / max(abs((_e524 - _e121)), (abs(((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e524 - _e121) * ((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e524 - _e121) * ((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f)))) + (_cse_447_ * _cse_431_)) * area) * _e10094)) - ((((_e10099 * (((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e10106) + (((2f * select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e10121))) * _e10125) + ((_e10129 * (((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e10132) + (((2f * s_own_grad_u_y_y) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e10141))) * lambda_other)) * area));
        let _e10151 = constants.eos_r;
        let _e10226 = constants.eos_gm1_;
        let _e10236 = constants.eos_r;
        let _e10313 = constants.eos_gm1_;
        let _e10326 = constants.eos_r;
        let _e10407 = lambda;
        let _e10412 = normal_vec;
        let _e10423 = state[((owner_1 * 22u) + 10u)];
        let _e10428 = normal_vec;
        let _e10434 = lambda;
        let _e10443 = normal_vec;
        let _e10450 = lambda;
        let _e10455 = normal_vec;
        let _e10466 = state[((owner_1 * 22u) + 11u)];
        let _e10471 = normal_vec;
        let _e10477 = lambda;
        let _e10486 = normal_vec;
        let _e10491 = constants.viscosity;
        let _e10495 = constants.viscosity;
        let _e10509 = normal_vec.x;
        let _e10517 = normal_vec.y;
        let _e10521 = lambda;
        let _e10525 = constants.viscosity;
        let _e10533 = normal_vec.x;
        let _e10537 = normal_vec.y;
        let _e10545 = constants.viscosity;
        let _e10552 = normal_vec.x;
        let _e10567 = normal_vec.y;
        let _e10571 = lambda;
        let _e10575 = constants.viscosity;
        let _e10578 = normal_vec.x;
        let _e10587 = normal_vec.y;
        phi_3_ = ((((_cse_384_ * (((((_cse_387_ * _e10151) * (_e121 + ((((((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e524 - _e121))) / max(abs((_e524 - _e121)), (abs(((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e524 - _e121) * ((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e524 - _e121) * ((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f)))) / max(_e10226, 0.000000000001f)) + ((0.5f * _cse_387_) * _cse_405_)) + ((_cse_387_ * _e10236) * (_e121 + ((((((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e524 - _e121))) / max(abs((_e524 - _e121)), (abs(((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e524 - _e121) * ((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e524 - _e121) * ((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f)))))) + (_cse_445_ * (((_cse_431_ / max(_e10313, 0.000000000001f)) + ((0.5f * _cse_416_) * _cse_434_)) + _cse_431_))) + (_cse_444_ * (((_cse_387_ * _e10326) * (_e121 + ((((((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e524 - _e121))) / max(abs((_e524 - _e121)), (abs(((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e524 - _e121) * ((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e524 - _e121) * ((((_e121 * 0.625f) + (_e524 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f)))) - _cse_431_))) - (dot(((vec2<f32>(dot((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e10407) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e10412 * select(0f, 1f, is_boundary_1)) * (((s_own_u_x - _e10423) / max(dist, 0.000001f)) - dot(_e10428, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e10434) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))), _e10443), dot((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e10450) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e10455 * select(0f, 1f, is_boundary_1)) * (((s_own_u_y - _e10466) / max(dist, 0.000001f)) - dot(_e10471, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e10477) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))), _e10486)) * _e10491) + vec2<f32>((((_e10495 * ((((2f * select(s_neigh_grad_u_x_x, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e10509) + ((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e10517))) * _e10521) + ((_e10525 * ((((2f * s_own_grad_u_x_x) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e10533) + ((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e10537))) * lambda_other)), (((_e10545 * (((select(s_neigh_grad_u_x_y, 0f, is_boundary_1) + select(s_neigh_grad_u_y_x, 0f, is_boundary_1)) * _e10552) + (((2f * select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) - (0.6666667f * (select(s_neigh_grad_u_x_x, 0f, is_boundary_1) + select(s_neigh_grad_u_y_y, 0f, is_boundary_1)))) * _e10567))) * _e10571) + ((_e10575 * (((s_own_grad_u_x_y + s_own_grad_u_y_x) * _e10578) + (((2f * s_own_grad_u_y_y) - (0.6666667f * (s_own_grad_u_x_x + s_own_grad_u_y_y))) * _e10587))) * lambda_other)))), ((_cse_385_ * _cse_389_) + (_cse_410_ * _cse_447_))) * area));
        phi_4_ = 0f;
        phi_5_ = 0f;
        phi_6_ = 0f;
        phi_7_ = 0f;
    }
    let _e10611 = phi_0_;
    fluxes[((idx * 8u) + 0u)] = _e10611;
    let _e10618 = phi_1_;
    fluxes[((idx * 8u) + 1u)] = _e10618;
    let _e10625 = phi_2_;
    fluxes[((idx * 8u) + 2u)] = _e10625;
    let _e10632 = phi_3_;
    fluxes[((idx * 8u) + 3u)] = _e10632;
    let _e10639 = phi_4_;
    fluxes[((idx * 8u) + 4u)] = _e10639;
    let _e10646 = phi_5_;
    fluxes[((idx * 8u) + 5u)] = _e10646;
    let _e10653 = phi_6_;
    fluxes[((idx * 8u) + 6u)] = _e10653;
    let _e10660 = phi_7_;
    fluxes[((idx * 8u) + 7u)] = _e10660;
    return;
}
"#;
    }
    pub mod flux_module_gradients_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleGradientsCompressible::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleGradientsCompressible::BindGroup1::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::flux_module_gradients_compressible::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleGradientsCompressible::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleGradientsCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_gradients_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_rho_u_x: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_rho_u_y: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_rho: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_rho_e: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_T: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_u_x: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_u_y: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e31 = k;
        if (_e31 < end) {
        } else {
            break;
        }
        {
            let _e34 = k;
            let face_idx = cell_faces[_e34];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e60 = face_normals[face_idx].x;
            let _e64 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e60, _e64);
            let _e68 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e68) < 0f) {
                let _e72 = normal_vec;
                normal_vec = -(_e72);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e81 = other_idx;
                let other_center = cell_centers[_e81];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let _e88 = normal_vec;
            let d_own = abs(dot((face_center_vec - cell_center_vec), _e88));
            let _e91 = other_center_vec;
            let _e93 = normal_vec;
            let d_neigh = abs(dot((_e91 - face_center_vec), _e93));
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e102 = lambda;
            let lambda_other = (1f - _e102);
            let _e105 = normal_vec;
            let _e112 = state[((idx * 22u) + 1u)];
            let _e113 = lambda;
            let _e115 = other_idx;
            let _e122 = state[((_e115 * 22u) + 1u)];
            let _e129 = state[((idx * 22u) + 1u)];
            let _e136 = bc_value[((face_idx * 8u) + 1u)];
            let _e143 = bc_kind[((face_idx * 8u) + 1u)];
            let _e153 = state[((idx * 22u) + 1u)];
            let _e160 = bc_value[((face_idx * 8u) + 1u)];
            let _e169 = bc_kind[((face_idx * 8u) + 1u)];
            let _e180 = state[((idx * 22u) + 1u)];
            let _e187 = state[((idx * 22u) + 1u)];
            let _e189 = normal_vec.x;
            let _e197 = state[((idx * 22u) + 2u)];
            let _e199 = normal_vec.y;
            let _e203 = normal_vec.x;
            let _e215 = grad_acc_rho_u_x;
            grad_acc_rho_u_x = (_e215 + ((_e105 * ((_e112 * _e113) + (select(select(_e122, select(select(_e129, _e136, (_e143 == 1u)), (_e153 + (_e160 * d_own)), (_e169 == 2u)), is_boundary), (_e180 - (((_e187 * _e189) + (_e197 * _e199)) * _e203)), (is_boundary && (boundary_type == 4u))) * lambda_other))) * area));
            let _e217 = normal_vec;
            let _e224 = state[((idx * 22u) + 2u)];
            let _e225 = lambda;
            let _e227 = other_idx;
            let _e234 = state[((_e227 * 22u) + 2u)];
            let _e241 = state[((idx * 22u) + 2u)];
            let _e248 = bc_value[((face_idx * 8u) + 2u)];
            let _e255 = bc_kind[((face_idx * 8u) + 2u)];
            let _e265 = state[((idx * 22u) + 2u)];
            let _e272 = bc_value[((face_idx * 8u) + 2u)];
            let _e281 = bc_kind[((face_idx * 8u) + 2u)];
            let _e292 = state[((idx * 22u) + 2u)];
            let _e299 = state[((idx * 22u) + 1u)];
            let _e301 = normal_vec.x;
            let _e309 = state[((idx * 22u) + 2u)];
            let _e311 = normal_vec.y;
            let _e315 = normal_vec.y;
            let _e327 = grad_acc_rho_u_y;
            grad_acc_rho_u_y = (_e327 + ((_e217 * ((_e224 * _e225) + (select(select(_e234, select(select(_e241, _e248, (_e255 == 1u)), (_e265 + (_e272 * d_own)), (_e281 == 2u)), is_boundary), (_e292 - (((_e299 * _e301) + (_e309 * _e311)) * _e315)), (is_boundary && (boundary_type == 4u))) * lambda_other))) * area));
            let _e329 = normal_vec;
            let _e336 = state[((idx * 22u) + 0u)];
            let _e337 = lambda;
            let _e339 = other_idx;
            let _e346 = state[((_e339 * 22u) + 0u)];
            let _e353 = state[((idx * 22u) + 0u)];
            let _e360 = bc_value[((face_idx * 8u) + 0u)];
            let _e367 = bc_kind[((face_idx * 8u) + 0u)];
            let _e377 = state[((idx * 22u) + 0u)];
            let _e384 = bc_value[((face_idx * 8u) + 0u)];
            let _e393 = bc_kind[((face_idx * 8u) + 0u)];
            let _e403 = grad_acc_rho;
            grad_acc_rho = (_e403 + ((_e329 * ((_e336 * _e337) + (select(_e346, select(select(_e353, _e360, (_e367 == 1u)), (_e377 + (_e384 * d_own)), (_e393 == 2u)), is_boundary) * lambda_other))) * area));
            let _e405 = normal_vec;
            let _e412 = state[((idx * 22u) + 7u)];
            let _e413 = lambda;
            let _e415 = other_idx;
            let _e422 = state[((_e415 * 22u) + 7u)];
            let _e429 = state[((idx * 22u) + 7u)];
            let _e436 = bc_value[((face_idx * 8u) + 3u)];
            let _e443 = bc_kind[((face_idx * 8u) + 3u)];
            let _e453 = state[((idx * 22u) + 7u)];
            let _e460 = bc_value[((face_idx * 8u) + 3u)];
            let _e469 = bc_kind[((face_idx * 8u) + 3u)];
            let _e479 = grad_acc_rho_e;
            grad_acc_rho_e = (_e479 + ((_e405 * ((_e412 * _e413) + (select(_e422, select(select(_e429, _e436, (_e443 == 1u)), (_e453 + (_e460 * d_own)), (_e469 == 2u)), is_boundary) * lambda_other))) * area));
            let _e481 = normal_vec;
            let _e488 = state[((idx * 22u) + 9u)];
            let _e489 = lambda;
            let _e491 = other_idx;
            let _e498 = state[((_e491 * 22u) + 9u)];
            let _e505 = state[((idx * 22u) + 9u)];
            let _e512 = bc_value[((face_idx * 8u) + 7u)];
            let _e519 = bc_kind[((face_idx * 8u) + 7u)];
            let _e529 = state[((idx * 22u) + 9u)];
            let _e536 = bc_value[((face_idx * 8u) + 7u)];
            let _e545 = bc_kind[((face_idx * 8u) + 7u)];
            let _e555 = grad_acc_T;
            grad_acc_T = (_e555 + ((_e481 * ((_e488 * _e489) + (select(_e498, select(select(_e505, _e512, (_e519 == 1u)), (_e529 + (_e536 * d_own)), (_e545 == 2u)), is_boundary) * lambda_other))) * area));
            let _e557 = normal_vec;
            let _e564 = state[((idx * 22u) + 10u)];
            let _e565 = lambda;
            let _e567 = other_idx;
            let _e574 = state[((_e567 * 22u) + 10u)];
            let _e581 = state[((idx * 22u) + 10u)];
            let _e588 = bc_value[((face_idx * 8u) + 4u)];
            let _e595 = bc_kind[((face_idx * 8u) + 4u)];
            let _e605 = state[((idx * 22u) + 10u)];
            let _e612 = bc_value[((face_idx * 8u) + 4u)];
            let _e621 = bc_kind[((face_idx * 8u) + 4u)];
            let _e632 = state[((idx * 22u) + 10u)];
            let _e639 = state[((idx * 22u) + 10u)];
            let _e641 = normal_vec.x;
            let _e649 = state[((idx * 22u) + 11u)];
            let _e651 = normal_vec.y;
            let _e655 = normal_vec.x;
            let _e667 = grad_acc_u_x;
            grad_acc_u_x = (_e667 + ((_e557 * ((_e564 * _e565) + (select(select(_e574, select(select(_e581, _e588, (_e595 == 1u)), (_e605 + (_e612 * d_own)), (_e621 == 2u)), is_boundary), (_e632 - (((_e639 * _e641) + (_e649 * _e651)) * _e655)), (is_boundary && (boundary_type == 4u))) * lambda_other))) * area));
            let _e669 = normal_vec;
            let _e676 = state[((idx * 22u) + 11u)];
            let _e677 = lambda;
            let _e679 = other_idx;
            let _e686 = state[((_e679 * 22u) + 11u)];
            let _e693 = state[((idx * 22u) + 11u)];
            let _e700 = bc_value[((face_idx * 8u) + 5u)];
            let _e707 = bc_kind[((face_idx * 8u) + 5u)];
            let _e717 = state[((idx * 22u) + 11u)];
            let _e724 = bc_value[((face_idx * 8u) + 5u)];
            let _e733 = bc_kind[((face_idx * 8u) + 5u)];
            let _e744 = state[((idx * 22u) + 11u)];
            let _e751 = state[((idx * 22u) + 10u)];
            let _e753 = normal_vec.x;
            let _e761 = state[((idx * 22u) + 11u)];
            let _e763 = normal_vec.y;
            let _e767 = normal_vec.y;
            let _e779 = grad_acc_u_y;
            grad_acc_u_y = (_e779 + ((_e669 * ((_e676 * _e677) + (select(select(_e686, select(select(_e693, _e700, (_e707 == 1u)), (_e717 + (_e724 * d_own)), (_e733 == 2u)), is_boundary), (_e744 - (((_e751 * _e753) + (_e761 * _e763)) * _e767)), (is_boundary && (boundary_type == 4u))) * lambda_other))) * area));
        }
        continuing {
            let _e782 = k;
            k = (_e782 + 1u);
        }
    }
    let _e784 = grad_acc_rho_u_x;
    let grad_out_rho_u_x = ((_e784 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 3u)] = grad_out_rho_u_x.x;
    state[((idx * 22u) + 4u)] = grad_out_rho_u_x.y;
    let _e805 = grad_acc_rho_u_y;
    let grad_out_rho_u_y = ((_e805 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 5u)] = grad_out_rho_u_y.x;
    state[((idx * 22u) + 6u)] = grad_out_rho_u_y.y;
    let _e826 = grad_acc_rho;
    let grad_out_rho = ((_e826 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 12u)] = grad_out_rho.x;
    state[((idx * 22u) + 13u)] = grad_out_rho.y;
    let _e847 = grad_acc_rho_e;
    let grad_out_rho_e = ((_e847 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 14u)] = grad_out_rho_e.x;
    state[((idx * 22u) + 15u)] = grad_out_rho_e.y;
    let _e868 = grad_acc_T;
    let grad_out_T = ((_e868 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 16u)] = grad_out_T.x;
    state[((idx * 22u) + 17u)] = grad_out_T.y;
    let _e889 = grad_acc_u_x;
    let grad_out_u_x = ((_e889 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 18u)] = grad_out_u_x.x;
    state[((idx * 22u) + 19u)] = grad_out_u_x.y;
    let _e910 = grad_acc_u_y;
    let grad_out_u_y = ((_e910 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 20u)] = grad_out_u_y.x;
    state[((idx * 22u) + 21u)] = grad_out_u_y.y;
    return;
}
"#;
    }
    pub mod flux_module_gradients_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: flux_module_gradients_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_gradients_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_p: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e31 = k;
        if (_e31 < end) {
        } else {
            break;
        }
        {
            let _e34 = k;
            let face_idx = cell_faces[_e34];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e60 = face_normals[face_idx].x;
            let _e64 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e60, _e64);
            let _e68 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e68) < 0f) {
                let _e72 = normal_vec;
                normal_vec = -(_e72);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e81 = other_idx;
                let other_center = cell_centers[_e81];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let _e88 = normal_vec;
            let d_own = abs(dot((face_center_vec - cell_center_vec), _e88));
            let _e91 = other_center_vec;
            let _e93 = normal_vec;
            let d_neigh = abs(dot((_e91 - face_center_vec), _e93));
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e102 = lambda;
            let lambda_other = (1f - _e102);
            let _e105 = normal_vec;
            let _e112 = state[((idx * 8u) + 2u)];
            let _e113 = lambda;
            let _e115 = other_idx;
            let _e122 = state[((_e115 * 8u) + 2u)];
            let _e129 = state[((idx * 8u) + 2u)];
            let _e136 = bc_value[((face_idx * 3u) + 2u)];
            let _e143 = bc_kind[((face_idx * 3u) + 2u)];
            let _e153 = state[((idx * 8u) + 2u)];
            let _e160 = bc_value[((face_idx * 3u) + 2u)];
            let _e169 = bc_kind[((face_idx * 3u) + 2u)];
            let _e179 = grad_acc_p;
            grad_acc_p = (_e179 + ((_e105 * ((_e112 * _e113) + (select(_e122, select(select(_e129, _e136, (_e143 == 1u)), (_e153 + (_e160 * d_own)), (_e169 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e182 = k;
            k = (_e182 + 1u);
        }
    }
    let _e184 = grad_acc_p;
    let grad_out_p = ((_e184 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 8u) + 4u)] = grad_out_p.x;
    state[((idx * 8u) + 5u)] = grad_out_p.y;
    return;
}
"#;
    }
    pub mod flux_module_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleIncompressibleMomentum::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: flux_module_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleIncompressibleMomentum::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

fn bc_neighbor_scalar(interior: f32, owner: f32, kind: u32, value: f32, d_own: f32, is_boundary: bool) -> f32 {
    var boundary: f32;

    boundary = owner;
    if (kind == 1u) {
        boundary = value;
    }
    if (kind == 2u) {
        boundary = (owner + (value * d_own));
    }
    let _e13 = boundary;
    return select(interior, _e13, is_boundary);
}

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var neigh_idx: u32;
    var normal_vec: vec2<f32>;
    var c_neigh_vec: vec2<f32>;
    var lambda: f32 = 0.5f;

    let _e5 = constants.stride_x;
    let idx = ((global_id.y * _e5) + global_id.x);
    if (idx >= arrayLength((&face_areas))) {
        return;
    }
    let owner_1 = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let is_boundary_1 = (neighbor == -1i);
    neigh_idx = owner_1;
    if (neighbor != -1i) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let _e36 = face_normals[idx].x;
    let _e40 = face_normals[idx].y;
    normal_vec = vec2<f32>(_e36, _e40);
    let c_owner = cell_centers[owner_1];
    let c_owner_vec = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec = vec2<f32>(face_center.x, face_center.y);
    let _e53 = normal_vec;
    if (dot((face_center_vec - c_owner_vec), _e53) < 0f) {
        let _e57 = normal_vec;
        normal_vec = -(_e57);
    }
    let _e60 = neigh_idx;
    let c_neigh = cell_centers[_e60];
    c_neigh_vec = vec2<f32>(c_neigh.x, c_neigh.y);
    let c_neigh_cell_vec = c_neigh_vec;
    if is_boundary_1 {
        c_neigh_vec = face_center_vec;
    }
    let _e69 = normal_vec;
    let d_own_1 = abs(dot((face_center_vec - c_owner_vec), _e69));
    let _e72 = c_neigh_vec;
    let _e74 = normal_vec;
    let d_neigh = abs(dot((_e72 - face_center_vec), _e74));
    let total_dist = (d_own_1 + d_neigh);
    if (total_dist > 0.000001f) {
        lambda = (d_neigh / total_dist);
    }
    let _e82 = lambda;
    let lambda_other = (1f - _e82);
    let _e85 = c_neigh_vec;
    let d_vec = (_e85 - c_owner_vec);
    let _e87 = normal_vec;
    let dist_proj = abs(dot(d_vec, _e87));
    let dist = max(dist_proj, 0.000001f);
    let _e98 = state[((owner_1 * 8u) + 0u)];
    let _e105 = state[((owner_1 * 8u) + 0u)];
    let _e112 = bc_kind[((idx * 3u) + 0u)];
    let _e119 = bc_value[((idx * 3u) + 0u)];
    let _e120 = bc_neighbor_scalar(_e98, _e105, _e112, _e119, d_own_1, is_boundary_1);
    let _e127 = state[((owner_1 * 8u) + 0u)];
    let _e134 = state[((owner_1 * 8u) + 0u)];
    let _e136 = normal_vec.x;
    let _e144 = state[((owner_1 * 8u) + 1u)];
    let _e146 = normal_vec.y;
    let _e150 = normal_vec.x;
    let s_own_U_x = select(_e120, (_e127 - (((_e134 * _e136) + (_e144 * _e146)) * _e150)), (is_boundary_1 && (boundary_type == 4u)));
    let _e163 = state[((owner_1 * 8u) + 1u)];
    let _e170 = state[((owner_1 * 8u) + 1u)];
    let _e177 = bc_kind[((idx * 3u) + 1u)];
    let _e184 = bc_value[((idx * 3u) + 1u)];
    let _e185 = bc_neighbor_scalar(_e163, _e170, _e177, _e184, d_own_1, is_boundary_1);
    let _e192 = state[((owner_1 * 8u) + 1u)];
    let _e199 = state[((owner_1 * 8u) + 0u)];
    let _e201 = normal_vec.x;
    let _e209 = state[((owner_1 * 8u) + 1u)];
    let _e211 = normal_vec.y;
    let _e215 = normal_vec.y;
    let s_own_U_y = select(_e185, (_e192 - (((_e199 * _e201) + (_e209 * _e211)) * _e215)), (is_boundary_1 && (boundary_type == 4u)));
    let s_own_d_p = state[((owner_1 * 8u) + 3u)];
    let s_own_grad_p_x = state[((owner_1 * 8u) + 4u)];
    let s_own_grad_p_y = state[((owner_1 * 8u) + 5u)];
    let _e249 = state[((owner_1 * 8u) + 2u)];
    let _e256 = state[((owner_1 * 8u) + 2u)];
    let _e263 = bc_kind[((idx * 3u) + 2u)];
    let _e270 = bc_value[((idx * 3u) + 2u)];
    let _e271 = bc_neighbor_scalar(_e249, _e256, _e263, _e270, d_own_1, is_boundary_1);
    let _e272 = neigh_idx;
    let _e279 = state[((_e272 * 8u) + 0u)];
    let _e286 = state[((owner_1 * 8u) + 0u)];
    let _e293 = bc_kind[((idx * 3u) + 0u)];
    let _e300 = bc_value[((idx * 3u) + 0u)];
    let _e301 = bc_neighbor_scalar(_e279, _e286, _e293, _e300, d_own_1, is_boundary_1);
    let _e308 = state[((owner_1 * 8u) + 0u)];
    let _e315 = state[((owner_1 * 8u) + 0u)];
    let _e317 = normal_vec.x;
    let _e325 = state[((owner_1 * 8u) + 1u)];
    let _e327 = normal_vec.y;
    let _e331 = normal_vec.x;
    let s_neigh_U_x = select(_e301, (_e308 - (((_e315 * _e317) + (_e325 * _e327)) * _e331)), (is_boundary_1 && (boundary_type == 4u)));
    let _e338 = neigh_idx;
    let _e345 = state[((_e338 * 8u) + 1u)];
    let _e352 = state[((owner_1 * 8u) + 1u)];
    let _e359 = bc_kind[((idx * 3u) + 1u)];
    let _e366 = bc_value[((idx * 3u) + 1u)];
    let _e367 = bc_neighbor_scalar(_e345, _e352, _e359, _e366, d_own_1, is_boundary_1);
    let _e374 = state[((owner_1 * 8u) + 1u)];
    let _e381 = state[((owner_1 * 8u) + 0u)];
    let _e383 = normal_vec.x;
    let _e391 = state[((owner_1 * 8u) + 1u)];
    let _e393 = normal_vec.y;
    let _e397 = normal_vec.y;
    let s_neigh_U_y = select(_e367, (_e374 - (((_e381 * _e383) + (_e391 * _e393)) * _e397)), (is_boundary_1 && (boundary_type == 4u)));
    let _e404 = neigh_idx;
    let _e411 = state[((_e404 * 8u) + 3u)];
    let _e418 = state[((owner_1 * 8u) + 3u)];
    let s_neigh_d_p = select(_e411, _e418, is_boundary_1);
    let _e420 = neigh_idx;
    let _e427 = state[((_e420 * 8u) + 4u)];
    let _e434 = state[((owner_1 * 8u) + 4u)];
    let s_neigh_grad_p_x = select(_e427, _e434, is_boundary_1);
    let _e436 = neigh_idx;
    let _e443 = state[((_e436 * 8u) + 5u)];
    let _e450 = state[((owner_1 * 8u) + 5u)];
    let s_neigh_grad_p_y = select(_e443, _e450, is_boundary_1);
    let _e452 = neigh_idx;
    let _e459 = state[((_e452 * 8u) + 2u)];
    let _e466 = state[((owner_1 * 8u) + 2u)];
    let _e473 = bc_kind[((idx * 3u) + 2u)];
    let _e480 = bc_value[((idx * 3u) + 2u)];
    let _e481 = bc_neighbor_scalar(_e459, _e466, _e473, _e480, d_own_1, is_boundary_1);
    let _e490 = constants.density;
    let _e492 = lambda;
    let _e498 = lambda;
    let _e515 = lambda;
    let _e521 = normal_vec;
    let _e527 = constants.density;
    let _e528 = lambda;
    fluxes[((idx * 3u) + 0u)] = (((_e490 * dot((((vec2<f32>(s_own_U_x, s_own_U_y) * _e492) + (vec2<f32>(s_neigh_U_x, s_neigh_U_y) * lambda_other)) + (((vec2<f32>(s_own_grad_p_x, s_own_grad_p_y) * _e498) + (vec2<f32>(select(s_neigh_grad_p_x, 0f, (is_boundary_1 && !((boundary_type == 2u)))), select(s_neigh_grad_p_y, 0f, (is_boundary_1 && !((boundary_type == 2u))))) * lambda_other)) * ((s_own_d_p * _e515) + (s_neigh_d_p * lambda_other)))), _e521)) * area) - ((((_e527 * ((s_own_d_p * _e528) + (s_neigh_d_p * lambda_other))) * (_e481 - _e271)) / dist) * area));
    let _e546 = constants.density;
    let _e548 = lambda;
    let _e554 = lambda;
    let _e571 = lambda;
    let _e577 = normal_vec;
    let _e583 = constants.density;
    let _e584 = lambda;
    fluxes[((idx * 3u) + 1u)] = (((_e546 * dot((((vec2<f32>(s_own_U_x, s_own_U_y) * _e548) + (vec2<f32>(s_neigh_U_x, s_neigh_U_y) * lambda_other)) + (((vec2<f32>(s_own_grad_p_x, s_own_grad_p_y) * _e554) + (vec2<f32>(select(s_neigh_grad_p_x, 0f, (is_boundary_1 && !((boundary_type == 2u)))), select(s_neigh_grad_p_y, 0f, (is_boundary_1 && !((boundary_type == 2u))))) * lambda_other)) * ((s_own_d_p * _e571) + (s_neigh_d_p * lambda_other)))), _e577)) * area) - ((((_e583 * ((s_own_d_p * _e584) + (s_neigh_d_p * lambda_other))) * (_e481 - _e271)) / dist) * area));
    let _e602 = constants.density;
    let _e604 = lambda;
    let _e610 = lambda;
    let _e627 = lambda;
    let _e633 = normal_vec;
    fluxes[((idx * 3u) + 2u)] = ((_e602 * dot((((vec2<f32>(s_own_U_x, s_own_U_y) * _e604) + (vec2<f32>(s_neigh_U_x, s_neigh_U_y) * lambda_other)) + (((vec2<f32>(s_own_grad_p_x, s_own_grad_p_y) * _e610) + (vec2<f32>(select(s_neigh_grad_p_x, 0f, (is_boundary_1 && !((boundary_type == 2u)))), select(s_neigh_grad_p_y, 0f, (is_boundary_1 && !((boundary_type == 2u))))) * lambda_other)) * ((s_own_d_p * _e627) + (s_neigh_d_p * lambda_other)))), _e633)) * area);
    return;
}
"#;
    }
    pub mod generic_coupled_apply {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub row_offsets: wgpu::BufferBinding<'a>,
            pub col_indices: wgpu::BufferBinding<'a>,
            pub matrix_values: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub row_offsets: wgpu::BindGroupEntry<'a>,
            pub col_indices: wgpu::BindGroupEntry<'a>,
            pub matrix_values: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    row_offsets: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.row_offsets),
                    },
                    col_indices: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.col_indices),
                    },
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.row_offsets, self.col_indices, self.matrix_values]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"row_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"col_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
            pub y: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
            pub y: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                    y: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.y),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.x, self.y, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"y\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::generic_coupled_apply::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledApply::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_apply.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> col_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(1) @binding(0) 
var<storage> x: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> y: array<f32>;
@group(1) @binding(2) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sum: f32 = 0f;
    var i: u32;

    let _e5 = constants.stride_x;
    let row = ((global_id.y * _e5) + global_id.x);
    let n = (arrayLength((&row_offsets)) - 1u);
    if (row >= n) {
        return;
    }
    let start = row_offsets[row];
    let end = row_offsets[(row + 1u)];
    i = start;
    loop {
        let _e23 = i;
        if (_e23 < end) {
        } else {
            break;
        }
        {
            let _e26 = i;
            let col = col_indices[_e26];
            let _e30 = i;
            let val = matrix_values[_e30];
            let x_val = x[col];
            let _e38 = sum;
            sum = (_e38 + (val * x_val));
        }
        continuing {
            let _e41 = i;
            i = (_e41 + 1u);
        }
    }
    let _e45 = sum;
    y[row] = _e45;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(10): \"cell_face_matrix_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 10,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(11): \"diagonal_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 11,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyCompressible::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_compressible :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"rhs\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"scalar_row_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup3::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup3"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledAssemblyCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var diag_3_: f32 = 0f;
    var rhs_3_: f32 = 0f;
    var diag_4_: f32 = 0f;
    var rhs_4_: f32 = 0f;
    var diag_5_: f32 = 0f;
    var rhs_5_: f32 = 0f;
    var diag_6_: f32 = 0f;
    var rhs_6_: f32 = 0f;
    var diag_7_: f32 = 0f;
    var rhs_7_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;
    var phi_3_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 64u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 8u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 8u) * 2u));
    let start_row_3_ = (start_row_0_ + ((num_neighbors * 8u) * 3u));
    let start_row_4_ = (start_row_0_ + ((num_neighbors * 8u) * 4u));
    let start_row_5_ = (start_row_0_ + ((num_neighbors * 8u) * 5u));
    let start_row_6_ = (start_row_0_ + ((num_neighbors * 8u) * 6u));
    let start_row_7_ = (start_row_0_ + ((num_neighbors * 8u) * 7u));
    loop {
        let _e78 = rank;
        if (_e78 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e80 = rank;
            matrix_values[((start_row_0_ + (_e80 * 8u)) + 0u)] = 0f;
            let _e89 = rank;
            matrix_values[((start_row_0_ + (_e89 * 8u)) + 1u)] = 0f;
            let _e98 = rank;
            matrix_values[((start_row_0_ + (_e98 * 8u)) + 2u)] = 0f;
            let _e107 = rank;
            matrix_values[((start_row_0_ + (_e107 * 8u)) + 3u)] = 0f;
            let _e116 = rank;
            matrix_values[((start_row_0_ + (_e116 * 8u)) + 4u)] = 0f;
            let _e125 = rank;
            matrix_values[((start_row_0_ + (_e125 * 8u)) + 5u)] = 0f;
            let _e134 = rank;
            matrix_values[((start_row_0_ + (_e134 * 8u)) + 6u)] = 0f;
            let _e143 = rank;
            matrix_values[((start_row_0_ + (_e143 * 8u)) + 7u)] = 0f;
            let _e152 = rank;
            matrix_values[((start_row_1_ + (_e152 * 8u)) + 0u)] = 0f;
            let _e161 = rank;
            matrix_values[((start_row_1_ + (_e161 * 8u)) + 1u)] = 0f;
            let _e170 = rank;
            matrix_values[((start_row_1_ + (_e170 * 8u)) + 2u)] = 0f;
            let _e179 = rank;
            matrix_values[((start_row_1_ + (_e179 * 8u)) + 3u)] = 0f;
            let _e188 = rank;
            matrix_values[((start_row_1_ + (_e188 * 8u)) + 4u)] = 0f;
            let _e197 = rank;
            matrix_values[((start_row_1_ + (_e197 * 8u)) + 5u)] = 0f;
            let _e206 = rank;
            matrix_values[((start_row_1_ + (_e206 * 8u)) + 6u)] = 0f;
            let _e215 = rank;
            matrix_values[((start_row_1_ + (_e215 * 8u)) + 7u)] = 0f;
            let _e224 = rank;
            matrix_values[((start_row_2_ + (_e224 * 8u)) + 0u)] = 0f;
            let _e233 = rank;
            matrix_values[((start_row_2_ + (_e233 * 8u)) + 1u)] = 0f;
            let _e242 = rank;
            matrix_values[((start_row_2_ + (_e242 * 8u)) + 2u)] = 0f;
            let _e251 = rank;
            matrix_values[((start_row_2_ + (_e251 * 8u)) + 3u)] = 0f;
            let _e260 = rank;
            matrix_values[((start_row_2_ + (_e260 * 8u)) + 4u)] = 0f;
            let _e269 = rank;
            matrix_values[((start_row_2_ + (_e269 * 8u)) + 5u)] = 0f;
            let _e278 = rank;
            matrix_values[((start_row_2_ + (_e278 * 8u)) + 6u)] = 0f;
            let _e287 = rank;
            matrix_values[((start_row_2_ + (_e287 * 8u)) + 7u)] = 0f;
            let _e296 = rank;
            matrix_values[((start_row_3_ + (_e296 * 8u)) + 0u)] = 0f;
            let _e305 = rank;
            matrix_values[((start_row_3_ + (_e305 * 8u)) + 1u)] = 0f;
            let _e314 = rank;
            matrix_values[((start_row_3_ + (_e314 * 8u)) + 2u)] = 0f;
            let _e323 = rank;
            matrix_values[((start_row_3_ + (_e323 * 8u)) + 3u)] = 0f;
            let _e332 = rank;
            matrix_values[((start_row_3_ + (_e332 * 8u)) + 4u)] = 0f;
            let _e341 = rank;
            matrix_values[((start_row_3_ + (_e341 * 8u)) + 5u)] = 0f;
            let _e350 = rank;
            matrix_values[((start_row_3_ + (_e350 * 8u)) + 6u)] = 0f;
            let _e359 = rank;
            matrix_values[((start_row_3_ + (_e359 * 8u)) + 7u)] = 0f;
            let _e368 = rank;
            matrix_values[((start_row_4_ + (_e368 * 8u)) + 0u)] = 0f;
            let _e377 = rank;
            matrix_values[((start_row_4_ + (_e377 * 8u)) + 1u)] = 0f;
            let _e386 = rank;
            matrix_values[((start_row_4_ + (_e386 * 8u)) + 2u)] = 0f;
            let _e395 = rank;
            matrix_values[((start_row_4_ + (_e395 * 8u)) + 3u)] = 0f;
            let _e404 = rank;
            matrix_values[((start_row_4_ + (_e404 * 8u)) + 4u)] = 0f;
            let _e413 = rank;
            matrix_values[((start_row_4_ + (_e413 * 8u)) + 5u)] = 0f;
            let _e422 = rank;
            matrix_values[((start_row_4_ + (_e422 * 8u)) + 6u)] = 0f;
            let _e431 = rank;
            matrix_values[((start_row_4_ + (_e431 * 8u)) + 7u)] = 0f;
            let _e440 = rank;
            matrix_values[((start_row_5_ + (_e440 * 8u)) + 0u)] = 0f;
            let _e449 = rank;
            matrix_values[((start_row_5_ + (_e449 * 8u)) + 1u)] = 0f;
            let _e458 = rank;
            matrix_values[((start_row_5_ + (_e458 * 8u)) + 2u)] = 0f;
            let _e467 = rank;
            matrix_values[((start_row_5_ + (_e467 * 8u)) + 3u)] = 0f;
            let _e476 = rank;
            matrix_values[((start_row_5_ + (_e476 * 8u)) + 4u)] = 0f;
            let _e485 = rank;
            matrix_values[((start_row_5_ + (_e485 * 8u)) + 5u)] = 0f;
            let _e494 = rank;
            matrix_values[((start_row_5_ + (_e494 * 8u)) + 6u)] = 0f;
            let _e503 = rank;
            matrix_values[((start_row_5_ + (_e503 * 8u)) + 7u)] = 0f;
            let _e512 = rank;
            matrix_values[((start_row_6_ + (_e512 * 8u)) + 0u)] = 0f;
            let _e521 = rank;
            matrix_values[((start_row_6_ + (_e521 * 8u)) + 1u)] = 0f;
            let _e530 = rank;
            matrix_values[((start_row_6_ + (_e530 * 8u)) + 2u)] = 0f;
            let _e539 = rank;
            matrix_values[((start_row_6_ + (_e539 * 8u)) + 3u)] = 0f;
            let _e548 = rank;
            matrix_values[((start_row_6_ + (_e548 * 8u)) + 4u)] = 0f;
            let _e557 = rank;
            matrix_values[((start_row_6_ + (_e557 * 8u)) + 5u)] = 0f;
            let _e566 = rank;
            matrix_values[((start_row_6_ + (_e566 * 8u)) + 6u)] = 0f;
            let _e575 = rank;
            matrix_values[((start_row_6_ + (_e575 * 8u)) + 7u)] = 0f;
            let _e584 = rank;
            matrix_values[((start_row_7_ + (_e584 * 8u)) + 0u)] = 0f;
            let _e593 = rank;
            matrix_values[((start_row_7_ + (_e593 * 8u)) + 1u)] = 0f;
            let _e602 = rank;
            matrix_values[((start_row_7_ + (_e602 * 8u)) + 2u)] = 0f;
            let _e611 = rank;
            matrix_values[((start_row_7_ + (_e611 * 8u)) + 3u)] = 0f;
            let _e620 = rank;
            matrix_values[((start_row_7_ + (_e620 * 8u)) + 4u)] = 0f;
            let _e629 = rank;
            matrix_values[((start_row_7_ + (_e629 * 8u)) + 5u)] = 0f;
            let _e638 = rank;
            matrix_values[((start_row_7_ + (_e638 * 8u)) + 6u)] = 0f;
            let _e647 = rank;
            matrix_values[((start_row_7_ + (_e647 * 8u)) + 7u)] = 0f;
        }
        continuing {
            let _e657 = rank;
            rank = (_e657 + 1u);
        }
    }
    let _e662 = constants.dt;
    let _e664 = diag_0_;
    diag_0_ = (_e664 + (vol / _e662));
    let _e668 = constants.dt;
    let _e677 = state_old[((idx * 22u) + 0u)];
    let _e679 = rhs_0_;
    rhs_0_ = (_e679 + ((vol / _e668) * _e677));
    let _e683 = constants.time_scheme;
    if (_e683 == 1u) {
        let _e688 = constants.dt;
        let _e691 = constants.dt_old;
        let r = (_e688 / _e691);
        let _e695 = constants.dt;
        let diag_bdf2_ = (((vol / _e695) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e711 = diag_0_;
        let _e714 = constants.dt;
        diag_0_ = ((_e711 - (vol / _e714)) + diag_bdf2_);
        let _e718 = rhs_0_;
        let _e721 = constants.dt;
        let _e729 = state_old[((idx * 22u) + 0u)];
        let _e734 = constants.dt;
        let _e742 = state_old[((idx * 22u) + 0u)];
        let _e750 = state_old_old[((idx * 22u) + 0u)];
        rhs_0_ = ((_e718 - ((vol / _e721) * _e729)) + ((vol / _e734) * ((factor_n * _e742) - (factor_nm1_ * _e750))));
    }
    let _e757 = constants.dtau;
    if (_e757 > 0f) {
        let _e762 = constants.dtau;
        let _e764 = diag_0_;
        diag_0_ = (_e764 + (vol / _e762));
        let _e768 = constants.dtau;
        let _e776 = state_iter[((idx * 22u) + 0u)];
        let _e778 = rhs_0_;
        rhs_0_ = (_e778 + ((vol / _e768) * _e776));
    }
    let _e783 = constants.dt;
    let _e785 = diag_1_;
    diag_1_ = (_e785 + (vol / _e783));
    let _e789 = constants.dt;
    let _e798 = state_old[((idx * 22u) + 1u)];
    let _e800 = rhs_1_;
    rhs_1_ = (_e800 + ((vol / _e789) * _e798));
    let _e804 = constants.time_scheme;
    if (_e804 == 1u) {
        let _e809 = constants.dt;
        let _e812 = constants.dt_old;
        let r_1 = (_e809 / _e812);
        let _e816 = constants.dt;
        let diag_bdf2_1 = (((vol / _e816) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e832 = diag_1_;
        let _e835 = constants.dt;
        diag_1_ = ((_e832 - (vol / _e835)) + diag_bdf2_1);
        let _e839 = rhs_1_;
        let _e842 = constants.dt;
        let _e850 = state_old[((idx * 22u) + 1u)];
        let _e855 = constants.dt;
        let _e863 = state_old[((idx * 22u) + 1u)];
        let _e871 = state_old_old[((idx * 22u) + 1u)];
        rhs_1_ = ((_e839 - ((vol / _e842) * _e850)) + ((vol / _e855) * ((factor_n_1 * _e863) - (factor_nm1_1 * _e871))));
    }
    let _e878 = constants.dtau;
    if (_e878 > 0f) {
        let _e883 = constants.dtau;
        let _e885 = diag_1_;
        diag_1_ = (_e885 + (vol / _e883));
        let _e889 = constants.dtau;
        let _e897 = state_iter[((idx * 22u) + 1u)];
        let _e899 = rhs_1_;
        rhs_1_ = (_e899 + ((vol / _e889) * _e897));
    }
    let _e904 = constants.dt;
    let _e906 = diag_2_;
    diag_2_ = (_e906 + (vol / _e904));
    let _e910 = constants.dt;
    let _e919 = state_old[((idx * 22u) + 2u)];
    let _e921 = rhs_2_;
    rhs_2_ = (_e921 + ((vol / _e910) * _e919));
    let _e925 = constants.time_scheme;
    if (_e925 == 1u) {
        let _e930 = constants.dt;
        let _e933 = constants.dt_old;
        let r_2 = (_e930 / _e933);
        let _e937 = constants.dt;
        let diag_bdf2_2 = (((vol / _e937) * ((r_2 * 2f) + 1f)) / (r_2 + 1f));
        let factor_n_2 = (r_2 + 1f);
        let factor_nm1_2 = ((r_2 * r_2) / (r_2 + 1f));
        let _e953 = diag_2_;
        let _e956 = constants.dt;
        diag_2_ = ((_e953 - (vol / _e956)) + diag_bdf2_2);
        let _e960 = rhs_2_;
        let _e963 = constants.dt;
        let _e971 = state_old[((idx * 22u) + 2u)];
        let _e976 = constants.dt;
        let _e984 = state_old[((idx * 22u) + 2u)];
        let _e992 = state_old_old[((idx * 22u) + 2u)];
        rhs_2_ = ((_e960 - ((vol / _e963) * _e971)) + ((vol / _e976) * ((factor_n_2 * _e984) - (factor_nm1_2 * _e992))));
    }
    let _e999 = constants.dtau;
    if (_e999 > 0f) {
        let _e1004 = constants.dtau;
        let _e1006 = diag_2_;
        diag_2_ = (_e1006 + (vol / _e1004));
        let _e1010 = constants.dtau;
        let _e1018 = state_iter[((idx * 22u) + 2u)];
        let _e1020 = rhs_2_;
        rhs_2_ = (_e1020 + ((vol / _e1010) * _e1018));
    }
    let _e1025 = constants.dt;
    let _e1027 = diag_3_;
    diag_3_ = (_e1027 + (vol / _e1025));
    let _e1031 = constants.dt;
    let _e1040 = state_old[((idx * 22u) + 7u)];
    let _e1042 = rhs_3_;
    rhs_3_ = (_e1042 + ((vol / _e1031) * _e1040));
    let _e1046 = constants.time_scheme;
    if (_e1046 == 1u) {
        let _e1051 = constants.dt;
        let _e1054 = constants.dt_old;
        let r_3 = (_e1051 / _e1054);
        let _e1058 = constants.dt;
        let diag_bdf2_3 = (((vol / _e1058) * ((r_3 * 2f) + 1f)) / (r_3 + 1f));
        let factor_n_3 = (r_3 + 1f);
        let factor_nm1_3 = ((r_3 * r_3) / (r_3 + 1f));
        let _e1074 = diag_3_;
        let _e1077 = constants.dt;
        diag_3_ = ((_e1074 - (vol / _e1077)) + diag_bdf2_3);
        let _e1081 = rhs_3_;
        let _e1084 = constants.dt;
        let _e1092 = state_old[((idx * 22u) + 7u)];
        let _e1097 = constants.dt;
        let _e1105 = state_old[((idx * 22u) + 7u)];
        let _e1113 = state_old_old[((idx * 22u) + 7u)];
        rhs_3_ = ((_e1081 - ((vol / _e1084) * _e1092)) + ((vol / _e1097) * ((factor_n_3 * _e1105) - (factor_nm1_3 * _e1113))));
    }
    let _e1120 = constants.dtau;
    if (_e1120 > 0f) {
        let _e1125 = constants.dtau;
        let _e1127 = diag_3_;
        diag_3_ = (_e1127 + (vol / _e1125));
        let _e1131 = constants.dtau;
        let _e1139 = state_iter[((idx * 22u) + 7u)];
        let _e1141 = rhs_3_;
        rhs_3_ = (_e1141 + ((vol / _e1131) * _e1139));
    }
    let _e1149 = state[((idx * 22u) + 0u)];
    let _e1154 = constants.dt;
    let _e1157 = constants.dtau;
    let _e1160 = constants.dtau;
    let _e1168 = diag_4_;
    diag_4_ = (_e1168 - (-(((_e1149 * 1f) / select(_e1154, _e1157, (_e1160 > 0f)))) * vol));
    let _e1176 = state[((idx * 22u) + 0u)];
    let _e1181 = constants.dt;
    let _e1184 = constants.dtau;
    let _e1187 = constants.dtau;
    let _e1195 = diag_5_;
    diag_5_ = (_e1195 - (-(((_e1176 * 1f) / select(_e1181, _e1184, (_e1187 > 0f)))) * vol));
    let _e1206 = constants.dt;
    let _e1209 = constants.dtau;
    let _e1212 = constants.dtau;
    let _e1219 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)] = (_e1219 - ((1f / select(_e1206, _e1209, (_e1212 > 0f))) * vol));
    let _e1230 = constants.dt;
    let _e1233 = constants.dtau;
    let _e1236 = constants.dtau;
    let _e1243 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)] = (_e1243 - ((1f / select(_e1230, _e1233, (_e1236 > 0f))) * vol));
    let _e1247 = constants.dt;
    let _e1250 = constants.dtau;
    let _e1253 = constants.dtau;
    let _e1261 = diag_6_;
    diag_6_ = (_e1261 - ((1f / select(_e1247, _e1250, (_e1253 > 0f))) * vol));
    let _e1272 = constants.eos_gm1_;
    let _e1278 = constants.dt;
    let _e1281 = constants.dtau;
    let _e1284 = constants.dtau;
    let _e1290 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)] = (_e1290 - (((-(_e1272) * 1f) / select(_e1278, _e1281, (_e1284 > 0f))) * vol));
    let _e1301 = constants.eos_gm1_;
    let _e1308 = constants.dt;
    let _e1311 = constants.dtau;
    let _e1314 = constants.dtau;
    let _e1325 = state[((idx * 22u) + 10u)];
    let _e1332 = state[((idx * 22u) + 11u)];
    let _e1340 = state[((idx * 22u) + 10u)];
    let _e1347 = state[((idx * 22u) + 11u)];
    let _e1352 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1352 - (((((0.5f * _e1301) * 1f) / select(_e1308, _e1311, (_e1314 > 0f))) * dot(vec2<f32>(_e1325, _e1332), vec2<f32>(_e1340, _e1347))) * vol));
    let _e1363 = constants.eos_dp_drho;
    let _e1369 = constants.dt;
    let _e1372 = constants.dtau;
    let _e1375 = constants.dtau;
    let _e1381 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1381 - (((-(_e1363) * 1f) / select(_e1369, _e1372, (_e1375 > 0f))) * vol));
    let _e1385 = constants.eos_p_offset;
    let _e1391 = constants.dt;
    let _e1394 = constants.dtau;
    let _e1397 = constants.dtau;
    let _e1404 = rhs_6_;
    rhs_6_ = (_e1404 + (((-(_e1385) * 1f) / select(_e1391, _e1394, (_e1397 > 0f))) * vol));
    let _e1412 = state[((idx * 22u) + 0u)];
    let _e1415 = constants.eos_r;
    let _e1421 = constants.dt;
    let _e1424 = constants.dtau;
    let _e1427 = constants.dtau;
    let _e1434 = diag_7_;
    diag_7_ = (_e1434 - ((((_e1412 * _e1415) * 1f) / select(_e1421, _e1424, (_e1427 > 0f))) * vol));
    let _e1445 = constants.dt;
    let _e1448 = constants.dtau;
    let _e1451 = constants.dtau;
    let _e1459 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)] = (_e1459 - (-((1f / select(_e1445, _e1448, (_e1451 > 0f)))) * vol));
    k = start;
    loop {
        let _e1462 = k;
        if (_e1462 < end) {
        } else {
            break;
        }
        {
            let _e1465 = k;
            let face_idx = cell_faces[_e1465];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e1485 = face_normals[face_idx];
            normal = _e1485;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e1493 = normal.x;
                normal.x = -(_e1493);
                let _e1497 = normal.y;
                normal.y = -(_e1497);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e1504 = other_idx;
                let _e1506 = cell_centers[_e1504];
                other_center = _e1506;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e1510 = other_center.x;
            let dx = (_e1510 - center.x);
            let _e1514 = other_center.y;
            let dy = (_e1514 - center.y);
            let _e1518 = normal.x;
            let _e1521 = normal.y;
            let dist_proj = abs(((dx * _e1518) + (dy * _e1521)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e1535 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e1535];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e1545 = fluxes[((face_idx * 8u) + 0u)];
            phi_0_ = _e1545;
            if (owner != idx) {
                let _e1548 = phi_0_;
                let _e1551 = phi_0_;
                phi_0_ = (_e1551 - (_e1548 * 2f));
            }
            let _e1553 = phi_0_;
            let _e1554 = rhs_0_;
            rhs_0_ = (_e1554 - _e1553);
            let _e1558 = constants.viscosity;
            let _e1561 = constants.viscosity;
            let _e1564 = constants.viscosity;
            let _e1568 = is_boundary;
            let _e1572 = dist;
            let diff_coeff_rho_u = ((select(_e1558, ((_e1561 + _e1564) * 0.5f), !(_e1568)) * area) / _e1572);
            let _e1574 = is_boundary;
            if !(_e1574) {
                let _e1583 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1583 + diff_coeff_rho_u);
                let _e1592 = matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)] = (_e1592 - diff_coeff_rho_u);
            } else {
                if (boundary_type == 4u) {
                    let _e1603 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1603 + diff_coeff_rho_u);
                    let _e1611 = state[((idx * 22u) + 10u)];
                    let _e1618 = state[((idx * 22u) + 10u)];
                    let _e1620 = normal.x;
                    let _e1628 = state[((idx * 22u) + 11u)];
                    let _e1630 = normal.y;
                    let _e1634 = normal.x;
                    let _e1638 = rhs_1_;
                    rhs_1_ = (_e1638 + (diff_coeff_rho_u * (_e1611 - (((_e1618 * _e1620) + (_e1628 * _e1630)) * _e1634))));
                } else {
                    let _e1646 = bc_kind[((face_idx * 8u) + 4u)];
                    if (_e1646 == 1u) {
                        let _e1656 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                        matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1656 + diff_coeff_rho_u);
                        let _e1664 = bc_value[((face_idx * 8u) + 4u)];
                        let _e1666 = rhs_1_;
                        rhs_1_ = (_e1666 + (diff_coeff_rho_u * _e1664));
                    } else {
                        let _e1674 = bc_kind[((face_idx * 8u) + 4u)];
                        if (_e1674 == 2u) {
                            let _e1679 = constants.viscosity;
                            let _e1682 = constants.viscosity;
                            let _e1685 = constants.viscosity;
                            let _e1689 = is_boundary;
                            let _e1699 = bc_value[((face_idx * 8u) + 4u)];
                            let _e1702 = rhs_1_;
                            rhs_1_ = (_e1702 + -(((select(_e1679, ((_e1682 + _e1685) * 0.5f), !(_e1689)) * area) * _e1699)));
                        }
                    }
                }
            }
            let _e1704 = is_boundary;
            if !(_e1704) {
                let _e1713 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1713 + diff_coeff_rho_u);
                let _e1722 = matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)] = (_e1722 - diff_coeff_rho_u);
            } else {
                if (boundary_type == 4u) {
                    let _e1733 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1733 + diff_coeff_rho_u);
                    let _e1741 = state[((idx * 22u) + 11u)];
                    let _e1748 = state[((idx * 22u) + 10u)];
                    let _e1750 = normal.x;
                    let _e1758 = state[((idx * 22u) + 11u)];
                    let _e1760 = normal.y;
                    let _e1764 = normal.y;
                    let _e1768 = rhs_2_;
                    rhs_2_ = (_e1768 + (diff_coeff_rho_u * (_e1741 - (((_e1748 * _e1750) + (_e1758 * _e1760)) * _e1764))));
                } else {
                    let _e1776 = bc_kind[((face_idx * 8u) + 5u)];
                    if (_e1776 == 1u) {
                        let _e1786 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                        matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1786 + diff_coeff_rho_u);
                        let _e1794 = bc_value[((face_idx * 8u) + 5u)];
                        let _e1796 = rhs_2_;
                        rhs_2_ = (_e1796 + (diff_coeff_rho_u * _e1794));
                    } else {
                        let _e1804 = bc_kind[((face_idx * 8u) + 5u)];
                        if (_e1804 == 2u) {
                            let _e1809 = constants.viscosity;
                            let _e1812 = constants.viscosity;
                            let _e1815 = constants.viscosity;
                            let _e1819 = is_boundary;
                            let _e1829 = bc_value[((face_idx * 8u) + 5u)];
                            let _e1832 = rhs_2_;
                            rhs_2_ = (_e1832 + -(((select(_e1809, ((_e1812 + _e1815) * 0.5f), !(_e1819)) * area) * _e1829)));
                        }
                    }
                }
            }
            let _e1840 = fluxes[((face_idx * 8u) + 1u)];
            phi_1_ = _e1840;
            if (owner != idx) {
                let _e1843 = phi_1_;
                let _e1846 = phi_1_;
                phi_1_ = (_e1846 - (_e1843 * 2f));
            }
            let _e1848 = phi_1_;
            let _e1849 = rhs_1_;
            rhs_1_ = (_e1849 - _e1848);
            let _e1857 = fluxes[((face_idx * 8u) + 2u)];
            phi_2_ = _e1857;
            if (owner != idx) {
                let _e1860 = phi_2_;
                let _e1863 = phi_2_;
                phi_2_ = (_e1863 - (_e1860 * 2f));
            }
            let _e1865 = phi_2_;
            let _e1866 = rhs_2_;
            rhs_2_ = (_e1866 - _e1865);
            let _e1870 = constants.viscosity;
            let _e1873 = constants.eos_gamma;
            let _e1877 = constants.eos_r;
            let _e1881 = constants.eos_gm1_;
            let _e1889 = constants.viscosity;
            let _e1892 = constants.eos_gamma;
            let _e1896 = constants.eos_r;
            let _e1900 = constants.eos_gm1_;
            let _e1908 = constants.viscosity;
            let _e1911 = constants.eos_gamma;
            let _e1915 = constants.eos_r;
            let _e1919 = constants.eos_gm1_;
            let _e1928 = is_boundary;
            let _e1932 = dist;
            let diff_coeff_rho_e = ((select(((((_e1870 * _e1873) * _e1877) / max(_e1881, 0.000000000001f)) / 0.71f), ((((((_e1889 * _e1892) * _e1896) / max(_e1900, 0.000000000001f)) / 0.71f) + ((((_e1908 * _e1911) * _e1915) / max(_e1919, 0.000000000001f)) / 0.71f)) * 0.5f), !(_e1928)) * area) / _e1932);
            let _e1934 = is_boundary;
            if !(_e1934) {
                let _e1943 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 7u)];
                matrix_values[((start_row_3_ + (diag_rank * 8u)) + 7u)] = (_e1943 + diff_coeff_rho_e);
                let _e1952 = matrix_values[((start_row_3_ + (neighbor_rank * 8u)) + 7u)];
                matrix_values[((start_row_3_ + (neighbor_rank * 8u)) + 7u)] = (_e1952 - diff_coeff_rho_e);
            } else {
                let _e1960 = bc_kind[((face_idx * 8u) + 7u)];
                if (_e1960 == 1u) {
                    let _e1970 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 7u)];
                    matrix_values[((start_row_3_ + (diag_rank * 8u)) + 7u)] = (_e1970 + diff_coeff_rho_e);
                    let _e1978 = bc_value[((face_idx * 8u) + 7u)];
                    let _e1980 = rhs_3_;
                    rhs_3_ = (_e1980 + (diff_coeff_rho_e * _e1978));
                } else {
                    let _e1988 = bc_kind[((face_idx * 8u) + 7u)];
                    if (_e1988 == 2u) {
                        let _e1993 = constants.viscosity;
                        let _e1996 = constants.eos_gamma;
                        let _e2000 = constants.eos_r;
                        let _e2004 = constants.eos_gm1_;
                        let _e2012 = constants.viscosity;
                        let _e2015 = constants.eos_gamma;
                        let _e2019 = constants.eos_r;
                        let _e2023 = constants.eos_gm1_;
                        let _e2031 = constants.viscosity;
                        let _e2034 = constants.eos_gamma;
                        let _e2038 = constants.eos_r;
                        let _e2042 = constants.eos_gm1_;
                        let _e2051 = is_boundary;
                        let _e2061 = bc_value[((face_idx * 8u) + 7u)];
                        let _e2064 = rhs_3_;
                        rhs_3_ = (_e2064 + -(((select(((((_e1993 * _e1996) * _e2000) / max(_e2004, 0.000000000001f)) / 0.71f), ((((((_e2012 * _e2015) * _e2019) / max(_e2023, 0.000000000001f)) / 0.71f) + ((((_e2031 * _e2034) * _e2038) / max(_e2042, 0.000000000001f)) / 0.71f)) * 0.5f), !(_e2051)) * area) * _e2061)));
                    }
                }
            }
            let _e2072 = fluxes[((face_idx * 8u) + 3u)];
            phi_3_ = _e2072;
            if (owner != idx) {
                let _e2075 = phi_3_;
                let _e2078 = phi_3_;
                phi_3_ = (_e2078 - (_e2075 * 2f));
            }
            let _e2080 = phi_3_;
            let _e2081 = rhs_3_;
            rhs_3_ = (_e2081 - _e2080);
        }
        continuing {
            let _e2084 = k;
            k = (_e2084 + 1u);
        }
    }
    let _e2093 = diag_0_;
    let _e2094 = matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)] = (_e2094 + _e2093);
    let _e2102 = rhs_0_;
    rhs[((idx * 8u) + 0u)] = _e2102;
    let _e2110 = diag_1_;
    let _e2111 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)] = (_e2111 + _e2110);
    let _e2119 = rhs_1_;
    rhs[((idx * 8u) + 1u)] = _e2119;
    let _e2127 = diag_2_;
    let _e2128 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)] = (_e2128 + _e2127);
    let _e2136 = rhs_2_;
    rhs[((idx * 8u) + 2u)] = _e2136;
    let _e2144 = diag_3_;
    let _e2145 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)] = (_e2145 + _e2144);
    let _e2153 = rhs_3_;
    rhs[((idx * 8u) + 3u)] = _e2153;
    let _e2161 = diag_4_;
    let _e2162 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)] = (_e2162 + _e2161);
    let _e2171 = rhs_4_;
    rhs[((idx * 8u) + 4u)] = _e2171;
    let _e2179 = diag_5_;
    let _e2180 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)] = (_e2180 + _e2179);
    let _e2189 = rhs_5_;
    rhs[((idx * 8u) + 5u)] = _e2189;
    let _e2197 = diag_6_;
    let _e2198 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)] = (_e2198 + _e2197);
    let _e2206 = rhs_6_;
    rhs[((idx * 8u) + 6u)] = _e2206;
    let _e2214 = diag_7_;
    let _e2215 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)] = (_e2215 + _e2214);
    let _e2224 = rhs_7_;
    rhs[((idx * 8u) + 7u)] = _e2224;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_generic_diffusion_demo :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup3"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = is_boundary;
            let _e262 = dist;
            let diff_coeff_phi = ((select(1f, 1f, !(_e256)) * area) / _e262);
            let _e264 = is_boundary;
            if !(_e264) {
                let _e266 = diag_0_;
                diag_0_ = (_e266 + diff_coeff_phi);
                let _e275 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e275 - diff_coeff_phi);
            } else {
                let _e283 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e283 == 1u) {
                    let _e286 = diag_0_;
                    diag_0_ = (_e286 + diff_coeff_phi);
                    let _e294 = bc_value[((face_idx * 1u) + 0u)];
                    let _e296 = rhs_0_;
                    rhs_0_ = (_e296 + (diff_coeff_phi * _e294));
                } else {
                    let _e304 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e304 == 2u) {
                        let _e307 = is_boundary;
                        let _e319 = bc_value[((face_idx * 1u) + 0u)];
                        let _e322 = rhs_0_;
                        rhs_0_ = (_e322 + -(((select(1f, 1f, !(_e307)) * area) * _e319)));
                    }
                }
            }
        }
        continuing {
            let _e325 = k;
            k = (_e325 + 1u);
        }
    }
    let _e334 = diag_0_;
    let _e335 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e335 + _e334);
    let _e343 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e343;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_generic_diffusion_demo_neumann.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = is_boundary;
            let _e262 = dist;
            let diff_coeff_phi = ((select(1f, 1f, !(_e256)) * area) / _e262);
            let _e264 = is_boundary;
            if !(_e264) {
                let _e266 = diag_0_;
                diag_0_ = (_e266 + diff_coeff_phi);
                let _e275 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e275 - diff_coeff_phi);
            } else {
                let _e283 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e283 == 1u) {
                    let _e286 = diag_0_;
                    diag_0_ = (_e286 + diff_coeff_phi);
                    let _e294 = bc_value[((face_idx * 1u) + 0u)];
                    let _e296 = rhs_0_;
                    rhs_0_ = (_e296 + (diff_coeff_phi * _e294));
                } else {
                    let _e304 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e304 == 2u) {
                        let _e307 = is_boundary;
                        let _e319 = bc_value[((face_idx * 1u) + 0u)];
                        let _e322 = rhs_0_;
                        rhs_0_ = (_e322 + -(((select(1f, 1f, !(_e307)) * area) * _e319)));
                    }
                }
            }
        }
        continuing {
            let _e325 = k;
            k = (_e325 + 1u);
        }
    }
    let _e334 = diag_0_;
    let _e335 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e335 + _e334);
    let _e343 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e343;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_compressible :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup3"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_grad_state_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var diag_3_: f32 = 0f;
    var rhs_3_: f32 = 0f;
    var diag_4_: f32 = 0f;
    var rhs_4_: f32 = 0f;
    var diag_5_: f32 = 0f;
    var rhs_5_: f32 = 0f;
    var diag_6_: f32 = 0f;
    var rhs_6_: f32 = 0f;
    var diag_7_: f32 = 0f;
    var rhs_7_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;
    var phi_3_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 64u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 8u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 8u) * 2u));
    let start_row_3_ = (start_row_0_ + ((num_neighbors * 8u) * 3u));
    let start_row_4_ = (start_row_0_ + ((num_neighbors * 8u) * 4u));
    let start_row_5_ = (start_row_0_ + ((num_neighbors * 8u) * 5u));
    let start_row_6_ = (start_row_0_ + ((num_neighbors * 8u) * 6u));
    let start_row_7_ = (start_row_0_ + ((num_neighbors * 8u) * 7u));
    loop {
        let _e78 = rank;
        if (_e78 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e80 = rank;
            matrix_values[((start_row_0_ + (_e80 * 8u)) + 0u)] = 0f;
            let _e89 = rank;
            matrix_values[((start_row_0_ + (_e89 * 8u)) + 1u)] = 0f;
            let _e98 = rank;
            matrix_values[((start_row_0_ + (_e98 * 8u)) + 2u)] = 0f;
            let _e107 = rank;
            matrix_values[((start_row_0_ + (_e107 * 8u)) + 3u)] = 0f;
            let _e116 = rank;
            matrix_values[((start_row_0_ + (_e116 * 8u)) + 4u)] = 0f;
            let _e125 = rank;
            matrix_values[((start_row_0_ + (_e125 * 8u)) + 5u)] = 0f;
            let _e134 = rank;
            matrix_values[((start_row_0_ + (_e134 * 8u)) + 6u)] = 0f;
            let _e143 = rank;
            matrix_values[((start_row_0_ + (_e143 * 8u)) + 7u)] = 0f;
            let _e152 = rank;
            matrix_values[((start_row_1_ + (_e152 * 8u)) + 0u)] = 0f;
            let _e161 = rank;
            matrix_values[((start_row_1_ + (_e161 * 8u)) + 1u)] = 0f;
            let _e170 = rank;
            matrix_values[((start_row_1_ + (_e170 * 8u)) + 2u)] = 0f;
            let _e179 = rank;
            matrix_values[((start_row_1_ + (_e179 * 8u)) + 3u)] = 0f;
            let _e188 = rank;
            matrix_values[((start_row_1_ + (_e188 * 8u)) + 4u)] = 0f;
            let _e197 = rank;
            matrix_values[((start_row_1_ + (_e197 * 8u)) + 5u)] = 0f;
            let _e206 = rank;
            matrix_values[((start_row_1_ + (_e206 * 8u)) + 6u)] = 0f;
            let _e215 = rank;
            matrix_values[((start_row_1_ + (_e215 * 8u)) + 7u)] = 0f;
            let _e224 = rank;
            matrix_values[((start_row_2_ + (_e224 * 8u)) + 0u)] = 0f;
            let _e233 = rank;
            matrix_values[((start_row_2_ + (_e233 * 8u)) + 1u)] = 0f;
            let _e242 = rank;
            matrix_values[((start_row_2_ + (_e242 * 8u)) + 2u)] = 0f;
            let _e251 = rank;
            matrix_values[((start_row_2_ + (_e251 * 8u)) + 3u)] = 0f;
            let _e260 = rank;
            matrix_values[((start_row_2_ + (_e260 * 8u)) + 4u)] = 0f;
            let _e269 = rank;
            matrix_values[((start_row_2_ + (_e269 * 8u)) + 5u)] = 0f;
            let _e278 = rank;
            matrix_values[((start_row_2_ + (_e278 * 8u)) + 6u)] = 0f;
            let _e287 = rank;
            matrix_values[((start_row_2_ + (_e287 * 8u)) + 7u)] = 0f;
            let _e296 = rank;
            matrix_values[((start_row_3_ + (_e296 * 8u)) + 0u)] = 0f;
            let _e305 = rank;
            matrix_values[((start_row_3_ + (_e305 * 8u)) + 1u)] = 0f;
            let _e314 = rank;
            matrix_values[((start_row_3_ + (_e314 * 8u)) + 2u)] = 0f;
            let _e323 = rank;
            matrix_values[((start_row_3_ + (_e323 * 8u)) + 3u)] = 0f;
            let _e332 = rank;
            matrix_values[((start_row_3_ + (_e332 * 8u)) + 4u)] = 0f;
            let _e341 = rank;
            matrix_values[((start_row_3_ + (_e341 * 8u)) + 5u)] = 0f;
            let _e350 = rank;
            matrix_values[((start_row_3_ + (_e350 * 8u)) + 6u)] = 0f;
            let _e359 = rank;
            matrix_values[((start_row_3_ + (_e359 * 8u)) + 7u)] = 0f;
            let _e368 = rank;
            matrix_values[((start_row_4_ + (_e368 * 8u)) + 0u)] = 0f;
            let _e377 = rank;
            matrix_values[((start_row_4_ + (_e377 * 8u)) + 1u)] = 0f;
            let _e386 = rank;
            matrix_values[((start_row_4_ + (_e386 * 8u)) + 2u)] = 0f;
            let _e395 = rank;
            matrix_values[((start_row_4_ + (_e395 * 8u)) + 3u)] = 0f;
            let _e404 = rank;
            matrix_values[((start_row_4_ + (_e404 * 8u)) + 4u)] = 0f;
            let _e413 = rank;
            matrix_values[((start_row_4_ + (_e413 * 8u)) + 5u)] = 0f;
            let _e422 = rank;
            matrix_values[((start_row_4_ + (_e422 * 8u)) + 6u)] = 0f;
            let _e431 = rank;
            matrix_values[((start_row_4_ + (_e431 * 8u)) + 7u)] = 0f;
            let _e440 = rank;
            matrix_values[((start_row_5_ + (_e440 * 8u)) + 0u)] = 0f;
            let _e449 = rank;
            matrix_values[((start_row_5_ + (_e449 * 8u)) + 1u)] = 0f;
            let _e458 = rank;
            matrix_values[((start_row_5_ + (_e458 * 8u)) + 2u)] = 0f;
            let _e467 = rank;
            matrix_values[((start_row_5_ + (_e467 * 8u)) + 3u)] = 0f;
            let _e476 = rank;
            matrix_values[((start_row_5_ + (_e476 * 8u)) + 4u)] = 0f;
            let _e485 = rank;
            matrix_values[((start_row_5_ + (_e485 * 8u)) + 5u)] = 0f;
            let _e494 = rank;
            matrix_values[((start_row_5_ + (_e494 * 8u)) + 6u)] = 0f;
            let _e503 = rank;
            matrix_values[((start_row_5_ + (_e503 * 8u)) + 7u)] = 0f;
            let _e512 = rank;
            matrix_values[((start_row_6_ + (_e512 * 8u)) + 0u)] = 0f;
            let _e521 = rank;
            matrix_values[((start_row_6_ + (_e521 * 8u)) + 1u)] = 0f;
            let _e530 = rank;
            matrix_values[((start_row_6_ + (_e530 * 8u)) + 2u)] = 0f;
            let _e539 = rank;
            matrix_values[((start_row_6_ + (_e539 * 8u)) + 3u)] = 0f;
            let _e548 = rank;
            matrix_values[((start_row_6_ + (_e548 * 8u)) + 4u)] = 0f;
            let _e557 = rank;
            matrix_values[((start_row_6_ + (_e557 * 8u)) + 5u)] = 0f;
            let _e566 = rank;
            matrix_values[((start_row_6_ + (_e566 * 8u)) + 6u)] = 0f;
            let _e575 = rank;
            matrix_values[((start_row_6_ + (_e575 * 8u)) + 7u)] = 0f;
            let _e584 = rank;
            matrix_values[((start_row_7_ + (_e584 * 8u)) + 0u)] = 0f;
            let _e593 = rank;
            matrix_values[((start_row_7_ + (_e593 * 8u)) + 1u)] = 0f;
            let _e602 = rank;
            matrix_values[((start_row_7_ + (_e602 * 8u)) + 2u)] = 0f;
            let _e611 = rank;
            matrix_values[((start_row_7_ + (_e611 * 8u)) + 3u)] = 0f;
            let _e620 = rank;
            matrix_values[((start_row_7_ + (_e620 * 8u)) + 4u)] = 0f;
            let _e629 = rank;
            matrix_values[((start_row_7_ + (_e629 * 8u)) + 5u)] = 0f;
            let _e638 = rank;
            matrix_values[((start_row_7_ + (_e638 * 8u)) + 6u)] = 0f;
            let _e647 = rank;
            matrix_values[((start_row_7_ + (_e647 * 8u)) + 7u)] = 0f;
        }
        continuing {
            let _e657 = rank;
            rank = (_e657 + 1u);
        }
    }
    let _e662 = constants.dt;
    let _e664 = diag_0_;
    diag_0_ = (_e664 + (vol / _e662));
    let _e668 = constants.dt;
    let _e677 = state_old[((idx * 22u) + 0u)];
    let _e679 = rhs_0_;
    rhs_0_ = (_e679 + ((vol / _e668) * _e677));
    let _e683 = constants.time_scheme;
    if (_e683 == 1u) {
        let _e688 = constants.dt;
        let _e691 = constants.dt_old;
        let r = (_e688 / _e691);
        let _e695 = constants.dt;
        let diag_bdf2_ = (((vol / _e695) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e711 = diag_0_;
        let _e714 = constants.dt;
        diag_0_ = ((_e711 - (vol / _e714)) + diag_bdf2_);
        let _e718 = rhs_0_;
        let _e721 = constants.dt;
        let _e729 = state_old[((idx * 22u) + 0u)];
        let _e734 = constants.dt;
        let _e742 = state_old[((idx * 22u) + 0u)];
        let _e750 = state_old_old[((idx * 22u) + 0u)];
        rhs_0_ = ((_e718 - ((vol / _e721) * _e729)) + ((vol / _e734) * ((factor_n * _e742) - (factor_nm1_ * _e750))));
    }
    let _e757 = constants.dtau;
    if (_e757 > 0f) {
        let _e762 = constants.dtau;
        let _e764 = diag_0_;
        diag_0_ = (_e764 + (vol / _e762));
        let _e768 = constants.dtau;
        let _e776 = state_iter[((idx * 22u) + 0u)];
        let _e778 = rhs_0_;
        rhs_0_ = (_e778 + ((vol / _e768) * _e776));
    }
    let _e783 = constants.dt;
    let _e785 = diag_1_;
    diag_1_ = (_e785 + (vol / _e783));
    let _e789 = constants.dt;
    let _e798 = state_old[((idx * 22u) + 1u)];
    let _e800 = rhs_1_;
    rhs_1_ = (_e800 + ((vol / _e789) * _e798));
    let _e804 = constants.time_scheme;
    if (_e804 == 1u) {
        let _e809 = constants.dt;
        let _e812 = constants.dt_old;
        let r_1 = (_e809 / _e812);
        let _e816 = constants.dt;
        let diag_bdf2_1 = (((vol / _e816) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e832 = diag_1_;
        let _e835 = constants.dt;
        diag_1_ = ((_e832 - (vol / _e835)) + diag_bdf2_1);
        let _e839 = rhs_1_;
        let _e842 = constants.dt;
        let _e850 = state_old[((idx * 22u) + 1u)];
        let _e855 = constants.dt;
        let _e863 = state_old[((idx * 22u) + 1u)];
        let _e871 = state_old_old[((idx * 22u) + 1u)];
        rhs_1_ = ((_e839 - ((vol / _e842) * _e850)) + ((vol / _e855) * ((factor_n_1 * _e863) - (factor_nm1_1 * _e871))));
    }
    let _e878 = constants.dtau;
    if (_e878 > 0f) {
        let _e883 = constants.dtau;
        let _e885 = diag_1_;
        diag_1_ = (_e885 + (vol / _e883));
        let _e889 = constants.dtau;
        let _e897 = state_iter[((idx * 22u) + 1u)];
        let _e899 = rhs_1_;
        rhs_1_ = (_e899 + ((vol / _e889) * _e897));
    }
    let _e904 = constants.dt;
    let _e906 = diag_2_;
    diag_2_ = (_e906 + (vol / _e904));
    let _e910 = constants.dt;
    let _e919 = state_old[((idx * 22u) + 2u)];
    let _e921 = rhs_2_;
    rhs_2_ = (_e921 + ((vol / _e910) * _e919));
    let _e925 = constants.time_scheme;
    if (_e925 == 1u) {
        let _e930 = constants.dt;
        let _e933 = constants.dt_old;
        let r_2 = (_e930 / _e933);
        let _e937 = constants.dt;
        let diag_bdf2_2 = (((vol / _e937) * ((r_2 * 2f) + 1f)) / (r_2 + 1f));
        let factor_n_2 = (r_2 + 1f);
        let factor_nm1_2 = ((r_2 * r_2) / (r_2 + 1f));
        let _e953 = diag_2_;
        let _e956 = constants.dt;
        diag_2_ = ((_e953 - (vol / _e956)) + diag_bdf2_2);
        let _e960 = rhs_2_;
        let _e963 = constants.dt;
        let _e971 = state_old[((idx * 22u) + 2u)];
        let _e976 = constants.dt;
        let _e984 = state_old[((idx * 22u) + 2u)];
        let _e992 = state_old_old[((idx * 22u) + 2u)];
        rhs_2_ = ((_e960 - ((vol / _e963) * _e971)) + ((vol / _e976) * ((factor_n_2 * _e984) - (factor_nm1_2 * _e992))));
    }
    let _e999 = constants.dtau;
    if (_e999 > 0f) {
        let _e1004 = constants.dtau;
        let _e1006 = diag_2_;
        diag_2_ = (_e1006 + (vol / _e1004));
        let _e1010 = constants.dtau;
        let _e1018 = state_iter[((idx * 22u) + 2u)];
        let _e1020 = rhs_2_;
        rhs_2_ = (_e1020 + ((vol / _e1010) * _e1018));
    }
    let _e1025 = constants.dt;
    let _e1027 = diag_3_;
    diag_3_ = (_e1027 + (vol / _e1025));
    let _e1031 = constants.dt;
    let _e1040 = state_old[((idx * 22u) + 7u)];
    let _e1042 = rhs_3_;
    rhs_3_ = (_e1042 + ((vol / _e1031) * _e1040));
    let _e1046 = constants.time_scheme;
    if (_e1046 == 1u) {
        let _e1051 = constants.dt;
        let _e1054 = constants.dt_old;
        let r_3 = (_e1051 / _e1054);
        let _e1058 = constants.dt;
        let diag_bdf2_3 = (((vol / _e1058) * ((r_3 * 2f) + 1f)) / (r_3 + 1f));
        let factor_n_3 = (r_3 + 1f);
        let factor_nm1_3 = ((r_3 * r_3) / (r_3 + 1f));
        let _e1074 = diag_3_;
        let _e1077 = constants.dt;
        diag_3_ = ((_e1074 - (vol / _e1077)) + diag_bdf2_3);
        let _e1081 = rhs_3_;
        let _e1084 = constants.dt;
        let _e1092 = state_old[((idx * 22u) + 7u)];
        let _e1097 = constants.dt;
        let _e1105 = state_old[((idx * 22u) + 7u)];
        let _e1113 = state_old_old[((idx * 22u) + 7u)];
        rhs_3_ = ((_e1081 - ((vol / _e1084) * _e1092)) + ((vol / _e1097) * ((factor_n_3 * _e1105) - (factor_nm1_3 * _e1113))));
    }
    let _e1120 = constants.dtau;
    if (_e1120 > 0f) {
        let _e1125 = constants.dtau;
        let _e1127 = diag_3_;
        diag_3_ = (_e1127 + (vol / _e1125));
        let _e1131 = constants.dtau;
        let _e1139 = state_iter[((idx * 22u) + 7u)];
        let _e1141 = rhs_3_;
        rhs_3_ = (_e1141 + ((vol / _e1131) * _e1139));
    }
    let _e1149 = state[((idx * 22u) + 0u)];
    let _e1154 = constants.dt;
    let _e1157 = constants.dtau;
    let _e1160 = constants.dtau;
    let _e1168 = diag_4_;
    diag_4_ = (_e1168 - (-(((_e1149 * 1f) / select(_e1154, _e1157, (_e1160 > 0f)))) * vol));
    let _e1176 = state[((idx * 22u) + 0u)];
    let _e1181 = constants.dt;
    let _e1184 = constants.dtau;
    let _e1187 = constants.dtau;
    let _e1195 = diag_5_;
    diag_5_ = (_e1195 - (-(((_e1176 * 1f) / select(_e1181, _e1184, (_e1187 > 0f)))) * vol));
    let _e1206 = constants.dt;
    let _e1209 = constants.dtau;
    let _e1212 = constants.dtau;
    let _e1219 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)] = (_e1219 - ((1f / select(_e1206, _e1209, (_e1212 > 0f))) * vol));
    let _e1230 = constants.dt;
    let _e1233 = constants.dtau;
    let _e1236 = constants.dtau;
    let _e1243 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)] = (_e1243 - ((1f / select(_e1230, _e1233, (_e1236 > 0f))) * vol));
    let _e1247 = constants.dt;
    let _e1250 = constants.dtau;
    let _e1253 = constants.dtau;
    let _e1261 = diag_6_;
    diag_6_ = (_e1261 - ((1f / select(_e1247, _e1250, (_e1253 > 0f))) * vol));
    let _e1272 = constants.eos_gm1_;
    let _e1278 = constants.dt;
    let _e1281 = constants.dtau;
    let _e1284 = constants.dtau;
    let _e1290 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)] = (_e1290 - (((-(_e1272) * 1f) / select(_e1278, _e1281, (_e1284 > 0f))) * vol));
    let _e1301 = constants.eos_gm1_;
    let _e1308 = constants.dt;
    let _e1311 = constants.dtau;
    let _e1314 = constants.dtau;
    let _e1325 = state[((idx * 22u) + 10u)];
    let _e1332 = state[((idx * 22u) + 11u)];
    let _e1340 = state[((idx * 22u) + 10u)];
    let _e1347 = state[((idx * 22u) + 11u)];
    let _e1352 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1352 - (((((0.5f * _e1301) * 1f) / select(_e1308, _e1311, (_e1314 > 0f))) * dot(vec2<f32>(_e1325, _e1332), vec2<f32>(_e1340, _e1347))) * vol));
    let _e1363 = constants.eos_dp_drho;
    let _e1369 = constants.dt;
    let _e1372 = constants.dtau;
    let _e1375 = constants.dtau;
    let _e1381 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1381 - (((-(_e1363) * 1f) / select(_e1369, _e1372, (_e1375 > 0f))) * vol));
    let _e1385 = constants.eos_p_offset;
    let _e1391 = constants.dt;
    let _e1394 = constants.dtau;
    let _e1397 = constants.dtau;
    let _e1404 = rhs_6_;
    rhs_6_ = (_e1404 + (((-(_e1385) * 1f) / select(_e1391, _e1394, (_e1397 > 0f))) * vol));
    let _e1412 = state[((idx * 22u) + 0u)];
    let _e1415 = constants.eos_r;
    let _e1421 = constants.dt;
    let _e1424 = constants.dtau;
    let _e1427 = constants.dtau;
    let _e1434 = diag_7_;
    diag_7_ = (_e1434 - ((((_e1412 * _e1415) * 1f) / select(_e1421, _e1424, (_e1427 > 0f))) * vol));
    let _e1445 = constants.dt;
    let _e1448 = constants.dtau;
    let _e1451 = constants.dtau;
    let _e1459 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)] = (_e1459 - (-((1f / select(_e1445, _e1448, (_e1451 > 0f)))) * vol));
    k = start;
    loop {
        let _e1462 = k;
        if (_e1462 < end) {
        } else {
            break;
        }
        {
            let _e1465 = k;
            let face_idx = cell_faces[_e1465];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e1485 = face_normals[face_idx];
            normal = _e1485;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e1493 = normal.x;
                normal.x = -(_e1493);
                let _e1497 = normal.y;
                normal.y = -(_e1497);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e1504 = other_idx;
                let _e1506 = cell_centers[_e1504];
                other_center = _e1506;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e1510 = other_center.x;
            let dx = (_e1510 - center.x);
            let _e1514 = other_center.y;
            let dy = (_e1514 - center.y);
            let _e1518 = normal.x;
            let _e1521 = normal.y;
            let dist_proj = abs(((dx * _e1518) + (dy * _e1521)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e1535 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e1535];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e1545 = fluxes[((face_idx * 8u) + 0u)];
            phi_0_ = _e1545;
            if (owner != idx) {
                let _e1548 = phi_0_;
                let _e1551 = phi_0_;
                phi_0_ = (_e1551 - (_e1548 * 2f));
            }
            let _e1553 = phi_0_;
            let _e1554 = rhs_0_;
            rhs_0_ = (_e1554 - _e1553);
            let _e1558 = constants.viscosity;
            let _e1561 = constants.viscosity;
            let _e1564 = constants.viscosity;
            let _e1568 = is_boundary;
            let _e1572 = dist;
            let diff_coeff_rho_u = ((select(_e1558, ((_e1561 + _e1564) * 0.5f), !(_e1568)) * area) / _e1572);
            let _e1574 = is_boundary;
            if !(_e1574) {
                let _e1583 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1583 + diff_coeff_rho_u);
                let _e1592 = matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)] = (_e1592 - diff_coeff_rho_u);
            } else {
                if (boundary_type == 4u) {
                    let _e1603 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1603 + diff_coeff_rho_u);
                    let _e1611 = state[((idx * 22u) + 10u)];
                    let _e1618 = state[((idx * 22u) + 10u)];
                    let _e1620 = normal.x;
                    let _e1628 = state[((idx * 22u) + 11u)];
                    let _e1630 = normal.y;
                    let _e1634 = normal.x;
                    let _e1638 = rhs_1_;
                    rhs_1_ = (_e1638 + (diff_coeff_rho_u * (_e1611 - (((_e1618 * _e1620) + (_e1628 * _e1630)) * _e1634))));
                } else {
                    let _e1646 = bc_kind[((face_idx * 8u) + 4u)];
                    if (_e1646 == 1u) {
                        let _e1656 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                        matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1656 + diff_coeff_rho_u);
                        let _e1664 = bc_value[((face_idx * 8u) + 4u)];
                        let _e1666 = rhs_1_;
                        rhs_1_ = (_e1666 + (diff_coeff_rho_u * _e1664));
                    } else {
                        let _e1674 = bc_kind[((face_idx * 8u) + 4u)];
                        if (_e1674 == 2u) {
                            let _e1679 = constants.viscosity;
                            let _e1682 = constants.viscosity;
                            let _e1685 = constants.viscosity;
                            let _e1689 = is_boundary;
                            let _e1699 = bc_value[((face_idx * 8u) + 4u)];
                            let _e1702 = rhs_1_;
                            rhs_1_ = (_e1702 + -(((select(_e1679, ((_e1682 + _e1685) * 0.5f), !(_e1689)) * area) * _e1699)));
                        }
                    }
                }
            }
            let _e1704 = is_boundary;
            if !(_e1704) {
                let _e1713 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1713 + diff_coeff_rho_u);
                let _e1722 = matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)] = (_e1722 - diff_coeff_rho_u);
            } else {
                if (boundary_type == 4u) {
                    let _e1733 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1733 + diff_coeff_rho_u);
                    let _e1741 = state[((idx * 22u) + 11u)];
                    let _e1748 = state[((idx * 22u) + 10u)];
                    let _e1750 = normal.x;
                    let _e1758 = state[((idx * 22u) + 11u)];
                    let _e1760 = normal.y;
                    let _e1764 = normal.y;
                    let _e1768 = rhs_2_;
                    rhs_2_ = (_e1768 + (diff_coeff_rho_u * (_e1741 - (((_e1748 * _e1750) + (_e1758 * _e1760)) * _e1764))));
                } else {
                    let _e1776 = bc_kind[((face_idx * 8u) + 5u)];
                    if (_e1776 == 1u) {
                        let _e1786 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                        matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1786 + diff_coeff_rho_u);
                        let _e1794 = bc_value[((face_idx * 8u) + 5u)];
                        let _e1796 = rhs_2_;
                        rhs_2_ = (_e1796 + (diff_coeff_rho_u * _e1794));
                    } else {
                        let _e1804 = bc_kind[((face_idx * 8u) + 5u)];
                        if (_e1804 == 2u) {
                            let _e1809 = constants.viscosity;
                            let _e1812 = constants.viscosity;
                            let _e1815 = constants.viscosity;
                            let _e1819 = is_boundary;
                            let _e1829 = bc_value[((face_idx * 8u) + 5u)];
                            let _e1832 = rhs_2_;
                            rhs_2_ = (_e1832 + -(((select(_e1809, ((_e1812 + _e1815) * 0.5f), !(_e1819)) * area) * _e1829)));
                        }
                    }
                }
            }
            let _e1840 = fluxes[((face_idx * 8u) + 1u)];
            phi_1_ = _e1840;
            if (owner != idx) {
                let _e1843 = phi_1_;
                let _e1846 = phi_1_;
                phi_1_ = (_e1846 - (_e1843 * 2f));
            }
            let _e1848 = phi_1_;
            let _e1849 = rhs_1_;
            rhs_1_ = (_e1849 - _e1848);
            let _e1857 = fluxes[((face_idx * 8u) + 2u)];
            phi_2_ = _e1857;
            if (owner != idx) {
                let _e1860 = phi_2_;
                let _e1863 = phi_2_;
                phi_2_ = (_e1863 - (_e1860 * 2f));
            }
            let _e1865 = phi_2_;
            let _e1866 = rhs_2_;
            rhs_2_ = (_e1866 - _e1865);
            let _e1870 = constants.viscosity;
            let _e1873 = constants.eos_gamma;
            let _e1877 = constants.eos_r;
            let _e1881 = constants.eos_gm1_;
            let _e1889 = constants.viscosity;
            let _e1892 = constants.eos_gamma;
            let _e1896 = constants.eos_r;
            let _e1900 = constants.eos_gm1_;
            let _e1908 = constants.viscosity;
            let _e1911 = constants.eos_gamma;
            let _e1915 = constants.eos_r;
            let _e1919 = constants.eos_gm1_;
            let _e1928 = is_boundary;
            let _e1932 = dist;
            let diff_coeff_rho_e = ((select(((((_e1870 * _e1873) * _e1877) / max(_e1881, 0.000000000001f)) / 0.71f), ((((((_e1889 * _e1892) * _e1896) / max(_e1900, 0.000000000001f)) / 0.71f) + ((((_e1908 * _e1911) * _e1915) / max(_e1919, 0.000000000001f)) / 0.71f)) * 0.5f), !(_e1928)) * area) / _e1932);
            let _e1934 = is_boundary;
            if !(_e1934) {
                let _e1943 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 7u)];
                matrix_values[((start_row_3_ + (diag_rank * 8u)) + 7u)] = (_e1943 + diff_coeff_rho_e);
                let _e1952 = matrix_values[((start_row_3_ + (neighbor_rank * 8u)) + 7u)];
                matrix_values[((start_row_3_ + (neighbor_rank * 8u)) + 7u)] = (_e1952 - diff_coeff_rho_e);
            } else {
                let _e1960 = bc_kind[((face_idx * 8u) + 7u)];
                if (_e1960 == 1u) {
                    let _e1970 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 7u)];
                    matrix_values[((start_row_3_ + (diag_rank * 8u)) + 7u)] = (_e1970 + diff_coeff_rho_e);
                    let _e1978 = bc_value[((face_idx * 8u) + 7u)];
                    let _e1980 = rhs_3_;
                    rhs_3_ = (_e1980 + (diff_coeff_rho_e * _e1978));
                } else {
                    let _e1988 = bc_kind[((face_idx * 8u) + 7u)];
                    if (_e1988 == 2u) {
                        let _e1993 = constants.viscosity;
                        let _e1996 = constants.eos_gamma;
                        let _e2000 = constants.eos_r;
                        let _e2004 = constants.eos_gm1_;
                        let _e2012 = constants.viscosity;
                        let _e2015 = constants.eos_gamma;
                        let _e2019 = constants.eos_r;
                        let _e2023 = constants.eos_gm1_;
                        let _e2031 = constants.viscosity;
                        let _e2034 = constants.eos_gamma;
                        let _e2038 = constants.eos_r;
                        let _e2042 = constants.eos_gm1_;
                        let _e2051 = is_boundary;
                        let _e2061 = bc_value[((face_idx * 8u) + 7u)];
                        let _e2064 = rhs_3_;
                        rhs_3_ = (_e2064 + -(((select(((((_e1993 * _e1996) * _e2000) / max(_e2004, 0.000000000001f)) / 0.71f), ((((((_e2012 * _e2015) * _e2019) / max(_e2023, 0.000000000001f)) / 0.71f) + ((((_e2031 * _e2034) * _e2038) / max(_e2042, 0.000000000001f)) / 0.71f)) * 0.5f), !(_e2051)) * area) * _e2061)));
                    }
                }
            }
            let _e2072 = fluxes[((face_idx * 8u) + 3u)];
            phi_3_ = _e2072;
            if (owner != idx) {
                let _e2075 = phi_3_;
                let _e2078 = phi_3_;
                phi_3_ = (_e2078 - (_e2075 * 2f));
            }
            let _e2080 = phi_3_;
            let _e2081 = rhs_3_;
            rhs_3_ = (_e2081 - _e2080);
        }
        continuing {
            let _e2084 = k;
            k = (_e2084 + 1u);
        }
    }
    let _e2093 = diag_0_;
    let _e2094 = matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)] = (_e2094 + _e2093);
    let _e2102 = rhs_0_;
    rhs[((idx * 8u) + 0u)] = _e2102;
    let _e2110 = diag_1_;
    let _e2111 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)] = (_e2111 + _e2110);
    let _e2119 = rhs_1_;
    rhs[((idx * 8u) + 1u)] = _e2119;
    let _e2127 = diag_2_;
    let _e2128 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)] = (_e2128 + _e2127);
    let _e2136 = rhs_2_;
    rhs[((idx * 8u) + 2u)] = _e2136;
    let _e2144 = diag_3_;
    let _e2145 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)] = (_e2145 + _e2144);
    let _e2153 = rhs_3_;
    rhs[((idx * 8u) + 3u)] = _e2153;
    let _e2161 = diag_4_;
    let _e2162 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)] = (_e2162 + _e2161);
    let _e2171 = rhs_4_;
    rhs[((idx * 8u) + 4u)] = _e2171;
    let _e2179 = diag_5_;
    let _e2180 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)] = (_e2180 + _e2179);
    let _e2189 = rhs_5_;
    rhs[((idx * 8u) + 5u)] = _e2189;
    let _e2197 = diag_6_;
    let _e2198 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)] = (_e2198 + _e2197);
    let _e2206 = rhs_6_;
    rhs[((idx * 8u) + 6u)] = _e2206;
    let _e2214 = diag_7_;
    let _e2215 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)] = (_e2215 + _e2214);
    let _e2224 = rhs_7_;
    rhs[((idx * 8u) + 7u)] = _e2224;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_grad_state_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = is_boundary;
            let _e262 = dist;
            let diff_coeff_phi = ((select(1f, 1f, !(_e256)) * area) / _e262);
            let _e264 = is_boundary;
            if !(_e264) {
                let _e266 = diag_0_;
                diag_0_ = (_e266 + diff_coeff_phi);
                let _e275 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e275 - diff_coeff_phi);
            } else {
                let _e283 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e283 == 1u) {
                    let _e286 = diag_0_;
                    diag_0_ = (_e286 + diff_coeff_phi);
                    let _e294 = bc_value[((face_idx * 1u) + 0u)];
                    let _e296 = rhs_0_;
                    rhs_0_ = (_e296 + (diff_coeff_phi * _e294));
                } else {
                    let _e304 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e304 == 2u) {
                        let _e307 = is_boundary;
                        let _e319 = bc_value[((face_idx * 1u) + 0u)];
                        let _e322 = rhs_0_;
                        rhs_0_ = (_e322 + -(((select(1f, 1f, !(_e307)) * area) * _e319)));
                    }
                }
            }
        }
        continuing {
            let _e325 = k;
            k = (_e325 + 1u);
        }
    }
    let _e334 = diag_0_;
    let _e335 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e335 + _e334);
    let _e343 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e343;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup0") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup1") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup2") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup3") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device . create_pipeline_layout (& wgpu :: PipelineLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::PipelineLayout") , bind_group_layouts : & [& WgpuBindGroup0 :: get_bind_group_layout (device) , & WgpuBindGroup1 :: get_bind_group_layout (device) , & WgpuBindGroup2 :: get_bind_group_layout (device) , & WgpuBindGroup3 :: get_bind_group_layout (device)] , push_constant_ranges : & [] , })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some(
                    "generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann.wgsl",
                ),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = is_boundary;
            let _e262 = dist;
            let diff_coeff_phi = ((select(1f, 1f, !(_e256)) * area) / _e262);
            let _e264 = is_boundary;
            if !(_e264) {
                let _e266 = diag_0_;
                diag_0_ = (_e266 + diff_coeff_phi);
                let _e275 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e275 - diff_coeff_phi);
            } else {
                let _e283 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e283 == 1u) {
                    let _e286 = diag_0_;
                    diag_0_ = (_e286 + diff_coeff_phi);
                    let _e294 = bc_value[((face_idx * 1u) + 0u)];
                    let _e296 = rhs_0_;
                    rhs_0_ = (_e296 + (diff_coeff_phi * _e294));
                } else {
                    let _e304 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e304 == 2u) {
                        let _e307 = is_boundary;
                        let _e319 = bc_value[((face_idx * 1u) + 0u)];
                        let _e322 = rhs_0_;
                        rhs_0_ = (_e322 + -(((select(1f, 1f, !(_e307)) * area) * _e319)));
                    }
                }
            }
        }
        continuing {
            let _e325 = k;
            k = (_e325 + 1u);
        }
    }
    let _e334 = diag_0_;
    let _e335 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e335 + _e334);
    let _e343 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e343;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup0") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup1") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup2") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup3") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device . create_pipeline_layout (& wgpu :: PipelineLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::PipelineLayout") , bind_group_layouts : & [& WgpuBindGroup0 :: get_bind_group_layout (device) , & WgpuBindGroup1 :: get_bind_group_layout (device) , & WgpuBindGroup2 :: get_bind_group_layout (device) , & WgpuBindGroup3 :: get_bind_group_layout (device)] , push_constant_ranges : & [] , })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_grad_state_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 9u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 3u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 3u) * 2u));
    loop {
        let _e53 = rank;
        if (_e53 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e55 = rank;
            matrix_values[((start_row_0_ + (_e55 * 3u)) + 0u)] = 0f;
            let _e64 = rank;
            matrix_values[((start_row_0_ + (_e64 * 3u)) + 1u)] = 0f;
            let _e73 = rank;
            matrix_values[((start_row_0_ + (_e73 * 3u)) + 2u)] = 0f;
            let _e82 = rank;
            matrix_values[((start_row_1_ + (_e82 * 3u)) + 0u)] = 0f;
            let _e91 = rank;
            matrix_values[((start_row_1_ + (_e91 * 3u)) + 1u)] = 0f;
            let _e100 = rank;
            matrix_values[((start_row_1_ + (_e100 * 3u)) + 2u)] = 0f;
            let _e109 = rank;
            matrix_values[((start_row_2_ + (_e109 * 3u)) + 0u)] = 0f;
            let _e118 = rank;
            matrix_values[((start_row_2_ + (_e118 * 3u)) + 1u)] = 0f;
            let _e127 = rank;
            matrix_values[((start_row_2_ + (_e127 * 3u)) + 2u)] = 0f;
        }
        continuing {
            let _e137 = rank;
            rank = (_e137 + 1u);
        }
    }
    let _e141 = constants.density;
    let _e146 = constants.dt;
    let _e148 = diag_0_;
    diag_0_ = (_e148 + ((vol * _e141) / _e146));
    let _e152 = constants.density;
    let _e156 = constants.dt;
    let _e165 = state_old[((idx * 8u) + 0u)];
    let _e167 = rhs_0_;
    rhs_0_ = (_e167 + (((vol * _e152) / _e156) * _e165));
    let _e171 = constants.time_scheme;
    if (_e171 == 1u) {
        let _e176 = constants.dt;
        let _e179 = constants.dt_old;
        let r = (_e176 / _e179);
        let _e183 = constants.density;
        let _e187 = constants.dt;
        let diag_bdf2_ = ((((vol * _e183) / _e187) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e203 = diag_0_;
        let _e206 = constants.density;
        let _e210 = constants.dt;
        diag_0_ = ((_e203 - ((vol * _e206) / _e210)) + diag_bdf2_);
        let _e214 = rhs_0_;
        let _e217 = constants.density;
        let _e221 = constants.dt;
        let _e229 = state_old[((idx * 8u) + 0u)];
        let _e234 = constants.density;
        let _e238 = constants.dt;
        let _e246 = state_old[((idx * 8u) + 0u)];
        let _e254 = state_old_old[((idx * 8u) + 0u)];
        rhs_0_ = ((_e214 - (((vol * _e217) / _e221) * _e229)) + (((vol * _e234) / _e238) * ((factor_n * _e246) - (factor_nm1_ * _e254))));
    }
    let _e261 = constants.dtau;
    if (_e261 > 0f) {
        let _e266 = constants.density;
        let _e270 = constants.dtau;
        let _e272 = diag_0_;
        diag_0_ = (_e272 + ((vol * _e266) / _e270));
        let _e276 = constants.density;
        let _e280 = constants.dtau;
        let _e288 = state_iter[((idx * 8u) + 0u)];
        let _e290 = rhs_0_;
        rhs_0_ = (_e290 + (((vol * _e276) / _e280) * _e288));
    }
    let _e294 = constants.density;
    let _e299 = constants.dt;
    let _e301 = diag_1_;
    diag_1_ = (_e301 + ((vol * _e294) / _e299));
    let _e305 = constants.density;
    let _e309 = constants.dt;
    let _e318 = state_old[((idx * 8u) + 1u)];
    let _e320 = rhs_1_;
    rhs_1_ = (_e320 + (((vol * _e305) / _e309) * _e318));
    let _e324 = constants.time_scheme;
    if (_e324 == 1u) {
        let _e329 = constants.dt;
        let _e332 = constants.dt_old;
        let r_1 = (_e329 / _e332);
        let _e336 = constants.density;
        let _e340 = constants.dt;
        let diag_bdf2_1 = ((((vol * _e336) / _e340) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e356 = diag_1_;
        let _e359 = constants.density;
        let _e363 = constants.dt;
        diag_1_ = ((_e356 - ((vol * _e359) / _e363)) + diag_bdf2_1);
        let _e367 = rhs_1_;
        let _e370 = constants.density;
        let _e374 = constants.dt;
        let _e382 = state_old[((idx * 8u) + 1u)];
        let _e387 = constants.density;
        let _e391 = constants.dt;
        let _e399 = state_old[((idx * 8u) + 1u)];
        let _e407 = state_old_old[((idx * 8u) + 1u)];
        rhs_1_ = ((_e367 - (((vol * _e370) / _e374) * _e382)) + (((vol * _e387) / _e391) * ((factor_n_1 * _e399) - (factor_nm1_1 * _e407))));
    }
    let _e414 = constants.dtau;
    if (_e414 > 0f) {
        let _e419 = constants.density;
        let _e423 = constants.dtau;
        let _e425 = diag_1_;
        diag_1_ = (_e425 + ((vol * _e419) / _e423));
        let _e429 = constants.density;
        let _e433 = constants.dtau;
        let _e441 = state_iter[((idx * 8u) + 1u)];
        let _e443 = rhs_1_;
        rhs_1_ = (_e443 + (((vol * _e429) / _e433) * _e441));
    }
    k = start;
    loop {
        let _e446 = k;
        if (_e446 < end) {
        } else {
            break;
        }
        {
            let _e449 = k;
            let face_idx = cell_faces[_e449];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e469 = face_normals[face_idx];
            normal = _e469;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e477 = normal.x;
                normal.x = -(_e477);
                let _e481 = normal.y;
                normal.y = -(_e481);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e488 = other_idx;
                let _e490 = cell_centers[_e488];
                other_center = _e490;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e494 = other_center.x;
            let dx = (_e494 - center.x);
            let _e498 = other_center.y;
            let dy = (_e498 - center.y);
            let _e502 = normal.x;
            let _e505 = normal.y;
            let dist_proj = abs(((dx * _e502) + (dy * _e505)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e519 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e519];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e525 = constants.viscosity;
            let _e528 = constants.viscosity;
            let _e531 = constants.viscosity;
            let _e535 = is_boundary;
            let _e539 = dist;
            let diff_coeff_U = ((select(_e525, ((_e528 + _e531) * 0.5f), !(_e535)) * area) / _e539);
            let _e541 = is_boundary;
            if !(_e541) {
                let _e543 = diag_0_;
                diag_0_ = (_e543 + diff_coeff_U);
                let _e552 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e552 - diff_coeff_U);
            } else {
                if (boundary_type == 4u) {
                    let _e556 = diag_0_;
                    diag_0_ = (_e556 + diff_coeff_U);
                    let _e564 = state[((idx * 8u) + 0u)];
                    let _e571 = state[((idx * 8u) + 0u)];
                    let _e573 = normal.x;
                    let _e581 = state[((idx * 8u) + 1u)];
                    let _e583 = normal.y;
                    let _e587 = normal.x;
                    let _e591 = rhs_0_;
                    rhs_0_ = (_e591 + (diff_coeff_U * (_e564 - (((_e571 * _e573) + (_e581 * _e583)) * _e587))));
                } else {
                    let _e599 = bc_kind[((face_idx * 3u) + 0u)];
                    if (_e599 == 1u) {
                        let _e602 = diag_0_;
                        diag_0_ = (_e602 + diff_coeff_U);
                        let _e610 = bc_value[((face_idx * 3u) + 0u)];
                        let _e612 = rhs_0_;
                        rhs_0_ = (_e612 + (diff_coeff_U * _e610));
                    } else {
                        let _e620 = bc_kind[((face_idx * 3u) + 0u)];
                        if (_e620 == 2u) {
                            let _e625 = constants.viscosity;
                            let _e628 = constants.viscosity;
                            let _e631 = constants.viscosity;
                            let _e635 = is_boundary;
                            let _e645 = bc_value[((face_idx * 3u) + 0u)];
                            let _e648 = rhs_0_;
                            rhs_0_ = (_e648 + -(((select(_e625, ((_e628 + _e631) * 0.5f), !(_e635)) * area) * _e645)));
                        }
                    }
                }
            }
            let _e650 = is_boundary;
            if !(_e650) {
                let _e652 = diag_1_;
                diag_1_ = (_e652 + diff_coeff_U);
                let _e661 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e661 - diff_coeff_U);
            } else {
                if (boundary_type == 4u) {
                    let _e665 = diag_1_;
                    diag_1_ = (_e665 + diff_coeff_U);
                    let _e673 = state[((idx * 8u) + 1u)];
                    let _e680 = state[((idx * 8u) + 0u)];
                    let _e682 = normal.x;
                    let _e690 = state[((idx * 8u) + 1u)];
                    let _e692 = normal.y;
                    let _e696 = normal.y;
                    let _e700 = rhs_1_;
                    rhs_1_ = (_e700 + (diff_coeff_U * (_e673 - (((_e680 * _e682) + (_e690 * _e692)) * _e696))));
                } else {
                    let _e708 = bc_kind[((face_idx * 3u) + 1u)];
                    if (_e708 == 1u) {
                        let _e711 = diag_1_;
                        diag_1_ = (_e711 + diff_coeff_U);
                        let _e719 = bc_value[((face_idx * 3u) + 1u)];
                        let _e721 = rhs_1_;
                        rhs_1_ = (_e721 + (diff_coeff_U * _e719));
                    } else {
                        let _e729 = bc_kind[((face_idx * 3u) + 1u)];
                        if (_e729 == 2u) {
                            let _e734 = constants.viscosity;
                            let _e737 = constants.viscosity;
                            let _e740 = constants.viscosity;
                            let _e744 = is_boundary;
                            let _e754 = bc_value[((face_idx * 3u) + 1u)];
                            let _e757 = rhs_1_;
                            rhs_1_ = (_e757 + -(((select(_e734, ((_e737 + _e740) * 0.5f), !(_e744)) * area) * _e754)));
                        }
                    }
                }
            }
            let _e765 = fluxes[((face_idx * 3u) + 0u)];
            phi_0_ = _e765;
            if (owner != idx) {
                let _e768 = phi_0_;
                let _e771 = phi_0_;
                phi_0_ = (_e771 - (_e768 * 2f));
            }
            let _e773 = is_boundary;
            if !(_e773) {
                let _e775 = phi_0_;
                let _e778 = diag_0_;
                diag_0_ = (_e778 + max(_e775, 0f));
                let _e787 = phi_0_;
                let _e790 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e790 + min(_e787, 0f));
                let _e792 = phi_0_;
                let _e799 = state[((idx * 8u) + 0u)];
                let _e800 = other_idx;
                let _e807 = state[((_e800 * 8u) + 0u)];
                let _e808 = phi_0_;
                let _e812 = other_idx;
                let _e819 = state[((_e812 * 8u) + 0u)];
                let _e820 = other_idx;
                let _e828 = grad_state[((_e820 * 8u) + 0u)].x;
                let _e829 = other_idx;
                let _e837 = grad_state[((_e829 * 8u) + 0u)].y;
                let _e843 = other_center.x;
                let _e845 = other_center.y;
                let _e856 = state[((idx * 8u) + 0u)];
                let _e864 = grad_state[((idx * 8u) + 0u)].x;
                let _e872 = grad_state[((idx * 8u) + 0u)].y;
                let _e883 = phi_0_;
                let _e889 = constants.scheme;
                let _e893 = other_idx;
                let _e900 = state[((_e893 * 8u) + 0u)];
                let _e901 = other_idx;
                let _e908 = state[((_e901 * 8u) + 0u)];
                let _e918 = state[((idx * 8u) + 0u)];
                let _e922 = other_idx;
                let _e930 = grad_state[((_e922 * 8u) + 0u)].x;
                let _e931 = other_idx;
                let _e939 = grad_state[((_e931 * 8u) + 0u)].y;
                let _e945 = other_center.x;
                let _e947 = other_center.y;
                let _e954 = other_idx;
                let _e961 = state[((_e954 * 8u) + 0u)];
                let _e969 = state[((idx * 8u) + 0u)];
                let _e976 = state[((idx * 8u) + 0u)];
                let _e980 = other_idx;
                let _e987 = state[((_e980 * 8u) + 0u)];
                let _e998 = grad_state[((idx * 8u) + 0u)].x;
                let _e1006 = grad_state[((idx * 8u) + 0u)].y;
                let _e1009 = other_center.x;
                let _e1011 = other_center.y;
                let _e1027 = state[((idx * 8u) + 0u)];
                let _e1029 = phi_0_;
                let _e1035 = constants.scheme;
                let _e1039 = other_idx;
                let _e1046 = state[((_e1039 * 8u) + 0u)];
                let _e1047 = other_idx;
                let _e1055 = grad_state[((_e1047 * 8u) + 0u)].x;
                let _e1056 = other_idx;
                let _e1064 = grad_state[((_e1056 * 8u) + 0u)].y;
                let _e1070 = other_center.x;
                let _e1072 = other_center.y;
                let _e1082 = state[((idx * 8u) + 0u)];
                let _e1083 = other_idx;
                let _e1090 = state[((_e1083 * 8u) + 0u)];
                let _e1101 = state[((idx * 8u) + 0u)];
                let _e1102 = other_idx;
                let _e1109 = state[((_e1102 * 8u) + 0u)];
                let _e1121 = state[((idx * 8u) + 0u)];
                let _e1129 = grad_state[((idx * 8u) + 0u)].x;
                let _e1137 = grad_state[((idx * 8u) + 0u)].y;
                let _e1147 = other_idx;
                let _e1154 = state[((_e1147 * 8u) + 0u)];
                let _e1161 = state[((idx * 8u) + 0u)];
                let _e1166 = other_idx;
                let _e1173 = state[((_e1166 * 8u) + 0u)];
                let _e1180 = state[((idx * 8u) + 0u)];
                let _e1186 = phi_0_;
                let _e1192 = constants.scheme;
                let _e1196 = other_idx;
                let _e1203 = state[((_e1196 * 8u) + 0u)];
                let _e1204 = other_idx;
                let _e1212 = grad_state[((_e1204 * 8u) + 0u)].x;
                let _e1213 = other_idx;
                let _e1221 = grad_state[((_e1213 * 8u) + 0u)].y;
                let _e1227 = other_center.x;
                let _e1229 = other_center.y;
                let _e1239 = state[((idx * 8u) + 0u)];
                let _e1240 = other_idx;
                let _e1247 = state[((_e1240 * 8u) + 0u)];
                let _e1257 = state[((idx * 8u) + 0u)];
                let _e1258 = other_idx;
                let _e1265 = state[((_e1258 * 8u) + 0u)];
                let _e1268 = other_idx;
                let _e1276 = grad_state[((_e1268 * 8u) + 0u)].x;
                let _e1277 = other_idx;
                let _e1285 = grad_state[((_e1277 * 8u) + 0u)].y;
                let _e1291 = other_center.x;
                let _e1293 = other_center.y;
                let _e1308 = state[((idx * 8u) + 0u)];
                let _e1309 = other_idx;
                let _e1316 = state[((_e1309 * 8u) + 0u)];
                let _e1318 = other_idx;
                let _e1326 = grad_state[((_e1318 * 8u) + 0u)].x;
                let _e1327 = other_idx;
                let _e1335 = grad_state[((_e1327 * 8u) + 0u)].y;
                let _e1341 = other_center.x;
                let _e1343 = other_center.y;
                let _e1357 = state[((idx * 8u) + 0u)];
                let _e1358 = other_idx;
                let _e1365 = state[((_e1358 * 8u) + 0u)];
                let _e1367 = other_idx;
                let _e1375 = grad_state[((_e1367 * 8u) + 0u)].x;
                let _e1376 = other_idx;
                let _e1384 = grad_state[((_e1376 * 8u) + 0u)].y;
                let _e1390 = other_center.x;
                let _e1392 = other_center.y;
                let _e1408 = state[((idx * 8u) + 0u)];
                let _e1416 = grad_state[((idx * 8u) + 0u)].x;
                let _e1424 = grad_state[((idx * 8u) + 0u)].y;
                let _e1434 = other_idx;
                let _e1441 = state[((_e1434 * 8u) + 0u)];
                let _e1448 = state[((idx * 8u) + 0u)];
                let _e1452 = other_idx;
                let _e1459 = state[((_e1452 * 8u) + 0u)];
                let _e1466 = state[((idx * 8u) + 0u)];
                let _e1476 = grad_state[((idx * 8u) + 0u)].x;
                let _e1484 = grad_state[((idx * 8u) + 0u)].y;
                let _e1499 = other_idx;
                let _e1506 = state[((_e1499 * 8u) + 0u)];
                let _e1513 = state[((idx * 8u) + 0u)];
                let _e1522 = grad_state[((idx * 8u) + 0u)].x;
                let _e1530 = grad_state[((idx * 8u) + 0u)].y;
                let _e1544 = other_idx;
                let _e1551 = state[((_e1544 * 8u) + 0u)];
                let _e1558 = state[((idx * 8u) + 0u)];
                let _e1567 = grad_state[((idx * 8u) + 0u)].x;
                let _e1575 = grad_state[((idx * 8u) + 0u)].y;
                let _e1591 = phi_0_;
                let _e1597 = constants.scheme;
                let _e1601 = other_idx;
                let _e1608 = state[((_e1601 * 8u) + 0u)];
                let _e1609 = other_idx;
                let _e1616 = state[((_e1609 * 8u) + 0u)];
                let _e1625 = state[((idx * 8u) + 0u)];
                let _e1629 = other_idx;
                let _e1637 = grad_state[((_e1629 * 8u) + 0u)].x;
                let _e1638 = other_idx;
                let _e1646 = grad_state[((_e1638 * 8u) + 0u)].y;
                let _e1652 = other_center.x;
                let _e1654 = other_center.y;
                let _e1661 = other_idx;
                let _e1668 = state[((_e1661 * 8u) + 0u)];
                let _e1676 = state[((idx * 8u) + 0u)];
                let _e1677 = other_idx;
                let _e1684 = state[((_e1677 * 8u) + 0u)];
                let _e1695 = state[((idx * 8u) + 0u)];
                let _e1696 = other_idx;
                let _e1703 = state[((_e1696 * 8u) + 0u)];
                let _e1715 = state[((idx * 8u) + 0u)];
                let _e1722 = state[((idx * 8u) + 0u)];
                let _e1725 = other_idx;
                let _e1732 = state[((_e1725 * 8u) + 0u)];
                let _e1743 = grad_state[((idx * 8u) + 0u)].x;
                let _e1751 = grad_state[((idx * 8u) + 0u)].y;
                let _e1754 = other_center.x;
                let _e1756 = other_center.y;
                let _e1772 = state[((idx * 8u) + 0u)];
                let _e1774 = other_idx;
                let _e1781 = state[((_e1774 * 8u) + 0u)];
                let _e1788 = state[((idx * 8u) + 0u)];
                let _e1793 = other_idx;
                let _e1800 = state[((_e1793 * 8u) + 0u)];
                let _e1807 = state[((idx * 8u) + 0u)];
                let _e1813 = phi_0_;
                let _e1819 = constants.scheme;
                let _e1823 = other_idx;
                let _e1830 = state[((_e1823 * 8u) + 0u)];
                let _e1831 = other_idx;
                let _e1838 = state[((_e1831 * 8u) + 0u)];
                let _e1847 = state[((idx * 8u) + 0u)];
                let _e1851 = other_idx;
                let _e1859 = grad_state[((_e1851 * 8u) + 0u)].x;
                let _e1860 = other_idx;
                let _e1868 = grad_state[((_e1860 * 8u) + 0u)].y;
                let _e1874 = other_center.x;
                let _e1876 = other_center.y;
                let _e1883 = other_idx;
                let _e1890 = state[((_e1883 * 8u) + 0u)];
                let _e1898 = state[((idx * 8u) + 0u)];
                let _e1899 = other_idx;
                let _e1906 = state[((_e1899 * 8u) + 0u)];
                let _e1916 = state[((idx * 8u) + 0u)];
                let _e1917 = other_idx;
                let _e1924 = state[((_e1917 * 8u) + 0u)];
                let _e1927 = other_idx;
                let _e1934 = state[((_e1927 * 8u) + 0u)];
                let _e1943 = state[((idx * 8u) + 0u)];
                let _e1947 = other_idx;
                let _e1955 = grad_state[((_e1947 * 8u) + 0u)].x;
                let _e1956 = other_idx;
                let _e1964 = grad_state[((_e1956 * 8u) + 0u)].y;
                let _e1970 = other_center.x;
                let _e1972 = other_center.y;
                let _e1979 = other_idx;
                let _e1986 = state[((_e1979 * 8u) + 0u)];
                let _e1999 = state[((idx * 8u) + 0u)];
                let _e2000 = other_idx;
                let _e2007 = state[((_e2000 * 8u) + 0u)];
                let _e2009 = other_idx;
                let _e2016 = state[((_e2009 * 8u) + 0u)];
                let _e2025 = state[((idx * 8u) + 0u)];
                let _e2029 = other_idx;
                let _e2037 = grad_state[((_e2029 * 8u) + 0u)].x;
                let _e2038 = other_idx;
                let _e2046 = grad_state[((_e2038 * 8u) + 0u)].y;
                let _e2052 = other_center.x;
                let _e2054 = other_center.y;
                let _e2061 = other_idx;
                let _e2068 = state[((_e2061 * 8u) + 0u)];
                let _e2080 = state[((idx * 8u) + 0u)];
                let _e2081 = other_idx;
                let _e2088 = state[((_e2081 * 8u) + 0u)];
                let _e2090 = other_idx;
                let _e2097 = state[((_e2090 * 8u) + 0u)];
                let _e2106 = state[((idx * 8u) + 0u)];
                let _e2110 = other_idx;
                let _e2118 = grad_state[((_e2110 * 8u) + 0u)].x;
                let _e2119 = other_idx;
                let _e2127 = grad_state[((_e2119 * 8u) + 0u)].y;
                let _e2133 = other_center.x;
                let _e2135 = other_center.y;
                let _e2142 = other_idx;
                let _e2149 = state[((_e2142 * 8u) + 0u)];
                let _e2163 = state[((idx * 8u) + 0u)];
                let _e2170 = state[((idx * 8u) + 0u)];
                let _e2173 = other_idx;
                let _e2180 = state[((_e2173 * 8u) + 0u)];
                let _e2191 = grad_state[((idx * 8u) + 0u)].x;
                let _e2199 = grad_state[((idx * 8u) + 0u)].y;
                let _e2202 = other_center.x;
                let _e2204 = other_center.y;
                let _e2220 = state[((idx * 8u) + 0u)];
                let _e2222 = other_idx;
                let _e2229 = state[((_e2222 * 8u) + 0u)];
                let _e2236 = state[((idx * 8u) + 0u)];
                let _e2240 = other_idx;
                let _e2247 = state[((_e2240 * 8u) + 0u)];
                let _e2254 = state[((idx * 8u) + 0u)];
                let _e2263 = state[((idx * 8u) + 0u)];
                let _e2266 = other_idx;
                let _e2273 = state[((_e2266 * 8u) + 0u)];
                let _e2284 = grad_state[((idx * 8u) + 0u)].x;
                let _e2292 = grad_state[((idx * 8u) + 0u)].y;
                let _e2295 = other_center.x;
                let _e2297 = other_center.y;
                let _e2313 = state[((idx * 8u) + 0u)];
                let _e2320 = other_idx;
                let _e2327 = state[((_e2320 * 8u) + 0u)];
                let _e2334 = state[((idx * 8u) + 0u)];
                let _e2342 = state[((idx * 8u) + 0u)];
                let _e2345 = other_idx;
                let _e2352 = state[((_e2345 * 8u) + 0u)];
                let _e2363 = grad_state[((idx * 8u) + 0u)].x;
                let _e2371 = grad_state[((idx * 8u) + 0u)].y;
                let _e2374 = other_center.x;
                let _e2376 = other_center.y;
                let _e2392 = state[((idx * 8u) + 0u)];
                let _e2398 = other_idx;
                let _e2405 = state[((_e2398 * 8u) + 0u)];
                let _e2412 = state[((idx * 8u) + 0u)];
                let _e2420 = state[((idx * 8u) + 0u)];
                let _e2423 = other_idx;
                let _e2430 = state[((_e2423 * 8u) + 0u)];
                let _e2441 = grad_state[((idx * 8u) + 0u)].x;
                let _e2449 = grad_state[((idx * 8u) + 0u)].y;
                let _e2452 = other_center.x;
                let _e2454 = other_center.y;
                let _e2470 = state[((idx * 8u) + 0u)];
                let _e2478 = phi_0_;
                let _e2484 = constants.scheme;
                let _e2494 = state[((idx * 8u) + 0u)];
                let _e2495 = other_idx;
                let _e2502 = state[((_e2495 * 8u) + 0u)];
                let _e2503 = phi_0_;
                let _e2509 = rhs_0_;
                rhs_0_ = (_e2509 - (_e792 * (select(select(select(select(select(select(select(_e799, _e807, (_e808 < 0f)), select((_e819 + dot(vec2<f32>(_e828, _e837), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e843, _e845)))), (_e856 + dot(vec2<f32>(_e864, _e872), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e883 > 0f)), (_e889 == 1u)), select(((((_e900 + (_e908 * 0.625f)) + (_e918 * 0.375f)) + (dot(vec2<f32>(_e930, _e939), (vec2<f32>(center.x, center.y) - vec2<f32>(_e945, _e947))) * 0.125f)) - _e961), ((((_e969 + (_e976 * 0.625f)) + (_e987 * 0.375f)) + (dot(vec2<f32>(_e998, _e1006), (vec2<f32>(_e1009, _e1011) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e1027), (_e1029 > 0f)), (_e1035 == 2u)), select((_e1046 + min(max(dot(vec2<f32>(_e1055, _e1064), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1070, _e1072))), min((_e1082 - _e1090), 0f)), max((_e1101 - _e1109), 0f))), (_e1121 + min(max(dot(vec2<f32>(_e1129, _e1137), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e1154 - _e1161), 0f)), max((_e1173 - _e1180), 0f))), (_e1186 > 0f)), (_e1192 == 3u)), select((_e1203 + ((((dot(vec2<f32>(_e1212, _e1221), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1227, _e1229))) * abs((_e1239 - _e1247))) / max(abs((_e1257 - _e1265)), (abs(dot(vec2<f32>(_e1276, _e1285), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1291, _e1293)))) + 0.00000001f))) * max(((_e1308 - _e1316) * dot(vec2<f32>(_e1326, _e1335), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1341, _e1343)))), 0f)) / max(abs(((_e1357 - _e1365) * dot(vec2<f32>(_e1375, _e1384), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1390, _e1392))))), 0.00000001f))), (_e1408 + ((((dot(vec2<f32>(_e1416, _e1424), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e1441 - _e1448))) / max(abs((_e1459 - _e1466)), (abs(dot(vec2<f32>(_e1476, _e1484), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e1506 - _e1513) * dot(vec2<f32>(_e1522, _e1530), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e1551 - _e1558) * dot(vec2<f32>(_e1567, _e1575), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e1591 > 0f)), (_e1597 == 4u)), select((_e1608 + min(max(((((_e1616 * 0.625f) + (_e1625 * 0.375f)) + (dot(vec2<f32>(_e1637, _e1646), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1652, _e1654))) * 0.125f)) - _e1668), min((_e1676 - _e1684), 0f)), max((_e1695 - _e1703), 0f))), (_e1715 + min(max(((((_e1722 * 0.625f) + (_e1732 * 0.375f)) + (dot(vec2<f32>(_e1743, _e1751), (vec2<f32>(_e1754, _e1756) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e1772), min((_e1781 - _e1788), 0f)), max((_e1800 - _e1807), 0f))), (_e1813 > 0f)), (_e1819 == 5u)), select((_e1830 + ((((((((_e1838 * 0.625f) + (_e1847 * 0.375f)) + (dot(vec2<f32>(_e1859, _e1868), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1874, _e1876))) * 0.125f)) - _e1890) * abs((_e1898 - _e1906))) / max(abs((_e1916 - _e1924)), (abs(((((_e1934 * 0.625f) + (_e1943 * 0.375f)) + (dot(vec2<f32>(_e1955, _e1964), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1970, _e1972))) * 0.125f)) - _e1986)) + 0.00000001f))) * max(((_e1999 - _e2007) * ((((_e2016 * 0.625f) + (_e2025 * 0.375f)) + (dot(vec2<f32>(_e2037, _e2046), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2052, _e2054))) * 0.125f)) - _e2068)), 0f)) / max(abs(((_e2080 - _e2088) * ((((_e2097 * 0.625f) + (_e2106 * 0.375f)) + (dot(vec2<f32>(_e2118, _e2127), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2133, _e2135))) * 0.125f)) - _e2149))), 0.00000001f))), (_e2163 + ((((((((_e2170 * 0.625f) + (_e2180 * 0.375f)) + (dot(vec2<f32>(_e2191, _e2199), (vec2<f32>(_e2202, _e2204) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2220) * abs((_e2229 - _e2236))) / max(abs((_e2247 - _e2254)), (abs(((((_e2263 * 0.625f) + (_e2273 * 0.375f)) + (dot(vec2<f32>(_e2284, _e2292), (vec2<f32>(_e2295, _e2297) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2313)) + 0.00000001f))) * max(((_e2327 - _e2334) * ((((_e2342 * 0.625f) + (_e2352 * 0.375f)) + (dot(vec2<f32>(_e2363, _e2371), (vec2<f32>(_e2374, _e2376) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2392)), 0f)) / max(abs(((_e2405 - _e2412) * ((((_e2420 * 0.625f) + (_e2430 * 0.375f)) + (dot(vec2<f32>(_e2441, _e2449), (vec2<f32>(_e2452, _e2454) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2470))), 0.00000001f))), (_e2478 > 0f)), (_e2484 == 6u)) - select(_e2494, _e2502, (_e2503 < 0f)))));
            } else {
                let _e2517 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e2517 == 1u) {
                    let _e2520 = phi_0_;
                    let _e2523 = diag_0_;
                    diag_0_ = (_e2523 + max(_e2520, 0f));
                    let _e2525 = phi_0_;
                    let _e2534 = bc_value[((face_idx * 3u) + 0u)];
                    let _e2536 = rhs_0_;
                    rhs_0_ = (_e2536 - (min(_e2525, 0f) * _e2534));
                } else {
                    let _e2538 = phi_0_;
                    let _e2539 = diag_0_;
                    diag_0_ = (_e2539 + _e2538);
                }
            }
            let _e2547 = fluxes[((face_idx * 3u) + 1u)];
            phi_1_ = _e2547;
            if (owner != idx) {
                let _e2550 = phi_1_;
                let _e2553 = phi_1_;
                phi_1_ = (_e2553 - (_e2550 * 2f));
            }
            let _e2555 = is_boundary;
            if !(_e2555) {
                let _e2557 = phi_1_;
                let _e2560 = diag_1_;
                diag_1_ = (_e2560 + max(_e2557, 0f));
                let _e2569 = phi_1_;
                let _e2572 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e2572 + min(_e2569, 0f));
                let _e2574 = phi_1_;
                let _e2581 = state[((idx * 8u) + 1u)];
                let _e2582 = other_idx;
                let _e2589 = state[((_e2582 * 8u) + 1u)];
                let _e2590 = phi_1_;
                let _e2594 = other_idx;
                let _e2601 = state[((_e2594 * 8u) + 1u)];
                let _e2602 = other_idx;
                let _e2610 = grad_state[((_e2602 * 8u) + 1u)].x;
                let _e2611 = other_idx;
                let _e2619 = grad_state[((_e2611 * 8u) + 1u)].y;
                let _e2625 = other_center.x;
                let _e2627 = other_center.y;
                let _e2638 = state[((idx * 8u) + 1u)];
                let _e2646 = grad_state[((idx * 8u) + 1u)].x;
                let _e2654 = grad_state[((idx * 8u) + 1u)].y;
                let _e2665 = phi_1_;
                let _e2671 = constants.scheme;
                let _e2675 = other_idx;
                let _e2682 = state[((_e2675 * 8u) + 1u)];
                let _e2683 = other_idx;
                let _e2690 = state[((_e2683 * 8u) + 1u)];
                let _e2700 = state[((idx * 8u) + 1u)];
                let _e2704 = other_idx;
                let _e2712 = grad_state[((_e2704 * 8u) + 1u)].x;
                let _e2713 = other_idx;
                let _e2721 = grad_state[((_e2713 * 8u) + 1u)].y;
                let _e2727 = other_center.x;
                let _e2729 = other_center.y;
                let _e2736 = other_idx;
                let _e2743 = state[((_e2736 * 8u) + 1u)];
                let _e2751 = state[((idx * 8u) + 1u)];
                let _e2758 = state[((idx * 8u) + 1u)];
                let _e2762 = other_idx;
                let _e2769 = state[((_e2762 * 8u) + 1u)];
                let _e2780 = grad_state[((idx * 8u) + 1u)].x;
                let _e2788 = grad_state[((idx * 8u) + 1u)].y;
                let _e2791 = other_center.x;
                let _e2793 = other_center.y;
                let _e2809 = state[((idx * 8u) + 1u)];
                let _e2811 = phi_1_;
                let _e2817 = constants.scheme;
                let _e2821 = other_idx;
                let _e2828 = state[((_e2821 * 8u) + 1u)];
                let _e2829 = other_idx;
                let _e2837 = grad_state[((_e2829 * 8u) + 1u)].x;
                let _e2838 = other_idx;
                let _e2846 = grad_state[((_e2838 * 8u) + 1u)].y;
                let _e2852 = other_center.x;
                let _e2854 = other_center.y;
                let _e2864 = state[((idx * 8u) + 1u)];
                let _e2865 = other_idx;
                let _e2872 = state[((_e2865 * 8u) + 1u)];
                let _e2883 = state[((idx * 8u) + 1u)];
                let _e2884 = other_idx;
                let _e2891 = state[((_e2884 * 8u) + 1u)];
                let _e2903 = state[((idx * 8u) + 1u)];
                let _e2911 = grad_state[((idx * 8u) + 1u)].x;
                let _e2919 = grad_state[((idx * 8u) + 1u)].y;
                let _e2929 = other_idx;
                let _e2936 = state[((_e2929 * 8u) + 1u)];
                let _e2943 = state[((idx * 8u) + 1u)];
                let _e2948 = other_idx;
                let _e2955 = state[((_e2948 * 8u) + 1u)];
                let _e2962 = state[((idx * 8u) + 1u)];
                let _e2968 = phi_1_;
                let _e2974 = constants.scheme;
                let _e2978 = other_idx;
                let _e2985 = state[((_e2978 * 8u) + 1u)];
                let _e2986 = other_idx;
                let _e2994 = grad_state[((_e2986 * 8u) + 1u)].x;
                let _e2995 = other_idx;
                let _e3003 = grad_state[((_e2995 * 8u) + 1u)].y;
                let _e3009 = other_center.x;
                let _e3011 = other_center.y;
                let _e3021 = state[((idx * 8u) + 1u)];
                let _e3022 = other_idx;
                let _e3029 = state[((_e3022 * 8u) + 1u)];
                let _e3039 = state[((idx * 8u) + 1u)];
                let _e3040 = other_idx;
                let _e3047 = state[((_e3040 * 8u) + 1u)];
                let _e3050 = other_idx;
                let _e3058 = grad_state[((_e3050 * 8u) + 1u)].x;
                let _e3059 = other_idx;
                let _e3067 = grad_state[((_e3059 * 8u) + 1u)].y;
                let _e3073 = other_center.x;
                let _e3075 = other_center.y;
                let _e3090 = state[((idx * 8u) + 1u)];
                let _e3091 = other_idx;
                let _e3098 = state[((_e3091 * 8u) + 1u)];
                let _e3100 = other_idx;
                let _e3108 = grad_state[((_e3100 * 8u) + 1u)].x;
                let _e3109 = other_idx;
                let _e3117 = grad_state[((_e3109 * 8u) + 1u)].y;
                let _e3123 = other_center.x;
                let _e3125 = other_center.y;
                let _e3139 = state[((idx * 8u) + 1u)];
                let _e3140 = other_idx;
                let _e3147 = state[((_e3140 * 8u) + 1u)];
                let _e3149 = other_idx;
                let _e3157 = grad_state[((_e3149 * 8u) + 1u)].x;
                let _e3158 = other_idx;
                let _e3166 = grad_state[((_e3158 * 8u) + 1u)].y;
                let _e3172 = other_center.x;
                let _e3174 = other_center.y;
                let _e3190 = state[((idx * 8u) + 1u)];
                let _e3198 = grad_state[((idx * 8u) + 1u)].x;
                let _e3206 = grad_state[((idx * 8u) + 1u)].y;
                let _e3216 = other_idx;
                let _e3223 = state[((_e3216 * 8u) + 1u)];
                let _e3230 = state[((idx * 8u) + 1u)];
                let _e3234 = other_idx;
                let _e3241 = state[((_e3234 * 8u) + 1u)];
                let _e3248 = state[((idx * 8u) + 1u)];
                let _e3258 = grad_state[((idx * 8u) + 1u)].x;
                let _e3266 = grad_state[((idx * 8u) + 1u)].y;
                let _e3281 = other_idx;
                let _e3288 = state[((_e3281 * 8u) + 1u)];
                let _e3295 = state[((idx * 8u) + 1u)];
                let _e3304 = grad_state[((idx * 8u) + 1u)].x;
                let _e3312 = grad_state[((idx * 8u) + 1u)].y;
                let _e3326 = other_idx;
                let _e3333 = state[((_e3326 * 8u) + 1u)];
                let _e3340 = state[((idx * 8u) + 1u)];
                let _e3349 = grad_state[((idx * 8u) + 1u)].x;
                let _e3357 = grad_state[((idx * 8u) + 1u)].y;
                let _e3373 = phi_1_;
                let _e3379 = constants.scheme;
                let _e3383 = other_idx;
                let _e3390 = state[((_e3383 * 8u) + 1u)];
                let _e3391 = other_idx;
                let _e3398 = state[((_e3391 * 8u) + 1u)];
                let _e3407 = state[((idx * 8u) + 1u)];
                let _e3411 = other_idx;
                let _e3419 = grad_state[((_e3411 * 8u) + 1u)].x;
                let _e3420 = other_idx;
                let _e3428 = grad_state[((_e3420 * 8u) + 1u)].y;
                let _e3434 = other_center.x;
                let _e3436 = other_center.y;
                let _e3443 = other_idx;
                let _e3450 = state[((_e3443 * 8u) + 1u)];
                let _e3458 = state[((idx * 8u) + 1u)];
                let _e3459 = other_idx;
                let _e3466 = state[((_e3459 * 8u) + 1u)];
                let _e3477 = state[((idx * 8u) + 1u)];
                let _e3478 = other_idx;
                let _e3485 = state[((_e3478 * 8u) + 1u)];
                let _e3497 = state[((idx * 8u) + 1u)];
                let _e3504 = state[((idx * 8u) + 1u)];
                let _e3507 = other_idx;
                let _e3514 = state[((_e3507 * 8u) + 1u)];
                let _e3525 = grad_state[((idx * 8u) + 1u)].x;
                let _e3533 = grad_state[((idx * 8u) + 1u)].y;
                let _e3536 = other_center.x;
                let _e3538 = other_center.y;
                let _e3554 = state[((idx * 8u) + 1u)];
                let _e3556 = other_idx;
                let _e3563 = state[((_e3556 * 8u) + 1u)];
                let _e3570 = state[((idx * 8u) + 1u)];
                let _e3575 = other_idx;
                let _e3582 = state[((_e3575 * 8u) + 1u)];
                let _e3589 = state[((idx * 8u) + 1u)];
                let _e3595 = phi_1_;
                let _e3601 = constants.scheme;
                let _e3605 = other_idx;
                let _e3612 = state[((_e3605 * 8u) + 1u)];
                let _e3613 = other_idx;
                let _e3620 = state[((_e3613 * 8u) + 1u)];
                let _e3629 = state[((idx * 8u) + 1u)];
                let _e3633 = other_idx;
                let _e3641 = grad_state[((_e3633 * 8u) + 1u)].x;
                let _e3642 = other_idx;
                let _e3650 = grad_state[((_e3642 * 8u) + 1u)].y;
                let _e3656 = other_center.x;
                let _e3658 = other_center.y;
                let _e3665 = other_idx;
                let _e3672 = state[((_e3665 * 8u) + 1u)];
                let _e3680 = state[((idx * 8u) + 1u)];
                let _e3681 = other_idx;
                let _e3688 = state[((_e3681 * 8u) + 1u)];
                let _e3698 = state[((idx * 8u) + 1u)];
                let _e3699 = other_idx;
                let _e3706 = state[((_e3699 * 8u) + 1u)];
                let _e3709 = other_idx;
                let _e3716 = state[((_e3709 * 8u) + 1u)];
                let _e3725 = state[((idx * 8u) + 1u)];
                let _e3729 = other_idx;
                let _e3737 = grad_state[((_e3729 * 8u) + 1u)].x;
                let _e3738 = other_idx;
                let _e3746 = grad_state[((_e3738 * 8u) + 1u)].y;
                let _e3752 = other_center.x;
                let _e3754 = other_center.y;
                let _e3761 = other_idx;
                let _e3768 = state[((_e3761 * 8u) + 1u)];
                let _e3781 = state[((idx * 8u) + 1u)];
                let _e3782 = other_idx;
                let _e3789 = state[((_e3782 * 8u) + 1u)];
                let _e3791 = other_idx;
                let _e3798 = state[((_e3791 * 8u) + 1u)];
                let _e3807 = state[((idx * 8u) + 1u)];
                let _e3811 = other_idx;
                let _e3819 = grad_state[((_e3811 * 8u) + 1u)].x;
                let _e3820 = other_idx;
                let _e3828 = grad_state[((_e3820 * 8u) + 1u)].y;
                let _e3834 = other_center.x;
                let _e3836 = other_center.y;
                let _e3843 = other_idx;
                let _e3850 = state[((_e3843 * 8u) + 1u)];
                let _e3862 = state[((idx * 8u) + 1u)];
                let _e3863 = other_idx;
                let _e3870 = state[((_e3863 * 8u) + 1u)];
                let _e3872 = other_idx;
                let _e3879 = state[((_e3872 * 8u) + 1u)];
                let _e3888 = state[((idx * 8u) + 1u)];
                let _e3892 = other_idx;
                let _e3900 = grad_state[((_e3892 * 8u) + 1u)].x;
                let _e3901 = other_idx;
                let _e3909 = grad_state[((_e3901 * 8u) + 1u)].y;
                let _e3915 = other_center.x;
                let _e3917 = other_center.y;
                let _e3924 = other_idx;
                let _e3931 = state[((_e3924 * 8u) + 1u)];
                let _e3945 = state[((idx * 8u) + 1u)];
                let _e3952 = state[((idx * 8u) + 1u)];
                let _e3955 = other_idx;
                let _e3962 = state[((_e3955 * 8u) + 1u)];
                let _e3973 = grad_state[((idx * 8u) + 1u)].x;
                let _e3981 = grad_state[((idx * 8u) + 1u)].y;
                let _e3984 = other_center.x;
                let _e3986 = other_center.y;
                let _e4002 = state[((idx * 8u) + 1u)];
                let _e4004 = other_idx;
                let _e4011 = state[((_e4004 * 8u) + 1u)];
                let _e4018 = state[((idx * 8u) + 1u)];
                let _e4022 = other_idx;
                let _e4029 = state[((_e4022 * 8u) + 1u)];
                let _e4036 = state[((idx * 8u) + 1u)];
                let _e4045 = state[((idx * 8u) + 1u)];
                let _e4048 = other_idx;
                let _e4055 = state[((_e4048 * 8u) + 1u)];
                let _e4066 = grad_state[((idx * 8u) + 1u)].x;
                let _e4074 = grad_state[((idx * 8u) + 1u)].y;
                let _e4077 = other_center.x;
                let _e4079 = other_center.y;
                let _e4095 = state[((idx * 8u) + 1u)];
                let _e4102 = other_idx;
                let _e4109 = state[((_e4102 * 8u) + 1u)];
                let _e4116 = state[((idx * 8u) + 1u)];
                let _e4124 = state[((idx * 8u) + 1u)];
                let _e4127 = other_idx;
                let _e4134 = state[((_e4127 * 8u) + 1u)];
                let _e4145 = grad_state[((idx * 8u) + 1u)].x;
                let _e4153 = grad_state[((idx * 8u) + 1u)].y;
                let _e4156 = other_center.x;
                let _e4158 = other_center.y;
                let _e4174 = state[((idx * 8u) + 1u)];
                let _e4180 = other_idx;
                let _e4187 = state[((_e4180 * 8u) + 1u)];
                let _e4194 = state[((idx * 8u) + 1u)];
                let _e4202 = state[((idx * 8u) + 1u)];
                let _e4205 = other_idx;
                let _e4212 = state[((_e4205 * 8u) + 1u)];
                let _e4223 = grad_state[((idx * 8u) + 1u)].x;
                let _e4231 = grad_state[((idx * 8u) + 1u)].y;
                let _e4234 = other_center.x;
                let _e4236 = other_center.y;
                let _e4252 = state[((idx * 8u) + 1u)];
                let _e4260 = phi_1_;
                let _e4266 = constants.scheme;
                let _e4276 = state[((idx * 8u) + 1u)];
                let _e4277 = other_idx;
                let _e4284 = state[((_e4277 * 8u) + 1u)];
                let _e4285 = phi_1_;
                let _e4291 = rhs_1_;
                rhs_1_ = (_e4291 - (_e2574 * (select(select(select(select(select(select(select(_e2581, _e2589, (_e2590 < 0f)), select((_e2601 + dot(vec2<f32>(_e2610, _e2619), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e2625, _e2627)))), (_e2638 + dot(vec2<f32>(_e2646, _e2654), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e2665 > 0f)), (_e2671 == 1u)), select(((((_e2682 + (_e2690 * 0.625f)) + (_e2700 * 0.375f)) + (dot(vec2<f32>(_e2712, _e2721), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2727, _e2729))) * 0.125f)) - _e2743), ((((_e2751 + (_e2758 * 0.625f)) + (_e2769 * 0.375f)) + (dot(vec2<f32>(_e2780, _e2788), (vec2<f32>(_e2791, _e2793) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2809), (_e2811 > 0f)), (_e2817 == 2u)), select((_e2828 + min(max(dot(vec2<f32>(_e2837, _e2846), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e2852, _e2854))), min((_e2864 - _e2872), 0f)), max((_e2883 - _e2891), 0f))), (_e2903 + min(max(dot(vec2<f32>(_e2911, _e2919), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e2936 - _e2943), 0f)), max((_e2955 - _e2962), 0f))), (_e2968 > 0f)), (_e2974 == 3u)), select((_e2985 + ((((dot(vec2<f32>(_e2994, _e3003), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3009, _e3011))) * abs((_e3021 - _e3029))) / max(abs((_e3039 - _e3047)), (abs(dot(vec2<f32>(_e3058, _e3067), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3073, _e3075)))) + 0.00000001f))) * max(((_e3090 - _e3098) * dot(vec2<f32>(_e3108, _e3117), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3123, _e3125)))), 0f)) / max(abs(((_e3139 - _e3147) * dot(vec2<f32>(_e3157, _e3166), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3172, _e3174))))), 0.00000001f))), (_e3190 + ((((dot(vec2<f32>(_e3198, _e3206), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e3223 - _e3230))) / max(abs((_e3241 - _e3248)), (abs(dot(vec2<f32>(_e3258, _e3266), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e3288 - _e3295) * dot(vec2<f32>(_e3304, _e3312), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e3333 - _e3340) * dot(vec2<f32>(_e3349, _e3357), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e3373 > 0f)), (_e3379 == 4u)), select((_e3390 + min(max(((((_e3398 * 0.625f) + (_e3407 * 0.375f)) + (dot(vec2<f32>(_e3419, _e3428), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3434, _e3436))) * 0.125f)) - _e3450), min((_e3458 - _e3466), 0f)), max((_e3477 - _e3485), 0f))), (_e3497 + min(max(((((_e3504 * 0.625f) + (_e3514 * 0.375f)) + (dot(vec2<f32>(_e3525, _e3533), (vec2<f32>(_e3536, _e3538) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3554), min((_e3563 - _e3570), 0f)), max((_e3582 - _e3589), 0f))), (_e3595 > 0f)), (_e3601 == 5u)), select((_e3612 + ((((((((_e3620 * 0.625f) + (_e3629 * 0.375f)) + (dot(vec2<f32>(_e3641, _e3650), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3656, _e3658))) * 0.125f)) - _e3672) * abs((_e3680 - _e3688))) / max(abs((_e3698 - _e3706)), (abs(((((_e3716 * 0.625f) + (_e3725 * 0.375f)) + (dot(vec2<f32>(_e3737, _e3746), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3752, _e3754))) * 0.125f)) - _e3768)) + 0.00000001f))) * max(((_e3781 - _e3789) * ((((_e3798 * 0.625f) + (_e3807 * 0.375f)) + (dot(vec2<f32>(_e3819, _e3828), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3834, _e3836))) * 0.125f)) - _e3850)), 0f)) / max(abs(((_e3862 - _e3870) * ((((_e3879 * 0.625f) + (_e3888 * 0.375f)) + (dot(vec2<f32>(_e3900, _e3909), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3915, _e3917))) * 0.125f)) - _e3931))), 0.00000001f))), (_e3945 + ((((((((_e3952 * 0.625f) + (_e3962 * 0.375f)) + (dot(vec2<f32>(_e3973, _e3981), (vec2<f32>(_e3984, _e3986) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4002) * abs((_e4011 - _e4018))) / max(abs((_e4029 - _e4036)), (abs(((((_e4045 * 0.625f) + (_e4055 * 0.375f)) + (dot(vec2<f32>(_e4066, _e4074), (vec2<f32>(_e4077, _e4079) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4095)) + 0.00000001f))) * max(((_e4109 - _e4116) * ((((_e4124 * 0.625f) + (_e4134 * 0.375f)) + (dot(vec2<f32>(_e4145, _e4153), (vec2<f32>(_e4156, _e4158) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4174)), 0f)) / max(abs(((_e4187 - _e4194) * ((((_e4202 * 0.625f) + (_e4212 * 0.375f)) + (dot(vec2<f32>(_e4223, _e4231), (vec2<f32>(_e4234, _e4236) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4252))), 0.00000001f))), (_e4260 > 0f)), (_e4266 == 6u)) - select(_e4276, _e4284, (_e4285 < 0f)))));
            } else {
                let _e4299 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e4299 == 1u) {
                    let _e4302 = phi_1_;
                    let _e4305 = diag_1_;
                    diag_1_ = (_e4305 + max(_e4302, 0f));
                    let _e4307 = phi_1_;
                    let _e4316 = bc_value[((face_idx * 3u) + 1u)];
                    let _e4318 = rhs_1_;
                    rhs_1_ = (_e4318 - (min(_e4307, 0f) * _e4316));
                } else {
                    let _e4320 = phi_1_;
                    let _e4321 = diag_1_;
                    diag_1_ = (_e4321 + _e4320);
                }
            }
            let _e4326 = normal.x;
            let _e4334 = state[((idx * 8u) + 2u)];
            let _e4335 = other_idx;
            let _e4342 = state[((_e4335 * 8u) + 2u)];
            let _e4345 = rhs_0_;
            rhs_0_ = (_e4345 - (((0.5f * area) * _e4326) * (_e4334 + _e4342)));
            let _e4350 = normal.y;
            let _e4358 = state[((idx * 8u) + 2u)];
            let _e4359 = other_idx;
            let _e4366 = state[((_e4359 * 8u) + 2u)];
            let _e4369 = rhs_1_;
            rhs_1_ = (_e4369 - (((0.5f * area) * _e4350) * (_e4358 + _e4366)));
            let _e4373 = constants.density;
            let _e4380 = state[((idx * 8u) + 3u)];
            let _e4384 = constants.density;
            let _e4391 = state[((idx * 8u) + 3u)];
            let _e4395 = constants.density;
            let _e4396 = other_idx;
            let _e4403 = state[((_e4396 * 8u) + 3u)];
            let _e4408 = is_boundary;
            let _e4412 = dist;
            let diff_coeff_p = ((select((_e4373 * _e4380), (((_e4384 * _e4391) + (_e4395 * _e4403)) * 0.5f), !(_e4408)) * area) / _e4412);
            let _e4414 = is_boundary;
            if !(_e4414) {
                let _e4417 = diag_2_;
                diag_2_ = (_e4417 + diff_coeff_p);
                let _e4426 = matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)] = (_e4426 - diff_coeff_p);
            } else {
                let _e4434 = bc_kind[((face_idx * 3u) + 2u)];
                if (_e4434 == 1u) {
                    let _e4437 = diag_2_;
                    diag_2_ = (_e4437 + diff_coeff_p);
                    let _e4446 = bc_value[((face_idx * 3u) + 2u)];
                    let _e4448 = rhs_2_;
                    rhs_2_ = (_e4448 + (diff_coeff_p * _e4446));
                } else {
                    let _e4456 = bc_kind[((face_idx * 3u) + 2u)];
                    if (_e4456 == 2u) {
                        let _e4461 = constants.density;
                        let _e4468 = state[((idx * 8u) + 3u)];
                        let _e4472 = constants.density;
                        let _e4479 = state[((idx * 8u) + 3u)];
                        let _e4483 = constants.density;
                        let _e4484 = other_idx;
                        let _e4491 = state[((_e4484 * 8u) + 3u)];
                        let _e4496 = is_boundary;
                        let _e4506 = bc_value[((face_idx * 3u) + 2u)];
                        let _e4509 = rhs_2_;
                        rhs_2_ = (_e4509 + -(((select((_e4461 * _e4468), (((_e4472 * _e4479) + (_e4483 * _e4491)) * 0.5f), !(_e4496)) * area) * _e4506)));
                    }
                }
            }
            let _e4517 = fluxes[((face_idx * 3u) + 2u)];
            phi_2_ = _e4517;
            if (owner != idx) {
                let _e4520 = phi_2_;
                let _e4523 = phi_2_;
                phi_2_ = (_e4523 - (_e4520 * 2f));
            }
            let _e4525 = phi_2_;
            let _e4526 = rhs_2_;
            rhs_2_ = (_e4526 - _e4525);
        }
        continuing {
            let _e4529 = k;
            k = (_e4529 + 1u);
        }
    }
    let _e4538 = diag_0_;
    let _e4539 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)] = (_e4539 + _e4538);
    let _e4547 = rhs_0_;
    rhs[((idx * 3u) + 0u)] = _e4547;
    let _e4555 = diag_1_;
    let _e4556 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)] = (_e4556 + _e4555);
    let _e4564 = rhs_1_;
    rhs[((idx * 3u) + 1u)] = _e4564;
    let _e4572 = diag_2_;
    let _e4573 = matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)] = (_e4573 + _e4572);
    let _e4581 = rhs_2_;
    rhs[((idx * 3u) + 2u)] = _e4581;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_incompressible_momentum :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyIncompressibleMomentum::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 9u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 3u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 3u) * 2u));
    loop {
        let _e53 = rank;
        if (_e53 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e55 = rank;
            matrix_values[((start_row_0_ + (_e55 * 3u)) + 0u)] = 0f;
            let _e64 = rank;
            matrix_values[((start_row_0_ + (_e64 * 3u)) + 1u)] = 0f;
            let _e73 = rank;
            matrix_values[((start_row_0_ + (_e73 * 3u)) + 2u)] = 0f;
            let _e82 = rank;
            matrix_values[((start_row_1_ + (_e82 * 3u)) + 0u)] = 0f;
            let _e91 = rank;
            matrix_values[((start_row_1_ + (_e91 * 3u)) + 1u)] = 0f;
            let _e100 = rank;
            matrix_values[((start_row_1_ + (_e100 * 3u)) + 2u)] = 0f;
            let _e109 = rank;
            matrix_values[((start_row_2_ + (_e109 * 3u)) + 0u)] = 0f;
            let _e118 = rank;
            matrix_values[((start_row_2_ + (_e118 * 3u)) + 1u)] = 0f;
            let _e127 = rank;
            matrix_values[((start_row_2_ + (_e127 * 3u)) + 2u)] = 0f;
        }
        continuing {
            let _e137 = rank;
            rank = (_e137 + 1u);
        }
    }
    let _e141 = constants.density;
    let _e146 = constants.dt;
    let _e148 = diag_0_;
    diag_0_ = (_e148 + ((vol * _e141) / _e146));
    let _e152 = constants.density;
    let _e156 = constants.dt;
    let _e165 = state_old[((idx * 8u) + 0u)];
    let _e167 = rhs_0_;
    rhs_0_ = (_e167 + (((vol * _e152) / _e156) * _e165));
    let _e171 = constants.time_scheme;
    if (_e171 == 1u) {
        let _e176 = constants.dt;
        let _e179 = constants.dt_old;
        let r = (_e176 / _e179);
        let _e183 = constants.density;
        let _e187 = constants.dt;
        let diag_bdf2_ = ((((vol * _e183) / _e187) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e203 = diag_0_;
        let _e206 = constants.density;
        let _e210 = constants.dt;
        diag_0_ = ((_e203 - ((vol * _e206) / _e210)) + diag_bdf2_);
        let _e214 = rhs_0_;
        let _e217 = constants.density;
        let _e221 = constants.dt;
        let _e229 = state_old[((idx * 8u) + 0u)];
        let _e234 = constants.density;
        let _e238 = constants.dt;
        let _e246 = state_old[((idx * 8u) + 0u)];
        let _e254 = state_old_old[((idx * 8u) + 0u)];
        rhs_0_ = ((_e214 - (((vol * _e217) / _e221) * _e229)) + (((vol * _e234) / _e238) * ((factor_n * _e246) - (factor_nm1_ * _e254))));
    }
    let _e261 = constants.dtau;
    if (_e261 > 0f) {
        let _e266 = constants.density;
        let _e270 = constants.dtau;
        let _e272 = diag_0_;
        diag_0_ = (_e272 + ((vol * _e266) / _e270));
        let _e276 = constants.density;
        let _e280 = constants.dtau;
        let _e288 = state_iter[((idx * 8u) + 0u)];
        let _e290 = rhs_0_;
        rhs_0_ = (_e290 + (((vol * _e276) / _e280) * _e288));
    }
    let _e294 = constants.density;
    let _e299 = constants.dt;
    let _e301 = diag_1_;
    diag_1_ = (_e301 + ((vol * _e294) / _e299));
    let _e305 = constants.density;
    let _e309 = constants.dt;
    let _e318 = state_old[((idx * 8u) + 1u)];
    let _e320 = rhs_1_;
    rhs_1_ = (_e320 + (((vol * _e305) / _e309) * _e318));
    let _e324 = constants.time_scheme;
    if (_e324 == 1u) {
        let _e329 = constants.dt;
        let _e332 = constants.dt_old;
        let r_1 = (_e329 / _e332);
        let _e336 = constants.density;
        let _e340 = constants.dt;
        let diag_bdf2_1 = ((((vol * _e336) / _e340) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e356 = diag_1_;
        let _e359 = constants.density;
        let _e363 = constants.dt;
        diag_1_ = ((_e356 - ((vol * _e359) / _e363)) + diag_bdf2_1);
        let _e367 = rhs_1_;
        let _e370 = constants.density;
        let _e374 = constants.dt;
        let _e382 = state_old[((idx * 8u) + 1u)];
        let _e387 = constants.density;
        let _e391 = constants.dt;
        let _e399 = state_old[((idx * 8u) + 1u)];
        let _e407 = state_old_old[((idx * 8u) + 1u)];
        rhs_1_ = ((_e367 - (((vol * _e370) / _e374) * _e382)) + (((vol * _e387) / _e391) * ((factor_n_1 * _e399) - (factor_nm1_1 * _e407))));
    }
    let _e414 = constants.dtau;
    if (_e414 > 0f) {
        let _e419 = constants.density;
        let _e423 = constants.dtau;
        let _e425 = diag_1_;
        diag_1_ = (_e425 + ((vol * _e419) / _e423));
        let _e429 = constants.density;
        let _e433 = constants.dtau;
        let _e441 = state_iter[((idx * 8u) + 1u)];
        let _e443 = rhs_1_;
        rhs_1_ = (_e443 + (((vol * _e429) / _e433) * _e441));
    }
    k = start;
    loop {
        let _e446 = k;
        if (_e446 < end) {
        } else {
            break;
        }
        {
            let _e449 = k;
            let face_idx = cell_faces[_e449];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e469 = face_normals[face_idx];
            normal = _e469;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e477 = normal.x;
                normal.x = -(_e477);
                let _e481 = normal.y;
                normal.y = -(_e481);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e488 = other_idx;
                let _e490 = cell_centers[_e488];
                other_center = _e490;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e494 = other_center.x;
            let dx = (_e494 - center.x);
            let _e498 = other_center.y;
            let dy = (_e498 - center.y);
            let _e502 = normal.x;
            let _e505 = normal.y;
            let dist_proj = abs(((dx * _e502) + (dy * _e505)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e519 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e519];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e525 = constants.viscosity;
            let _e528 = constants.viscosity;
            let _e531 = constants.viscosity;
            let _e535 = is_boundary;
            let _e539 = dist;
            let diff_coeff_U = ((select(_e525, ((_e528 + _e531) * 0.5f), !(_e535)) * area) / _e539);
            let _e541 = is_boundary;
            if !(_e541) {
                let _e543 = diag_0_;
                diag_0_ = (_e543 + diff_coeff_U);
                let _e552 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e552 - diff_coeff_U);
            } else {
                if (boundary_type == 4u) {
                    let _e556 = diag_0_;
                    diag_0_ = (_e556 + diff_coeff_U);
                    let _e564 = state[((idx * 8u) + 0u)];
                    let _e571 = state[((idx * 8u) + 0u)];
                    let _e573 = normal.x;
                    let _e581 = state[((idx * 8u) + 1u)];
                    let _e583 = normal.y;
                    let _e587 = normal.x;
                    let _e591 = rhs_0_;
                    rhs_0_ = (_e591 + (diff_coeff_U * (_e564 - (((_e571 * _e573) + (_e581 * _e583)) * _e587))));
                } else {
                    let _e599 = bc_kind[((face_idx * 3u) + 0u)];
                    if (_e599 == 1u) {
                        let _e602 = diag_0_;
                        diag_0_ = (_e602 + diff_coeff_U);
                        let _e610 = bc_value[((face_idx * 3u) + 0u)];
                        let _e612 = rhs_0_;
                        rhs_0_ = (_e612 + (diff_coeff_U * _e610));
                    } else {
                        let _e620 = bc_kind[((face_idx * 3u) + 0u)];
                        if (_e620 == 2u) {
                            let _e625 = constants.viscosity;
                            let _e628 = constants.viscosity;
                            let _e631 = constants.viscosity;
                            let _e635 = is_boundary;
                            let _e645 = bc_value[((face_idx * 3u) + 0u)];
                            let _e648 = rhs_0_;
                            rhs_0_ = (_e648 + -(((select(_e625, ((_e628 + _e631) * 0.5f), !(_e635)) * area) * _e645)));
                        }
                    }
                }
            }
            let _e650 = is_boundary;
            if !(_e650) {
                let _e652 = diag_1_;
                diag_1_ = (_e652 + diff_coeff_U);
                let _e661 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e661 - diff_coeff_U);
            } else {
                if (boundary_type == 4u) {
                    let _e665 = diag_1_;
                    diag_1_ = (_e665 + diff_coeff_U);
                    let _e673 = state[((idx * 8u) + 1u)];
                    let _e680 = state[((idx * 8u) + 0u)];
                    let _e682 = normal.x;
                    let _e690 = state[((idx * 8u) + 1u)];
                    let _e692 = normal.y;
                    let _e696 = normal.y;
                    let _e700 = rhs_1_;
                    rhs_1_ = (_e700 + (diff_coeff_U * (_e673 - (((_e680 * _e682) + (_e690 * _e692)) * _e696))));
                } else {
                    let _e708 = bc_kind[((face_idx * 3u) + 1u)];
                    if (_e708 == 1u) {
                        let _e711 = diag_1_;
                        diag_1_ = (_e711 + diff_coeff_U);
                        let _e719 = bc_value[((face_idx * 3u) + 1u)];
                        let _e721 = rhs_1_;
                        rhs_1_ = (_e721 + (diff_coeff_U * _e719));
                    } else {
                        let _e729 = bc_kind[((face_idx * 3u) + 1u)];
                        if (_e729 == 2u) {
                            let _e734 = constants.viscosity;
                            let _e737 = constants.viscosity;
                            let _e740 = constants.viscosity;
                            let _e744 = is_boundary;
                            let _e754 = bc_value[((face_idx * 3u) + 1u)];
                            let _e757 = rhs_1_;
                            rhs_1_ = (_e757 + -(((select(_e734, ((_e737 + _e740) * 0.5f), !(_e744)) * area) * _e754)));
                        }
                    }
                }
            }
            let _e765 = fluxes[((face_idx * 3u) + 0u)];
            phi_0_ = _e765;
            if (owner != idx) {
                let _e768 = phi_0_;
                let _e771 = phi_0_;
                phi_0_ = (_e771 - (_e768 * 2f));
            }
            let _e773 = is_boundary;
            if !(_e773) {
                let _e775 = phi_0_;
                let _e778 = diag_0_;
                diag_0_ = (_e778 + max(_e775, 0f));
                let _e787 = phi_0_;
                let _e790 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e790 + min(_e787, 0f));
                let _e792 = phi_0_;
                let _e799 = state[((idx * 8u) + 0u)];
                let _e800 = other_idx;
                let _e807 = state[((_e800 * 8u) + 0u)];
                let _e808 = phi_0_;
                let _e812 = other_idx;
                let _e819 = state[((_e812 * 8u) + 0u)];
                let _e820 = other_idx;
                let _e827 = state[((_e820 * 8u) + 0u)];
                let _e834 = state[((idx * 8u) + 0u)];
                let _e843 = other_idx;
                let _e850 = state[((_e843 * 8u) + 0u)];
                let _e857 = state[((idx * 8u) + 0u)];
                let _e871 = other_center.x;
                let _e873 = other_center.y;
                let _e884 = state[((idx * 8u) + 0u)];
                let _e885 = other_idx;
                let _e892 = state[((_e885 * 8u) + 0u)];
                let _e899 = state[((idx * 8u) + 0u)];
                let _e908 = other_idx;
                let _e915 = state[((_e908 * 8u) + 0u)];
                let _e922 = state[((idx * 8u) + 0u)];
                let _e941 = phi_0_;
                let _e947 = constants.scheme;
                let _e951 = other_idx;
                let _e958 = state[((_e951 * 8u) + 0u)];
                let _e959 = other_idx;
                let _e966 = state[((_e959 * 8u) + 0u)];
                let _e976 = state[((idx * 8u) + 0u)];
                let _e980 = other_idx;
                let _e987 = state[((_e980 * 8u) + 0u)];
                let _e994 = state[((idx * 8u) + 0u)];
                let _e1003 = other_idx;
                let _e1010 = state[((_e1003 * 8u) + 0u)];
                let _e1017 = state[((idx * 8u) + 0u)];
                let _e1031 = other_center.x;
                let _e1033 = other_center.y;
                let _e1040 = other_idx;
                let _e1047 = state[((_e1040 * 8u) + 0u)];
                let _e1055 = state[((idx * 8u) + 0u)];
                let _e1062 = state[((idx * 8u) + 0u)];
                let _e1066 = other_idx;
                let _e1073 = state[((_e1066 * 8u) + 0u)];
                let _e1077 = other_idx;
                let _e1084 = state[((_e1077 * 8u) + 0u)];
                let _e1091 = state[((idx * 8u) + 0u)];
                let _e1100 = other_idx;
                let _e1107 = state[((_e1100 * 8u) + 0u)];
                let _e1114 = state[((idx * 8u) + 0u)];
                let _e1125 = other_center.x;
                let _e1127 = other_center.y;
                let _e1143 = state[((idx * 8u) + 0u)];
                let _e1145 = phi_0_;
                let _e1151 = constants.scheme;
                let _e1155 = other_idx;
                let _e1162 = state[((_e1155 * 8u) + 0u)];
                let _e1163 = other_idx;
                let _e1170 = state[((_e1163 * 8u) + 0u)];
                let _e1177 = state[((idx * 8u) + 0u)];
                let _e1186 = other_idx;
                let _e1193 = state[((_e1186 * 8u) + 0u)];
                let _e1200 = state[((idx * 8u) + 0u)];
                let _e1214 = other_center.x;
                let _e1216 = other_center.y;
                let _e1226 = state[((idx * 8u) + 0u)];
                let _e1227 = other_idx;
                let _e1234 = state[((_e1227 * 8u) + 0u)];
                let _e1245 = state[((idx * 8u) + 0u)];
                let _e1246 = other_idx;
                let _e1253 = state[((_e1246 * 8u) + 0u)];
                let _e1265 = state[((idx * 8u) + 0u)];
                let _e1266 = other_idx;
                let _e1273 = state[((_e1266 * 8u) + 0u)];
                let _e1280 = state[((idx * 8u) + 0u)];
                let _e1289 = other_idx;
                let _e1296 = state[((_e1289 * 8u) + 0u)];
                let _e1303 = state[((idx * 8u) + 0u)];
                let _e1321 = other_idx;
                let _e1328 = state[((_e1321 * 8u) + 0u)];
                let _e1335 = state[((idx * 8u) + 0u)];
                let _e1340 = other_idx;
                let _e1347 = state[((_e1340 * 8u) + 0u)];
                let _e1354 = state[((idx * 8u) + 0u)];
                let _e1360 = phi_0_;
                let _e1366 = constants.scheme;
                let _e1370 = other_idx;
                let _e1377 = state[((_e1370 * 8u) + 0u)];
                let _e1378 = other_idx;
                let _e1385 = state[((_e1378 * 8u) + 0u)];
                let _e1392 = state[((idx * 8u) + 0u)];
                let _e1401 = other_idx;
                let _e1408 = state[((_e1401 * 8u) + 0u)];
                let _e1415 = state[((idx * 8u) + 0u)];
                let _e1429 = other_center.x;
                let _e1431 = other_center.y;
                let _e1441 = state[((idx * 8u) + 0u)];
                let _e1442 = other_idx;
                let _e1449 = state[((_e1442 * 8u) + 0u)];
                let _e1459 = state[((idx * 8u) + 0u)];
                let _e1460 = other_idx;
                let _e1467 = state[((_e1460 * 8u) + 0u)];
                let _e1470 = other_idx;
                let _e1477 = state[((_e1470 * 8u) + 0u)];
                let _e1484 = state[((idx * 8u) + 0u)];
                let _e1493 = other_idx;
                let _e1500 = state[((_e1493 * 8u) + 0u)];
                let _e1507 = state[((idx * 8u) + 0u)];
                let _e1521 = other_center.x;
                let _e1523 = other_center.y;
                let _e1538 = state[((idx * 8u) + 0u)];
                let _e1539 = other_idx;
                let _e1546 = state[((_e1539 * 8u) + 0u)];
                let _e1548 = other_idx;
                let _e1555 = state[((_e1548 * 8u) + 0u)];
                let _e1562 = state[((idx * 8u) + 0u)];
                let _e1571 = other_idx;
                let _e1578 = state[((_e1571 * 8u) + 0u)];
                let _e1585 = state[((idx * 8u) + 0u)];
                let _e1599 = other_center.x;
                let _e1601 = other_center.y;
                let _e1615 = state[((idx * 8u) + 0u)];
                let _e1616 = other_idx;
                let _e1623 = state[((_e1616 * 8u) + 0u)];
                let _e1625 = other_idx;
                let _e1632 = state[((_e1625 * 8u) + 0u)];
                let _e1639 = state[((idx * 8u) + 0u)];
                let _e1648 = other_idx;
                let _e1655 = state[((_e1648 * 8u) + 0u)];
                let _e1662 = state[((idx * 8u) + 0u)];
                let _e1676 = other_center.x;
                let _e1678 = other_center.y;
                let _e1694 = state[((idx * 8u) + 0u)];
                let _e1695 = other_idx;
                let _e1702 = state[((_e1695 * 8u) + 0u)];
                let _e1709 = state[((idx * 8u) + 0u)];
                let _e1718 = other_idx;
                let _e1725 = state[((_e1718 * 8u) + 0u)];
                let _e1732 = state[((idx * 8u) + 0u)];
                let _e1750 = other_idx;
                let _e1757 = state[((_e1750 * 8u) + 0u)];
                let _e1764 = state[((idx * 8u) + 0u)];
                let _e1768 = other_idx;
                let _e1775 = state[((_e1768 * 8u) + 0u)];
                let _e1782 = state[((idx * 8u) + 0u)];
                let _e1785 = other_idx;
                let _e1792 = state[((_e1785 * 8u) + 0u)];
                let _e1799 = state[((idx * 8u) + 0u)];
                let _e1808 = other_idx;
                let _e1815 = state[((_e1808 * 8u) + 0u)];
                let _e1822 = state[((idx * 8u) + 0u)];
                let _e1845 = other_idx;
                let _e1852 = state[((_e1845 * 8u) + 0u)];
                let _e1859 = state[((idx * 8u) + 0u)];
                let _e1861 = other_idx;
                let _e1868 = state[((_e1861 * 8u) + 0u)];
                let _e1875 = state[((idx * 8u) + 0u)];
                let _e1884 = other_idx;
                let _e1891 = state[((_e1884 * 8u) + 0u)];
                let _e1898 = state[((idx * 8u) + 0u)];
                let _e1920 = other_idx;
                let _e1927 = state[((_e1920 * 8u) + 0u)];
                let _e1934 = state[((idx * 8u) + 0u)];
                let _e1936 = other_idx;
                let _e1943 = state[((_e1936 * 8u) + 0u)];
                let _e1950 = state[((idx * 8u) + 0u)];
                let _e1959 = other_idx;
                let _e1966 = state[((_e1959 * 8u) + 0u)];
                let _e1973 = state[((idx * 8u) + 0u)];
                let _e1997 = phi_0_;
                let _e2003 = constants.scheme;
                let _e2007 = other_idx;
                let _e2014 = state[((_e2007 * 8u) + 0u)];
                let _e2015 = other_idx;
                let _e2022 = state[((_e2015 * 8u) + 0u)];
                let _e2031 = state[((idx * 8u) + 0u)];
                let _e2035 = other_idx;
                let _e2042 = state[((_e2035 * 8u) + 0u)];
                let _e2049 = state[((idx * 8u) + 0u)];
                let _e2058 = other_idx;
                let _e2065 = state[((_e2058 * 8u) + 0u)];
                let _e2072 = state[((idx * 8u) + 0u)];
                let _e2086 = other_center.x;
                let _e2088 = other_center.y;
                let _e2095 = other_idx;
                let _e2102 = state[((_e2095 * 8u) + 0u)];
                let _e2110 = state[((idx * 8u) + 0u)];
                let _e2111 = other_idx;
                let _e2118 = state[((_e2111 * 8u) + 0u)];
                let _e2129 = state[((idx * 8u) + 0u)];
                let _e2130 = other_idx;
                let _e2137 = state[((_e2130 * 8u) + 0u)];
                let _e2149 = state[((idx * 8u) + 0u)];
                let _e2156 = state[((idx * 8u) + 0u)];
                let _e2159 = other_idx;
                let _e2166 = state[((_e2159 * 8u) + 0u)];
                let _e2170 = other_idx;
                let _e2177 = state[((_e2170 * 8u) + 0u)];
                let _e2184 = state[((idx * 8u) + 0u)];
                let _e2193 = other_idx;
                let _e2200 = state[((_e2193 * 8u) + 0u)];
                let _e2207 = state[((idx * 8u) + 0u)];
                let _e2218 = other_center.x;
                let _e2220 = other_center.y;
                let _e2236 = state[((idx * 8u) + 0u)];
                let _e2238 = other_idx;
                let _e2245 = state[((_e2238 * 8u) + 0u)];
                let _e2252 = state[((idx * 8u) + 0u)];
                let _e2257 = other_idx;
                let _e2264 = state[((_e2257 * 8u) + 0u)];
                let _e2271 = state[((idx * 8u) + 0u)];
                let _e2277 = phi_0_;
                let _e2283 = constants.scheme;
                let _e2287 = other_idx;
                let _e2294 = state[((_e2287 * 8u) + 0u)];
                let _e2295 = other_idx;
                let _e2302 = state[((_e2295 * 8u) + 0u)];
                let _e2311 = state[((idx * 8u) + 0u)];
                let _e2315 = other_idx;
                let _e2322 = state[((_e2315 * 8u) + 0u)];
                let _e2329 = state[((idx * 8u) + 0u)];
                let _e2338 = other_idx;
                let _e2345 = state[((_e2338 * 8u) + 0u)];
                let _e2352 = state[((idx * 8u) + 0u)];
                let _e2366 = other_center.x;
                let _e2368 = other_center.y;
                let _e2375 = other_idx;
                let _e2382 = state[((_e2375 * 8u) + 0u)];
                let _e2390 = state[((idx * 8u) + 0u)];
                let _e2391 = other_idx;
                let _e2398 = state[((_e2391 * 8u) + 0u)];
                let _e2408 = state[((idx * 8u) + 0u)];
                let _e2409 = other_idx;
                let _e2416 = state[((_e2409 * 8u) + 0u)];
                let _e2419 = other_idx;
                let _e2426 = state[((_e2419 * 8u) + 0u)];
                let _e2435 = state[((idx * 8u) + 0u)];
                let _e2439 = other_idx;
                let _e2446 = state[((_e2439 * 8u) + 0u)];
                let _e2453 = state[((idx * 8u) + 0u)];
                let _e2462 = other_idx;
                let _e2469 = state[((_e2462 * 8u) + 0u)];
                let _e2476 = state[((idx * 8u) + 0u)];
                let _e2490 = other_center.x;
                let _e2492 = other_center.y;
                let _e2499 = other_idx;
                let _e2506 = state[((_e2499 * 8u) + 0u)];
                let _e2519 = state[((idx * 8u) + 0u)];
                let _e2520 = other_idx;
                let _e2527 = state[((_e2520 * 8u) + 0u)];
                let _e2529 = other_idx;
                let _e2536 = state[((_e2529 * 8u) + 0u)];
                let _e2545 = state[((idx * 8u) + 0u)];
                let _e2549 = other_idx;
                let _e2556 = state[((_e2549 * 8u) + 0u)];
                let _e2563 = state[((idx * 8u) + 0u)];
                let _e2572 = other_idx;
                let _e2579 = state[((_e2572 * 8u) + 0u)];
                let _e2586 = state[((idx * 8u) + 0u)];
                let _e2600 = other_center.x;
                let _e2602 = other_center.y;
                let _e2609 = other_idx;
                let _e2616 = state[((_e2609 * 8u) + 0u)];
                let _e2628 = state[((idx * 8u) + 0u)];
                let _e2629 = other_idx;
                let _e2636 = state[((_e2629 * 8u) + 0u)];
                let _e2638 = other_idx;
                let _e2645 = state[((_e2638 * 8u) + 0u)];
                let _e2654 = state[((idx * 8u) + 0u)];
                let _e2658 = other_idx;
                let _e2665 = state[((_e2658 * 8u) + 0u)];
                let _e2672 = state[((idx * 8u) + 0u)];
                let _e2681 = other_idx;
                let _e2688 = state[((_e2681 * 8u) + 0u)];
                let _e2695 = state[((idx * 8u) + 0u)];
                let _e2709 = other_center.x;
                let _e2711 = other_center.y;
                let _e2718 = other_idx;
                let _e2725 = state[((_e2718 * 8u) + 0u)];
                let _e2739 = state[((idx * 8u) + 0u)];
                let _e2746 = state[((idx * 8u) + 0u)];
                let _e2749 = other_idx;
                let _e2756 = state[((_e2749 * 8u) + 0u)];
                let _e2760 = other_idx;
                let _e2767 = state[((_e2760 * 8u) + 0u)];
                let _e2774 = state[((idx * 8u) + 0u)];
                let _e2783 = other_idx;
                let _e2790 = state[((_e2783 * 8u) + 0u)];
                let _e2797 = state[((idx * 8u) + 0u)];
                let _e2808 = other_center.x;
                let _e2810 = other_center.y;
                let _e2826 = state[((idx * 8u) + 0u)];
                let _e2828 = other_idx;
                let _e2835 = state[((_e2828 * 8u) + 0u)];
                let _e2842 = state[((idx * 8u) + 0u)];
                let _e2846 = other_idx;
                let _e2853 = state[((_e2846 * 8u) + 0u)];
                let _e2860 = state[((idx * 8u) + 0u)];
                let _e2869 = state[((idx * 8u) + 0u)];
                let _e2872 = other_idx;
                let _e2879 = state[((_e2872 * 8u) + 0u)];
                let _e2883 = other_idx;
                let _e2890 = state[((_e2883 * 8u) + 0u)];
                let _e2897 = state[((idx * 8u) + 0u)];
                let _e2906 = other_idx;
                let _e2913 = state[((_e2906 * 8u) + 0u)];
                let _e2920 = state[((idx * 8u) + 0u)];
                let _e2931 = other_center.x;
                let _e2933 = other_center.y;
                let _e2949 = state[((idx * 8u) + 0u)];
                let _e2956 = other_idx;
                let _e2963 = state[((_e2956 * 8u) + 0u)];
                let _e2970 = state[((idx * 8u) + 0u)];
                let _e2978 = state[((idx * 8u) + 0u)];
                let _e2981 = other_idx;
                let _e2988 = state[((_e2981 * 8u) + 0u)];
                let _e2992 = other_idx;
                let _e2999 = state[((_e2992 * 8u) + 0u)];
                let _e3006 = state[((idx * 8u) + 0u)];
                let _e3015 = other_idx;
                let _e3022 = state[((_e3015 * 8u) + 0u)];
                let _e3029 = state[((idx * 8u) + 0u)];
                let _e3040 = other_center.x;
                let _e3042 = other_center.y;
                let _e3058 = state[((idx * 8u) + 0u)];
                let _e3064 = other_idx;
                let _e3071 = state[((_e3064 * 8u) + 0u)];
                let _e3078 = state[((idx * 8u) + 0u)];
                let _e3086 = state[((idx * 8u) + 0u)];
                let _e3089 = other_idx;
                let _e3096 = state[((_e3089 * 8u) + 0u)];
                let _e3100 = other_idx;
                let _e3107 = state[((_e3100 * 8u) + 0u)];
                let _e3114 = state[((idx * 8u) + 0u)];
                let _e3123 = other_idx;
                let _e3130 = state[((_e3123 * 8u) + 0u)];
                let _e3137 = state[((idx * 8u) + 0u)];
                let _e3148 = other_center.x;
                let _e3150 = other_center.y;
                let _e3166 = state[((idx * 8u) + 0u)];
                let _e3174 = phi_0_;
                let _e3180 = constants.scheme;
                let _e3190 = state[((idx * 8u) + 0u)];
                let _e3191 = other_idx;
                let _e3198 = state[((_e3191 * 8u) + 0u)];
                let _e3199 = phi_0_;
                let _e3205 = rhs_0_;
                rhs_0_ = (_e3205 - (_e792 * (select(select(select(select(select(select(select(_e799, _e807, (_e808 < 0f)), select((_e819 + dot(vec2<f32>((((_e827 - _e834) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e850 - _e857) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e871, _e873)))), (_e884 + dot(vec2<f32>((((_e892 - _e899) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e915 - _e922) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e941 > 0f)), (_e947 == 1u)), select(((((_e958 + (_e966 * 0.625f)) + (_e976 * 0.375f)) + (dot(vec2<f32>((((_e987 - _e994) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1010 - _e1017) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1031, _e1033))) * 0.125f)) - _e1047), ((((_e1055 + (_e1062 * 0.625f)) + (_e1073 * 0.375f)) + (dot(vec2<f32>((((_e1084 - _e1091) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1107 - _e1114) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e1125, _e1127) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e1143), (_e1145 > 0f)), (_e1151 == 2u)), select((_e1162 + min(max(dot(vec2<f32>((((_e1170 - _e1177) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1193 - _e1200) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1214, _e1216))), min((_e1226 - _e1234), 0f)), max((_e1245 - _e1253), 0f))), (_e1265 + min(max(dot(vec2<f32>((((_e1273 - _e1280) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1296 - _e1303) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e1328 - _e1335), 0f)), max((_e1347 - _e1354), 0f))), (_e1360 > 0f)), (_e1366 == 3u)), select((_e1377 + ((((dot(vec2<f32>((((_e1385 - _e1392) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1408 - _e1415) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1429, _e1431))) * abs((_e1441 - _e1449))) / max(abs((_e1459 - _e1467)), (abs(dot(vec2<f32>((((_e1477 - _e1484) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1500 - _e1507) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1521, _e1523)))) + 0.00000001f))) * max(((_e1538 - _e1546) * dot(vec2<f32>((((_e1555 - _e1562) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1578 - _e1585) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1599, _e1601)))), 0f)) / max(abs(((_e1615 - _e1623) * dot(vec2<f32>((((_e1632 - _e1639) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1655 - _e1662) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1676, _e1678))))), 0.00000001f))), (_e1694 + ((((dot(vec2<f32>((((_e1702 - _e1709) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1725 - _e1732) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e1757 - _e1764))) / max(abs((_e1775 - _e1782)), (abs(dot(vec2<f32>((((_e1792 - _e1799) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1815 - _e1822) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e1852 - _e1859) * dot(vec2<f32>((((_e1868 - _e1875) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1891 - _e1898) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e1927 - _e1934) * dot(vec2<f32>((((_e1943 - _e1950) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1966 - _e1973) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e1997 > 0f)), (_e2003 == 4u)), select((_e2014 + min(max(((((_e2022 * 0.625f) + (_e2031 * 0.375f)) + (dot(vec2<f32>((((_e2042 - _e2049) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2065 - _e2072) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2086, _e2088))) * 0.125f)) - _e2102), min((_e2110 - _e2118), 0f)), max((_e2129 - _e2137), 0f))), (_e2149 + min(max(((((_e2156 * 0.625f) + (_e2166 * 0.375f)) + (dot(vec2<f32>((((_e2177 - _e2184) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2200 - _e2207) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e2218, _e2220) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2236), min((_e2245 - _e2252), 0f)), max((_e2264 - _e2271), 0f))), (_e2277 > 0f)), (_e2283 == 5u)), select((_e2294 + ((((((((_e2302 * 0.625f) + (_e2311 * 0.375f)) + (dot(vec2<f32>((((_e2322 - _e2329) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2345 - _e2352) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2366, _e2368))) * 0.125f)) - _e2382) * abs((_e2390 - _e2398))) / max(abs((_e2408 - _e2416)), (abs(((((_e2426 * 0.625f) + (_e2435 * 0.375f)) + (dot(vec2<f32>((((_e2446 - _e2453) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2469 - _e2476) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2490, _e2492))) * 0.125f)) - _e2506)) + 0.00000001f))) * max(((_e2519 - _e2527) * ((((_e2536 * 0.625f) + (_e2545 * 0.375f)) + (dot(vec2<f32>((((_e2556 - _e2563) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2579 - _e2586) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2600, _e2602))) * 0.125f)) - _e2616)), 0f)) / max(abs(((_e2628 - _e2636) * ((((_e2645 * 0.625f) + (_e2654 * 0.375f)) + (dot(vec2<f32>((((_e2665 - _e2672) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2688 - _e2695) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2709, _e2711))) * 0.125f)) - _e2725))), 0.00000001f))), (_e2739 + ((((((((_e2746 * 0.625f) + (_e2756 * 0.375f)) + (dot(vec2<f32>((((_e2767 - _e2774) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2790 - _e2797) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e2808, _e2810) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2826) * abs((_e2835 - _e2842))) / max(abs((_e2853 - _e2860)), (abs(((((_e2869 * 0.625f) + (_e2879 * 0.375f)) + (dot(vec2<f32>((((_e2890 - _e2897) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2913 - _e2920) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e2931, _e2933) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2949)) + 0.00000001f))) * max(((_e2963 - _e2970) * ((((_e2978 * 0.625f) + (_e2988 * 0.375f)) + (dot(vec2<f32>((((_e2999 - _e3006) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3022 - _e3029) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e3040, _e3042) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3058)), 0f)) / max(abs(((_e3071 - _e3078) * ((((_e3086 * 0.625f) + (_e3096 * 0.375f)) + (dot(vec2<f32>((((_e3107 - _e3114) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3130 - _e3137) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e3148, _e3150) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3166))), 0.00000001f))), (_e3174 > 0f)), (_e3180 == 6u)) - select(_e3190, _e3198, (_e3199 < 0f)))));
            } else {
                let _e3213 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e3213 == 1u) {
                    let _e3216 = phi_0_;
                    let _e3219 = diag_0_;
                    diag_0_ = (_e3219 + max(_e3216, 0f));
                    let _e3221 = phi_0_;
                    let _e3230 = bc_value[((face_idx * 3u) + 0u)];
                    let _e3232 = rhs_0_;
                    rhs_0_ = (_e3232 - (min(_e3221, 0f) * _e3230));
                } else {
                    let _e3234 = phi_0_;
                    let _e3235 = diag_0_;
                    diag_0_ = (_e3235 + _e3234);
                }
            }
            let _e3243 = fluxes[((face_idx * 3u) + 1u)];
            phi_1_ = _e3243;
            if (owner != idx) {
                let _e3246 = phi_1_;
                let _e3249 = phi_1_;
                phi_1_ = (_e3249 - (_e3246 * 2f));
            }
            let _e3251 = is_boundary;
            if !(_e3251) {
                let _e3253 = phi_1_;
                let _e3256 = diag_1_;
                diag_1_ = (_e3256 + max(_e3253, 0f));
                let _e3265 = phi_1_;
                let _e3268 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e3268 + min(_e3265, 0f));
                let _e3270 = phi_1_;
                let _e3277 = state[((idx * 8u) + 1u)];
                let _e3278 = other_idx;
                let _e3285 = state[((_e3278 * 8u) + 1u)];
                let _e3286 = phi_1_;
                let _e3290 = other_idx;
                let _e3297 = state[((_e3290 * 8u) + 1u)];
                let _e3298 = other_idx;
                let _e3305 = state[((_e3298 * 8u) + 1u)];
                let _e3312 = state[((idx * 8u) + 1u)];
                let _e3321 = other_idx;
                let _e3328 = state[((_e3321 * 8u) + 1u)];
                let _e3335 = state[((idx * 8u) + 1u)];
                let _e3349 = other_center.x;
                let _e3351 = other_center.y;
                let _e3362 = state[((idx * 8u) + 1u)];
                let _e3363 = other_idx;
                let _e3370 = state[((_e3363 * 8u) + 1u)];
                let _e3377 = state[((idx * 8u) + 1u)];
                let _e3386 = other_idx;
                let _e3393 = state[((_e3386 * 8u) + 1u)];
                let _e3400 = state[((idx * 8u) + 1u)];
                let _e3419 = phi_1_;
                let _e3425 = constants.scheme;
                let _e3429 = other_idx;
                let _e3436 = state[((_e3429 * 8u) + 1u)];
                let _e3437 = other_idx;
                let _e3444 = state[((_e3437 * 8u) + 1u)];
                let _e3454 = state[((idx * 8u) + 1u)];
                let _e3458 = other_idx;
                let _e3465 = state[((_e3458 * 8u) + 1u)];
                let _e3472 = state[((idx * 8u) + 1u)];
                let _e3481 = other_idx;
                let _e3488 = state[((_e3481 * 8u) + 1u)];
                let _e3495 = state[((idx * 8u) + 1u)];
                let _e3509 = other_center.x;
                let _e3511 = other_center.y;
                let _e3518 = other_idx;
                let _e3525 = state[((_e3518 * 8u) + 1u)];
                let _e3533 = state[((idx * 8u) + 1u)];
                let _e3540 = state[((idx * 8u) + 1u)];
                let _e3544 = other_idx;
                let _e3551 = state[((_e3544 * 8u) + 1u)];
                let _e3555 = other_idx;
                let _e3562 = state[((_e3555 * 8u) + 1u)];
                let _e3569 = state[((idx * 8u) + 1u)];
                let _e3578 = other_idx;
                let _e3585 = state[((_e3578 * 8u) + 1u)];
                let _e3592 = state[((idx * 8u) + 1u)];
                let _e3603 = other_center.x;
                let _e3605 = other_center.y;
                let _e3621 = state[((idx * 8u) + 1u)];
                let _e3623 = phi_1_;
                let _e3629 = constants.scheme;
                let _e3633 = other_idx;
                let _e3640 = state[((_e3633 * 8u) + 1u)];
                let _e3641 = other_idx;
                let _e3648 = state[((_e3641 * 8u) + 1u)];
                let _e3655 = state[((idx * 8u) + 1u)];
                let _e3664 = other_idx;
                let _e3671 = state[((_e3664 * 8u) + 1u)];
                let _e3678 = state[((idx * 8u) + 1u)];
                let _e3692 = other_center.x;
                let _e3694 = other_center.y;
                let _e3704 = state[((idx * 8u) + 1u)];
                let _e3705 = other_idx;
                let _e3712 = state[((_e3705 * 8u) + 1u)];
                let _e3723 = state[((idx * 8u) + 1u)];
                let _e3724 = other_idx;
                let _e3731 = state[((_e3724 * 8u) + 1u)];
                let _e3743 = state[((idx * 8u) + 1u)];
                let _e3744 = other_idx;
                let _e3751 = state[((_e3744 * 8u) + 1u)];
                let _e3758 = state[((idx * 8u) + 1u)];
                let _e3767 = other_idx;
                let _e3774 = state[((_e3767 * 8u) + 1u)];
                let _e3781 = state[((idx * 8u) + 1u)];
                let _e3799 = other_idx;
                let _e3806 = state[((_e3799 * 8u) + 1u)];
                let _e3813 = state[((idx * 8u) + 1u)];
                let _e3818 = other_idx;
                let _e3825 = state[((_e3818 * 8u) + 1u)];
                let _e3832 = state[((idx * 8u) + 1u)];
                let _e3838 = phi_1_;
                let _e3844 = constants.scheme;
                let _e3848 = other_idx;
                let _e3855 = state[((_e3848 * 8u) + 1u)];
                let _e3856 = other_idx;
                let _e3863 = state[((_e3856 * 8u) + 1u)];
                let _e3870 = state[((idx * 8u) + 1u)];
                let _e3879 = other_idx;
                let _e3886 = state[((_e3879 * 8u) + 1u)];
                let _e3893 = state[((idx * 8u) + 1u)];
                let _e3907 = other_center.x;
                let _e3909 = other_center.y;
                let _e3919 = state[((idx * 8u) + 1u)];
                let _e3920 = other_idx;
                let _e3927 = state[((_e3920 * 8u) + 1u)];
                let _e3937 = state[((idx * 8u) + 1u)];
                let _e3938 = other_idx;
                let _e3945 = state[((_e3938 * 8u) + 1u)];
                let _e3948 = other_idx;
                let _e3955 = state[((_e3948 * 8u) + 1u)];
                let _e3962 = state[((idx * 8u) + 1u)];
                let _e3971 = other_idx;
                let _e3978 = state[((_e3971 * 8u) + 1u)];
                let _e3985 = state[((idx * 8u) + 1u)];
                let _e3999 = other_center.x;
                let _e4001 = other_center.y;
                let _e4016 = state[((idx * 8u) + 1u)];
                let _e4017 = other_idx;
                let _e4024 = state[((_e4017 * 8u) + 1u)];
                let _e4026 = other_idx;
                let _e4033 = state[((_e4026 * 8u) + 1u)];
                let _e4040 = state[((idx * 8u) + 1u)];
                let _e4049 = other_idx;
                let _e4056 = state[((_e4049 * 8u) + 1u)];
                let _e4063 = state[((idx * 8u) + 1u)];
                let _e4077 = other_center.x;
                let _e4079 = other_center.y;
                let _e4093 = state[((idx * 8u) + 1u)];
                let _e4094 = other_idx;
                let _e4101 = state[((_e4094 * 8u) + 1u)];
                let _e4103 = other_idx;
                let _e4110 = state[((_e4103 * 8u) + 1u)];
                let _e4117 = state[((idx * 8u) + 1u)];
                let _e4126 = other_idx;
                let _e4133 = state[((_e4126 * 8u) + 1u)];
                let _e4140 = state[((idx * 8u) + 1u)];
                let _e4154 = other_center.x;
                let _e4156 = other_center.y;
                let _e4172 = state[((idx * 8u) + 1u)];
                let _e4173 = other_idx;
                let _e4180 = state[((_e4173 * 8u) + 1u)];
                let _e4187 = state[((idx * 8u) + 1u)];
                let _e4196 = other_idx;
                let _e4203 = state[((_e4196 * 8u) + 1u)];
                let _e4210 = state[((idx * 8u) + 1u)];
                let _e4228 = other_idx;
                let _e4235 = state[((_e4228 * 8u) + 1u)];
                let _e4242 = state[((idx * 8u) + 1u)];
                let _e4246 = other_idx;
                let _e4253 = state[((_e4246 * 8u) + 1u)];
                let _e4260 = state[((idx * 8u) + 1u)];
                let _e4263 = other_idx;
                let _e4270 = state[((_e4263 * 8u) + 1u)];
                let _e4277 = state[((idx * 8u) + 1u)];
                let _e4286 = other_idx;
                let _e4293 = state[((_e4286 * 8u) + 1u)];
                let _e4300 = state[((idx * 8u) + 1u)];
                let _e4323 = other_idx;
                let _e4330 = state[((_e4323 * 8u) + 1u)];
                let _e4337 = state[((idx * 8u) + 1u)];
                let _e4339 = other_idx;
                let _e4346 = state[((_e4339 * 8u) + 1u)];
                let _e4353 = state[((idx * 8u) + 1u)];
                let _e4362 = other_idx;
                let _e4369 = state[((_e4362 * 8u) + 1u)];
                let _e4376 = state[((idx * 8u) + 1u)];
                let _e4398 = other_idx;
                let _e4405 = state[((_e4398 * 8u) + 1u)];
                let _e4412 = state[((idx * 8u) + 1u)];
                let _e4414 = other_idx;
                let _e4421 = state[((_e4414 * 8u) + 1u)];
                let _e4428 = state[((idx * 8u) + 1u)];
                let _e4437 = other_idx;
                let _e4444 = state[((_e4437 * 8u) + 1u)];
                let _e4451 = state[((idx * 8u) + 1u)];
                let _e4475 = phi_1_;
                let _e4481 = constants.scheme;
                let _e4485 = other_idx;
                let _e4492 = state[((_e4485 * 8u) + 1u)];
                let _e4493 = other_idx;
                let _e4500 = state[((_e4493 * 8u) + 1u)];
                let _e4509 = state[((idx * 8u) + 1u)];
                let _e4513 = other_idx;
                let _e4520 = state[((_e4513 * 8u) + 1u)];
                let _e4527 = state[((idx * 8u) + 1u)];
                let _e4536 = other_idx;
                let _e4543 = state[((_e4536 * 8u) + 1u)];
                let _e4550 = state[((idx * 8u) + 1u)];
                let _e4564 = other_center.x;
                let _e4566 = other_center.y;
                let _e4573 = other_idx;
                let _e4580 = state[((_e4573 * 8u) + 1u)];
                let _e4588 = state[((idx * 8u) + 1u)];
                let _e4589 = other_idx;
                let _e4596 = state[((_e4589 * 8u) + 1u)];
                let _e4607 = state[((idx * 8u) + 1u)];
                let _e4608 = other_idx;
                let _e4615 = state[((_e4608 * 8u) + 1u)];
                let _e4627 = state[((idx * 8u) + 1u)];
                let _e4634 = state[((idx * 8u) + 1u)];
                let _e4637 = other_idx;
                let _e4644 = state[((_e4637 * 8u) + 1u)];
                let _e4648 = other_idx;
                let _e4655 = state[((_e4648 * 8u) + 1u)];
                let _e4662 = state[((idx * 8u) + 1u)];
                let _e4671 = other_idx;
                let _e4678 = state[((_e4671 * 8u) + 1u)];
                let _e4685 = state[((idx * 8u) + 1u)];
                let _e4696 = other_center.x;
                let _e4698 = other_center.y;
                let _e4714 = state[((idx * 8u) + 1u)];
                let _e4716 = other_idx;
                let _e4723 = state[((_e4716 * 8u) + 1u)];
                let _e4730 = state[((idx * 8u) + 1u)];
                let _e4735 = other_idx;
                let _e4742 = state[((_e4735 * 8u) + 1u)];
                let _e4749 = state[((idx * 8u) + 1u)];
                let _e4755 = phi_1_;
                let _e4761 = constants.scheme;
                let _e4765 = other_idx;
                let _e4772 = state[((_e4765 * 8u) + 1u)];
                let _e4773 = other_idx;
                let _e4780 = state[((_e4773 * 8u) + 1u)];
                let _e4789 = state[((idx * 8u) + 1u)];
                let _e4793 = other_idx;
                let _e4800 = state[((_e4793 * 8u) + 1u)];
                let _e4807 = state[((idx * 8u) + 1u)];
                let _e4816 = other_idx;
                let _e4823 = state[((_e4816 * 8u) + 1u)];
                let _e4830 = state[((idx * 8u) + 1u)];
                let _e4844 = other_center.x;
                let _e4846 = other_center.y;
                let _e4853 = other_idx;
                let _e4860 = state[((_e4853 * 8u) + 1u)];
                let _e4868 = state[((idx * 8u) + 1u)];
                let _e4869 = other_idx;
                let _e4876 = state[((_e4869 * 8u) + 1u)];
                let _e4886 = state[((idx * 8u) + 1u)];
                let _e4887 = other_idx;
                let _e4894 = state[((_e4887 * 8u) + 1u)];
                let _e4897 = other_idx;
                let _e4904 = state[((_e4897 * 8u) + 1u)];
                let _e4913 = state[((idx * 8u) + 1u)];
                let _e4917 = other_idx;
                let _e4924 = state[((_e4917 * 8u) + 1u)];
                let _e4931 = state[((idx * 8u) + 1u)];
                let _e4940 = other_idx;
                let _e4947 = state[((_e4940 * 8u) + 1u)];
                let _e4954 = state[((idx * 8u) + 1u)];
                let _e4968 = other_center.x;
                let _e4970 = other_center.y;
                let _e4977 = other_idx;
                let _e4984 = state[((_e4977 * 8u) + 1u)];
                let _e4997 = state[((idx * 8u) + 1u)];
                let _e4998 = other_idx;
                let _e5005 = state[((_e4998 * 8u) + 1u)];
                let _e5007 = other_idx;
                let _e5014 = state[((_e5007 * 8u) + 1u)];
                let _e5023 = state[((idx * 8u) + 1u)];
                let _e5027 = other_idx;
                let _e5034 = state[((_e5027 * 8u) + 1u)];
                let _e5041 = state[((idx * 8u) + 1u)];
                let _e5050 = other_idx;
                let _e5057 = state[((_e5050 * 8u) + 1u)];
                let _e5064 = state[((idx * 8u) + 1u)];
                let _e5078 = other_center.x;
                let _e5080 = other_center.y;
                let _e5087 = other_idx;
                let _e5094 = state[((_e5087 * 8u) + 1u)];
                let _e5106 = state[((idx * 8u) + 1u)];
                let _e5107 = other_idx;
                let _e5114 = state[((_e5107 * 8u) + 1u)];
                let _e5116 = other_idx;
                let _e5123 = state[((_e5116 * 8u) + 1u)];
                let _e5132 = state[((idx * 8u) + 1u)];
                let _e5136 = other_idx;
                let _e5143 = state[((_e5136 * 8u) + 1u)];
                let _e5150 = state[((idx * 8u) + 1u)];
                let _e5159 = other_idx;
                let _e5166 = state[((_e5159 * 8u) + 1u)];
                let _e5173 = state[((idx * 8u) + 1u)];
                let _e5187 = other_center.x;
                let _e5189 = other_center.y;
                let _e5196 = other_idx;
                let _e5203 = state[((_e5196 * 8u) + 1u)];
                let _e5217 = state[((idx * 8u) + 1u)];
                let _e5224 = state[((idx * 8u) + 1u)];
                let _e5227 = other_idx;
                let _e5234 = state[((_e5227 * 8u) + 1u)];
                let _e5238 = other_idx;
                let _e5245 = state[((_e5238 * 8u) + 1u)];
                let _e5252 = state[((idx * 8u) + 1u)];
                let _e5261 = other_idx;
                let _e5268 = state[((_e5261 * 8u) + 1u)];
                let _e5275 = state[((idx * 8u) + 1u)];
                let _e5286 = other_center.x;
                let _e5288 = other_center.y;
                let _e5304 = state[((idx * 8u) + 1u)];
                let _e5306 = other_idx;
                let _e5313 = state[((_e5306 * 8u) + 1u)];
                let _e5320 = state[((idx * 8u) + 1u)];
                let _e5324 = other_idx;
                let _e5331 = state[((_e5324 * 8u) + 1u)];
                let _e5338 = state[((idx * 8u) + 1u)];
                let _e5347 = state[((idx * 8u) + 1u)];
                let _e5350 = other_idx;
                let _e5357 = state[((_e5350 * 8u) + 1u)];
                let _e5361 = other_idx;
                let _e5368 = state[((_e5361 * 8u) + 1u)];
                let _e5375 = state[((idx * 8u) + 1u)];
                let _e5384 = other_idx;
                let _e5391 = state[((_e5384 * 8u) + 1u)];
                let _e5398 = state[((idx * 8u) + 1u)];
                let _e5409 = other_center.x;
                let _e5411 = other_center.y;
                let _e5427 = state[((idx * 8u) + 1u)];
                let _e5434 = other_idx;
                let _e5441 = state[((_e5434 * 8u) + 1u)];
                let _e5448 = state[((idx * 8u) + 1u)];
                let _e5456 = state[((idx * 8u) + 1u)];
                let _e5459 = other_idx;
                let _e5466 = state[((_e5459 * 8u) + 1u)];
                let _e5470 = other_idx;
                let _e5477 = state[((_e5470 * 8u) + 1u)];
                let _e5484 = state[((idx * 8u) + 1u)];
                let _e5493 = other_idx;
                let _e5500 = state[((_e5493 * 8u) + 1u)];
                let _e5507 = state[((idx * 8u) + 1u)];
                let _e5518 = other_center.x;
                let _e5520 = other_center.y;
                let _e5536 = state[((idx * 8u) + 1u)];
                let _e5542 = other_idx;
                let _e5549 = state[((_e5542 * 8u) + 1u)];
                let _e5556 = state[((idx * 8u) + 1u)];
                let _e5564 = state[((idx * 8u) + 1u)];
                let _e5567 = other_idx;
                let _e5574 = state[((_e5567 * 8u) + 1u)];
                let _e5578 = other_idx;
                let _e5585 = state[((_e5578 * 8u) + 1u)];
                let _e5592 = state[((idx * 8u) + 1u)];
                let _e5601 = other_idx;
                let _e5608 = state[((_e5601 * 8u) + 1u)];
                let _e5615 = state[((idx * 8u) + 1u)];
                let _e5626 = other_center.x;
                let _e5628 = other_center.y;
                let _e5644 = state[((idx * 8u) + 1u)];
                let _e5652 = phi_1_;
                let _e5658 = constants.scheme;
                let _e5668 = state[((idx * 8u) + 1u)];
                let _e5669 = other_idx;
                let _e5676 = state[((_e5669 * 8u) + 1u)];
                let _e5677 = phi_1_;
                let _e5683 = rhs_1_;
                rhs_1_ = (_e5683 - (_e3270 * (select(select(select(select(select(select(select(_e3277, _e3285, (_e3286 < 0f)), select((_e3297 + dot(vec2<f32>((((_e3305 - _e3312) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3328 - _e3335) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3349, _e3351)))), (_e3362 + dot(vec2<f32>((((_e3370 - _e3377) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3393 - _e3400) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e3419 > 0f)), (_e3425 == 1u)), select(((((_e3436 + (_e3444 * 0.625f)) + (_e3454 * 0.375f)) + (dot(vec2<f32>((((_e3465 - _e3472) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3488 - _e3495) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3509, _e3511))) * 0.125f)) - _e3525), ((((_e3533 + (_e3540 * 0.625f)) + (_e3551 * 0.375f)) + (dot(vec2<f32>((((_e3562 - _e3569) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3585 - _e3592) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e3603, _e3605) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3621), (_e3623 > 0f)), (_e3629 == 2u)), select((_e3640 + min(max(dot(vec2<f32>((((_e3648 - _e3655) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3671 - _e3678) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3692, _e3694))), min((_e3704 - _e3712), 0f)), max((_e3723 - _e3731), 0f))), (_e3743 + min(max(dot(vec2<f32>((((_e3751 - _e3758) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3774 - _e3781) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e3806 - _e3813), 0f)), max((_e3825 - _e3832), 0f))), (_e3838 > 0f)), (_e3844 == 3u)), select((_e3855 + ((((dot(vec2<f32>((((_e3863 - _e3870) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3886 - _e3893) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3907, _e3909))) * abs((_e3919 - _e3927))) / max(abs((_e3937 - _e3945)), (abs(dot(vec2<f32>((((_e3955 - _e3962) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3978 - _e3985) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3999, _e4001)))) + 0.00000001f))) * max(((_e4016 - _e4024) * dot(vec2<f32>((((_e4033 - _e4040) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4056 - _e4063) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e4077, _e4079)))), 0f)) / max(abs(((_e4093 - _e4101) * dot(vec2<f32>((((_e4110 - _e4117) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4133 - _e4140) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e4154, _e4156))))), 0.00000001f))), (_e4172 + ((((dot(vec2<f32>((((_e4180 - _e4187) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4203 - _e4210) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e4235 - _e4242))) / max(abs((_e4253 - _e4260)), (abs(dot(vec2<f32>((((_e4270 - _e4277) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4293 - _e4300) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e4330 - _e4337) * dot(vec2<f32>((((_e4346 - _e4353) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4369 - _e4376) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e4405 - _e4412) * dot(vec2<f32>((((_e4421 - _e4428) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4444 - _e4451) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e4475 > 0f)), (_e4481 == 4u)), select((_e4492 + min(max(((((_e4500 * 0.625f) + (_e4509 * 0.375f)) + (dot(vec2<f32>((((_e4520 - _e4527) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4543 - _e4550) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4564, _e4566))) * 0.125f)) - _e4580), min((_e4588 - _e4596), 0f)), max((_e4607 - _e4615), 0f))), (_e4627 + min(max(((((_e4634 * 0.625f) + (_e4644 * 0.375f)) + (dot(vec2<f32>((((_e4655 - _e4662) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4678 - _e4685) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e4696, _e4698) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4714), min((_e4723 - _e4730), 0f)), max((_e4742 - _e4749), 0f))), (_e4755 > 0f)), (_e4761 == 5u)), select((_e4772 + ((((((((_e4780 * 0.625f) + (_e4789 * 0.375f)) + (dot(vec2<f32>((((_e4800 - _e4807) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4823 - _e4830) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4844, _e4846))) * 0.125f)) - _e4860) * abs((_e4868 - _e4876))) / max(abs((_e4886 - _e4894)), (abs(((((_e4904 * 0.625f) + (_e4913 * 0.375f)) + (dot(vec2<f32>((((_e4924 - _e4931) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4947 - _e4954) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4968, _e4970))) * 0.125f)) - _e4984)) + 0.00000001f))) * max(((_e4997 - _e5005) * ((((_e5014 * 0.625f) + (_e5023 * 0.375f)) + (dot(vec2<f32>((((_e5034 - _e5041) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5057 - _e5064) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e5078, _e5080))) * 0.125f)) - _e5094)), 0f)) / max(abs(((_e5106 - _e5114) * ((((_e5123 * 0.625f) + (_e5132 * 0.375f)) + (dot(vec2<f32>((((_e5143 - _e5150) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5166 - _e5173) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e5187, _e5189))) * 0.125f)) - _e5203))), 0.00000001f))), (_e5217 + ((((((((_e5224 * 0.625f) + (_e5234 * 0.375f)) + (dot(vec2<f32>((((_e5245 - _e5252) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5268 - _e5275) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5286, _e5288) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5304) * abs((_e5313 - _e5320))) / max(abs((_e5331 - _e5338)), (abs(((((_e5347 * 0.625f) + (_e5357 * 0.375f)) + (dot(vec2<f32>((((_e5368 - _e5375) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5391 - _e5398) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5409, _e5411) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5427)) + 0.00000001f))) * max(((_e5441 - _e5448) * ((((_e5456 * 0.625f) + (_e5466 * 0.375f)) + (dot(vec2<f32>((((_e5477 - _e5484) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5500 - _e5507) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5518, _e5520) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5536)), 0f)) / max(abs(((_e5549 - _e5556) * ((((_e5564 * 0.625f) + (_e5574 * 0.375f)) + (dot(vec2<f32>((((_e5585 - _e5592) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5608 - _e5615) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5626, _e5628) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5644))), 0.00000001f))), (_e5652 > 0f)), (_e5658 == 6u)) - select(_e5668, _e5676, (_e5677 < 0f)))));
            } else {
                let _e5691 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e5691 == 1u) {
                    let _e5694 = phi_1_;
                    let _e5697 = diag_1_;
                    diag_1_ = (_e5697 + max(_e5694, 0f));
                    let _e5699 = phi_1_;
                    let _e5708 = bc_value[((face_idx * 3u) + 1u)];
                    let _e5710 = rhs_1_;
                    rhs_1_ = (_e5710 - (min(_e5699, 0f) * _e5708));
                } else {
                    let _e5712 = phi_1_;
                    let _e5713 = diag_1_;
                    diag_1_ = (_e5713 + _e5712);
                }
            }
            let _e5718 = normal.x;
            let _e5726 = state[((idx * 8u) + 2u)];
            let _e5727 = other_idx;
            let _e5734 = state[((_e5727 * 8u) + 2u)];
            let _e5737 = rhs_0_;
            rhs_0_ = (_e5737 - (((0.5f * area) * _e5718) * (_e5726 + _e5734)));
            let _e5742 = normal.y;
            let _e5750 = state[((idx * 8u) + 2u)];
            let _e5751 = other_idx;
            let _e5758 = state[((_e5751 * 8u) + 2u)];
            let _e5761 = rhs_1_;
            rhs_1_ = (_e5761 - (((0.5f * area) * _e5742) * (_e5750 + _e5758)));
            let _e5765 = constants.density;
            let _e5772 = state[((idx * 8u) + 3u)];
            let _e5776 = constants.density;
            let _e5783 = state[((idx * 8u) + 3u)];
            let _e5787 = constants.density;
            let _e5788 = other_idx;
            let _e5795 = state[((_e5788 * 8u) + 3u)];
            let _e5800 = is_boundary;
            let _e5804 = dist;
            let diff_coeff_p = ((select((_e5765 * _e5772), (((_e5776 * _e5783) + (_e5787 * _e5795)) * 0.5f), !(_e5800)) * area) / _e5804);
            let _e5806 = is_boundary;
            if !(_e5806) {
                let _e5809 = diag_2_;
                diag_2_ = (_e5809 + diff_coeff_p);
                let _e5818 = matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)] = (_e5818 - diff_coeff_p);
            } else {
                let _e5826 = bc_kind[((face_idx * 3u) + 2u)];
                if (_e5826 == 1u) {
                    let _e5829 = diag_2_;
                    diag_2_ = (_e5829 + diff_coeff_p);
                    let _e5838 = bc_value[((face_idx * 3u) + 2u)];
                    let _e5840 = rhs_2_;
                    rhs_2_ = (_e5840 + (diff_coeff_p * _e5838));
                } else {
                    let _e5848 = bc_kind[((face_idx * 3u) + 2u)];
                    if (_e5848 == 2u) {
                        let _e5853 = constants.density;
                        let _e5860 = state[((idx * 8u) + 3u)];
                        let _e5864 = constants.density;
                        let _e5871 = state[((idx * 8u) + 3u)];
                        let _e5875 = constants.density;
                        let _e5876 = other_idx;
                        let _e5883 = state[((_e5876 * 8u) + 3u)];
                        let _e5888 = is_boundary;
                        let _e5898 = bc_value[((face_idx * 3u) + 2u)];
                        let _e5901 = rhs_2_;
                        rhs_2_ = (_e5901 + -(((select((_e5853 * _e5860), (((_e5864 * _e5871) + (_e5875 * _e5883)) * 0.5f), !(_e5888)) * area) * _e5898)));
                    }
                }
            }
            let _e5909 = fluxes[((face_idx * 3u) + 2u)];
            phi_2_ = _e5909;
            if (owner != idx) {
                let _e5912 = phi_2_;
                let _e5915 = phi_2_;
                phi_2_ = (_e5915 - (_e5912 * 2f));
            }
            let _e5917 = phi_2_;
            let _e5918 = rhs_2_;
            rhs_2_ = (_e5918 - _e5917);
        }
        continuing {
            let _e5921 = k;
            k = (_e5921 + 1u);
        }
    }
    let _e5930 = diag_0_;
    let _e5931 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)] = (_e5931 + _e5930);
    let _e5939 = rhs_0_;
    rhs[((idx * 3u) + 0u)] = _e5939;
    let _e5947 = diag_1_;
    let _e5948 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)] = (_e5948 + _e5947);
    let _e5956 = rhs_1_;
    rhs[((idx * 3u) + 1u)] = _e5956;
    let _e5964 = diag_2_;
    let _e5965 = matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)] = (_e5965 + _e5964);
    let _e5973 = rhs_2_;
    rhs[((idx * 3u) + 2u)] = _e5973;
    return;
}
"#;
    }
    pub mod generic_coupled_update_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateCompressible::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_compressible :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateCompressible::BindGroup1::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 22u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 22u) + 0u)];
    let _e32 = x[((idx * 8u) + 0u)];
    let _e39 = state[((idx * 22u) + 0u)];
    let _e46 = x[((idx * 8u) + 0u)];
    let _e49 = constants.alpha_u;
    let _e52 = constants.dtau;
    let _e64 = state[((idx * 22u) + 0u)];
    let _e71 = state[((idx * 22u) + 0u)];
    let _e79 = state[((idx * 22u) + 0u)];
    let _e91 = x[((idx * 8u) + 0u)];
    let _e98 = x[((idx * 8u) + 0u)];
    let _e106 = x[((idx * 8u) + 0u)];
    state[((idx * 22u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, select(1f, _e49, (_e52 > 0f))), ((_e64 == _e71) && (abs(_e79) < 340000000000000000000000000000000000000f))), ((_e91 == _e98) && (abs(_e106) < 340000000000000000000000000000000000000f)));
    let _e124 = state[((idx * 22u) + 0u)];
    let _e131 = x[((idx * 8u) + 0u)];
    let _e138 = state[((idx * 22u) + 0u)];
    let _e145 = x[((idx * 8u) + 0u)];
    let _e148 = constants.alpha_u;
    let _e151 = constants.dtau;
    let _e163 = state[((idx * 22u) + 0u)];
    let _e170 = state[((idx * 22u) + 0u)];
    let _e178 = state[((idx * 22u) + 0u)];
    let _e190 = x[((idx * 8u) + 0u)];
    let _e197 = x[((idx * 8u) + 0u)];
    let _e205 = x[((idx * 8u) + 0u)];
    x[((idx * 8u) + 0u)] = select(_e124, select(_e131, mix(_e138, _e145, select(1f, _e148, (_e151 > 0f))), ((_e163 == _e170) && (abs(_e178) < 340000000000000000000000000000000000000f))), ((_e190 == _e197) && (abs(_e205) < 340000000000000000000000000000000000000f)));
    let _e223 = state[((idx * 22u) + 1u)];
    let _e230 = x[((idx * 8u) + 1u)];
    let _e237 = state[((idx * 22u) + 1u)];
    let _e244 = x[((idx * 8u) + 1u)];
    let _e247 = constants.alpha_u;
    let _e250 = constants.dtau;
    let _e262 = state[((idx * 22u) + 1u)];
    let _e269 = state[((idx * 22u) + 1u)];
    let _e277 = state[((idx * 22u) + 1u)];
    let _e289 = x[((idx * 8u) + 1u)];
    let _e296 = x[((idx * 8u) + 1u)];
    let _e304 = x[((idx * 8u) + 1u)];
    state[((idx * 22u) + 1u)] = select(_e223, select(_e230, mix(_e237, _e244, select(1f, _e247, (_e250 > 0f))), ((_e262 == _e269) && (abs(_e277) < 340000000000000000000000000000000000000f))), ((_e289 == _e296) && (abs(_e304) < 340000000000000000000000000000000000000f)));
    let _e322 = state[((idx * 22u) + 1u)];
    let _e329 = x[((idx * 8u) + 1u)];
    let _e336 = state[((idx * 22u) + 1u)];
    let _e343 = x[((idx * 8u) + 1u)];
    let _e346 = constants.alpha_u;
    let _e349 = constants.dtau;
    let _e361 = state[((idx * 22u) + 1u)];
    let _e368 = state[((idx * 22u) + 1u)];
    let _e376 = state[((idx * 22u) + 1u)];
    let _e388 = x[((idx * 8u) + 1u)];
    let _e395 = x[((idx * 8u) + 1u)];
    let _e403 = x[((idx * 8u) + 1u)];
    x[((idx * 8u) + 1u)] = select(_e322, select(_e329, mix(_e336, _e343, select(1f, _e346, (_e349 > 0f))), ((_e361 == _e368) && (abs(_e376) < 340000000000000000000000000000000000000f))), ((_e388 == _e395) && (abs(_e403) < 340000000000000000000000000000000000000f)));
    let _e421 = state[((idx * 22u) + 2u)];
    let _e428 = x[((idx * 8u) + 2u)];
    let _e435 = state[((idx * 22u) + 2u)];
    let _e442 = x[((idx * 8u) + 2u)];
    let _e445 = constants.alpha_u;
    let _e448 = constants.dtau;
    let _e460 = state[((idx * 22u) + 2u)];
    let _e467 = state[((idx * 22u) + 2u)];
    let _e475 = state[((idx * 22u) + 2u)];
    let _e487 = x[((idx * 8u) + 2u)];
    let _e494 = x[((idx * 8u) + 2u)];
    let _e502 = x[((idx * 8u) + 2u)];
    state[((idx * 22u) + 2u)] = select(_e421, select(_e428, mix(_e435, _e442, select(1f, _e445, (_e448 > 0f))), ((_e460 == _e467) && (abs(_e475) < 340000000000000000000000000000000000000f))), ((_e487 == _e494) && (abs(_e502) < 340000000000000000000000000000000000000f)));
    let _e520 = state[((idx * 22u) + 2u)];
    let _e527 = x[((idx * 8u) + 2u)];
    let _e534 = state[((idx * 22u) + 2u)];
    let _e541 = x[((idx * 8u) + 2u)];
    let _e544 = constants.alpha_u;
    let _e547 = constants.dtau;
    let _e559 = state[((idx * 22u) + 2u)];
    let _e566 = state[((idx * 22u) + 2u)];
    let _e574 = state[((idx * 22u) + 2u)];
    let _e586 = x[((idx * 8u) + 2u)];
    let _e593 = x[((idx * 8u) + 2u)];
    let _e601 = x[((idx * 8u) + 2u)];
    x[((idx * 8u) + 2u)] = select(_e520, select(_e527, mix(_e534, _e541, select(1f, _e544, (_e547 > 0f))), ((_e559 == _e566) && (abs(_e574) < 340000000000000000000000000000000000000f))), ((_e586 == _e593) && (abs(_e601) < 340000000000000000000000000000000000000f)));
    let _e619 = state[((idx * 22u) + 7u)];
    let _e626 = x[((idx * 8u) + 3u)];
    let _e633 = state[((idx * 22u) + 7u)];
    let _e640 = x[((idx * 8u) + 3u)];
    let _e643 = constants.alpha_u;
    let _e646 = constants.dtau;
    let _e658 = state[((idx * 22u) + 7u)];
    let _e665 = state[((idx * 22u) + 7u)];
    let _e673 = state[((idx * 22u) + 7u)];
    let _e685 = x[((idx * 8u) + 3u)];
    let _e692 = x[((idx * 8u) + 3u)];
    let _e700 = x[((idx * 8u) + 3u)];
    state[((idx * 22u) + 7u)] = select(_e619, select(_e626, mix(_e633, _e640, select(1f, _e643, (_e646 > 0f))), ((_e658 == _e665) && (abs(_e673) < 340000000000000000000000000000000000000f))), ((_e685 == _e692) && (abs(_e700) < 340000000000000000000000000000000000000f)));
    let _e718 = state[((idx * 22u) + 7u)];
    let _e725 = x[((idx * 8u) + 3u)];
    let _e732 = state[((idx * 22u) + 7u)];
    let _e739 = x[((idx * 8u) + 3u)];
    let _e742 = constants.alpha_u;
    let _e745 = constants.dtau;
    let _e757 = state[((idx * 22u) + 7u)];
    let _e764 = state[((idx * 22u) + 7u)];
    let _e772 = state[((idx * 22u) + 7u)];
    let _e784 = x[((idx * 8u) + 3u)];
    let _e791 = x[((idx * 8u) + 3u)];
    let _e799 = x[((idx * 8u) + 3u)];
    x[((idx * 8u) + 3u)] = select(_e718, select(_e725, mix(_e732, _e739, select(1f, _e742, (_e745 > 0f))), ((_e757 == _e764) && (abs(_e772) < 340000000000000000000000000000000000000f))), ((_e784 == _e791) && (abs(_e799) < 340000000000000000000000000000000000000f)));
    let _e817 = state[((idx * 22u) + 10u)];
    let _e824 = x[((idx * 8u) + 4u)];
    let _e831 = state[((idx * 22u) + 10u)];
    let _e838 = x[((idx * 8u) + 4u)];
    let _e841 = constants.alpha_u;
    let _e844 = constants.dtau;
    let _e856 = state[((idx * 22u) + 10u)];
    let _e863 = state[((idx * 22u) + 10u)];
    let _e871 = state[((idx * 22u) + 10u)];
    let _e883 = x[((idx * 8u) + 4u)];
    let _e890 = x[((idx * 8u) + 4u)];
    let _e898 = x[((idx * 8u) + 4u)];
    state[((idx * 22u) + 10u)] = select(_e817, select(_e824, mix(_e831, _e838, select(1f, _e841, (_e844 > 0f))), ((_e856 == _e863) && (abs(_e871) < 340000000000000000000000000000000000000f))), ((_e883 == _e890) && (abs(_e898) < 340000000000000000000000000000000000000f)));
    let _e916 = state[((idx * 22u) + 10u)];
    let _e923 = x[((idx * 8u) + 4u)];
    let _e930 = state[((idx * 22u) + 10u)];
    let _e937 = x[((idx * 8u) + 4u)];
    let _e940 = constants.alpha_u;
    let _e943 = constants.dtau;
    let _e955 = state[((idx * 22u) + 10u)];
    let _e962 = state[((idx * 22u) + 10u)];
    let _e970 = state[((idx * 22u) + 10u)];
    let _e982 = x[((idx * 8u) + 4u)];
    let _e989 = x[((idx * 8u) + 4u)];
    let _e997 = x[((idx * 8u) + 4u)];
    x[((idx * 8u) + 4u)] = select(_e916, select(_e923, mix(_e930, _e937, select(1f, _e940, (_e943 > 0f))), ((_e955 == _e962) && (abs(_e970) < 340000000000000000000000000000000000000f))), ((_e982 == _e989) && (abs(_e997) < 340000000000000000000000000000000000000f)));
    let _e1015 = state[((idx * 22u) + 11u)];
    let _e1022 = x[((idx * 8u) + 5u)];
    let _e1029 = state[((idx * 22u) + 11u)];
    let _e1036 = x[((idx * 8u) + 5u)];
    let _e1039 = constants.alpha_u;
    let _e1042 = constants.dtau;
    let _e1054 = state[((idx * 22u) + 11u)];
    let _e1061 = state[((idx * 22u) + 11u)];
    let _e1069 = state[((idx * 22u) + 11u)];
    let _e1081 = x[((idx * 8u) + 5u)];
    let _e1088 = x[((idx * 8u) + 5u)];
    let _e1096 = x[((idx * 8u) + 5u)];
    state[((idx * 22u) + 11u)] = select(_e1015, select(_e1022, mix(_e1029, _e1036, select(1f, _e1039, (_e1042 > 0f))), ((_e1054 == _e1061) && (abs(_e1069) < 340000000000000000000000000000000000000f))), ((_e1081 == _e1088) && (abs(_e1096) < 340000000000000000000000000000000000000f)));
    let _e1114 = state[((idx * 22u) + 11u)];
    let _e1121 = x[((idx * 8u) + 5u)];
    let _e1128 = state[((idx * 22u) + 11u)];
    let _e1135 = x[((idx * 8u) + 5u)];
    let _e1138 = constants.alpha_u;
    let _e1141 = constants.dtau;
    let _e1153 = state[((idx * 22u) + 11u)];
    let _e1160 = state[((idx * 22u) + 11u)];
    let _e1168 = state[((idx * 22u) + 11u)];
    let _e1180 = x[((idx * 8u) + 5u)];
    let _e1187 = x[((idx * 8u) + 5u)];
    let _e1195 = x[((idx * 8u) + 5u)];
    x[((idx * 8u) + 5u)] = select(_e1114, select(_e1121, mix(_e1128, _e1135, select(1f, _e1138, (_e1141 > 0f))), ((_e1153 == _e1160) && (abs(_e1168) < 340000000000000000000000000000000000000f))), ((_e1180 == _e1187) && (abs(_e1195) < 340000000000000000000000000000000000000f)));
    let _e1213 = state[((idx * 22u) + 8u)];
    let _e1220 = x[((idx * 8u) + 6u)];
    let _e1227 = state[((idx * 22u) + 8u)];
    let _e1234 = x[((idx * 8u) + 6u)];
    let _e1237 = constants.alpha_p;
    let _e1240 = constants.dtau;
    let _e1252 = state[((idx * 22u) + 8u)];
    let _e1259 = state[((idx * 22u) + 8u)];
    let _e1267 = state[((idx * 22u) + 8u)];
    let _e1279 = x[((idx * 8u) + 6u)];
    let _e1286 = x[((idx * 8u) + 6u)];
    let _e1294 = x[((idx * 8u) + 6u)];
    state[((idx * 22u) + 8u)] = select(_e1213, select(_e1220, mix(_e1227, _e1234, select(1f, _e1237, (_e1240 > 0f))), ((_e1252 == _e1259) && (abs(_e1267) < 340000000000000000000000000000000000000f))), ((_e1279 == _e1286) && (abs(_e1294) < 340000000000000000000000000000000000000f)));
    let _e1312 = state[((idx * 22u) + 8u)];
    let _e1319 = x[((idx * 8u) + 6u)];
    let _e1326 = state[((idx * 22u) + 8u)];
    let _e1333 = x[((idx * 8u) + 6u)];
    let _e1336 = constants.alpha_p;
    let _e1339 = constants.dtau;
    let _e1351 = state[((idx * 22u) + 8u)];
    let _e1358 = state[((idx * 22u) + 8u)];
    let _e1366 = state[((idx * 22u) + 8u)];
    let _e1378 = x[((idx * 8u) + 6u)];
    let _e1385 = x[((idx * 8u) + 6u)];
    let _e1393 = x[((idx * 8u) + 6u)];
    x[((idx * 8u) + 6u)] = select(_e1312, select(_e1319, mix(_e1326, _e1333, select(1f, _e1336, (_e1339 > 0f))), ((_e1351 == _e1358) && (abs(_e1366) < 340000000000000000000000000000000000000f))), ((_e1378 == _e1385) && (abs(_e1393) < 340000000000000000000000000000000000000f)));
    let _e1411 = state[((idx * 22u) + 9u)];
    let _e1418 = x[((idx * 8u) + 7u)];
    let _e1425 = state[((idx * 22u) + 9u)];
    let _e1432 = x[((idx * 8u) + 7u)];
    let _e1435 = constants.alpha_u;
    let _e1438 = constants.dtau;
    let _e1450 = state[((idx * 22u) + 9u)];
    let _e1457 = state[((idx * 22u) + 9u)];
    let _e1465 = state[((idx * 22u) + 9u)];
    let _e1477 = x[((idx * 8u) + 7u)];
    let _e1484 = x[((idx * 8u) + 7u)];
    let _e1492 = x[((idx * 8u) + 7u)];
    state[((idx * 22u) + 9u)] = select(_e1411, select(_e1418, mix(_e1425, _e1432, select(1f, _e1435, (_e1438 > 0f))), ((_e1450 == _e1457) && (abs(_e1465) < 340000000000000000000000000000000000000f))), ((_e1477 == _e1484) && (abs(_e1492) < 340000000000000000000000000000000000000f)));
    let _e1510 = state[((idx * 22u) + 9u)];
    let _e1517 = x[((idx * 8u) + 7u)];
    let _e1524 = state[((idx * 22u) + 9u)];
    let _e1531 = x[((idx * 8u) + 7u)];
    let _e1534 = constants.alpha_u;
    let _e1537 = constants.dtau;
    let _e1549 = state[((idx * 22u) + 9u)];
    let _e1556 = state[((idx * 22u) + 9u)];
    let _e1564 = state[((idx * 22u) + 9u)];
    let _e1576 = x[((idx * 8u) + 7u)];
    let _e1583 = x[((idx * 8u) + 7u)];
    let _e1591 = x[((idx * 8u) + 7u)];
    x[((idx * 8u) + 7u)] = select(_e1510, select(_e1517, mix(_e1524, _e1531, select(1f, _e1534, (_e1537 > 0f))), ((_e1549 == _e1556) && (abs(_e1564) < 340000000000000000000000000000000000000f))), ((_e1576 == _e1583) && (abs(_e1591) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_generic_diffusion_demo :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 1u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 1u) + 0u)];
    let _e32 = x[((idx * 1u) + 0u)];
    let _e39 = state[((idx * 1u) + 0u)];
    let _e46 = x[((idx * 1u) + 0u)];
    let _e55 = state[((idx * 1u) + 0u)];
    let _e62 = state[((idx * 1u) + 0u)];
    let _e70 = state[((idx * 1u) + 0u)];
    let _e82 = x[((idx * 1u) + 0u)];
    let _e89 = x[((idx * 1u) + 0u)];
    let _e97 = x[((idx * 1u) + 0u)];
    state[((idx * 1u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, 1f), ((_e55 == _e62) && (abs(_e70) < 340000000000000000000000000000000000000f))), ((_e82 == _e89) && (abs(_e97) < 340000000000000000000000000000000000000f)));
    let _e115 = state[((idx * 1u) + 0u)];
    let _e122 = x[((idx * 1u) + 0u)];
    let _e129 = state[((idx * 1u) + 0u)];
    let _e136 = x[((idx * 1u) + 0u)];
    let _e145 = state[((idx * 1u) + 0u)];
    let _e152 = state[((idx * 1u) + 0u)];
    let _e160 = state[((idx * 1u) + 0u)];
    let _e172 = x[((idx * 1u) + 0u)];
    let _e179 = x[((idx * 1u) + 0u)];
    let _e187 = x[((idx * 1u) + 0u)];
    x[((idx * 1u) + 0u)] = select(_e115, select(_e122, mix(_e129, _e136, 1f), ((_e145 == _e152) && (abs(_e160) < 340000000000000000000000000000000000000f))), ((_e172 == _e179) && (abs(_e187) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_generic_diffusion_demo_neumann.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 1u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 1u) + 0u)];
    let _e32 = x[((idx * 1u) + 0u)];
    let _e39 = state[((idx * 1u) + 0u)];
    let _e46 = x[((idx * 1u) + 0u)];
    let _e55 = state[((idx * 1u) + 0u)];
    let _e62 = state[((idx * 1u) + 0u)];
    let _e70 = state[((idx * 1u) + 0u)];
    let _e82 = x[((idx * 1u) + 0u)];
    let _e89 = x[((idx * 1u) + 0u)];
    let _e97 = x[((idx * 1u) + 0u)];
    state[((idx * 1u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, 1f), ((_e55 == _e62) && (abs(_e70) < 340000000000000000000000000000000000000f))), ((_e82 == _e89) && (abs(_e97) < 340000000000000000000000000000000000000f)));
    let _e115 = state[((idx * 1u) + 0u)];
    let _e122 = x[((idx * 1u) + 0u)];
    let _e129 = state[((idx * 1u) + 0u)];
    let _e136 = x[((idx * 1u) + 0u)];
    let _e145 = state[((idx * 1u) + 0u)];
    let _e152 = state[((idx * 1u) + 0u)];
    let _e160 = state[((idx * 1u) + 0u)];
    let _e172 = x[((idx * 1u) + 0u)];
    let _e179 = x[((idx * 1u) + 0u)];
    let _e187 = x[((idx * 1u) + 0u)];
    x[((idx * 1u) + 0u)] = select(_e115, select(_e122, mix(_e129, _e136, 1f), ((_e145 == _e152) && (abs(_e160) < 340000000000000000000000000000000000000f))), ((_e172 == _e179) && (abs(_e187) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 8u) + 0u)];
    let _e32 = x[((idx * 3u) + 0u)];
    let _e39 = state[((idx * 8u) + 0u)];
    let _e46 = x[((idx * 3u) + 0u)];
    let _e49 = constants.alpha_u;
    let _e57 = state[((idx * 8u) + 0u)];
    let _e64 = state[((idx * 8u) + 0u)];
    let _e72 = state[((idx * 8u) + 0u)];
    let _e84 = x[((idx * 3u) + 0u)];
    let _e91 = x[((idx * 3u) + 0u)];
    let _e99 = x[((idx * 3u) + 0u)];
    state[((idx * 8u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, _e49), ((_e57 == _e64) && (abs(_e72) < 340000000000000000000000000000000000000f))), ((_e84 == _e91) && (abs(_e99) < 340000000000000000000000000000000000000f)));
    let _e117 = state[((idx * 8u) + 0u)];
    let _e124 = x[((idx * 3u) + 0u)];
    let _e131 = state[((idx * 8u) + 0u)];
    let _e138 = x[((idx * 3u) + 0u)];
    let _e141 = constants.alpha_u;
    let _e149 = state[((idx * 8u) + 0u)];
    let _e156 = state[((idx * 8u) + 0u)];
    let _e164 = state[((idx * 8u) + 0u)];
    let _e176 = x[((idx * 3u) + 0u)];
    let _e183 = x[((idx * 3u) + 0u)];
    let _e191 = x[((idx * 3u) + 0u)];
    x[((idx * 3u) + 0u)] = select(_e117, select(_e124, mix(_e131, _e138, _e141), ((_e149 == _e156) && (abs(_e164) < 340000000000000000000000000000000000000f))), ((_e176 == _e183) && (abs(_e191) < 340000000000000000000000000000000000000f)));
    let _e209 = state[((idx * 8u) + 1u)];
    let _e216 = x[((idx * 3u) + 1u)];
    let _e223 = state[((idx * 8u) + 1u)];
    let _e230 = x[((idx * 3u) + 1u)];
    let _e233 = constants.alpha_u;
    let _e241 = state[((idx * 8u) + 1u)];
    let _e248 = state[((idx * 8u) + 1u)];
    let _e256 = state[((idx * 8u) + 1u)];
    let _e268 = x[((idx * 3u) + 1u)];
    let _e275 = x[((idx * 3u) + 1u)];
    let _e283 = x[((idx * 3u) + 1u)];
    state[((idx * 8u) + 1u)] = select(_e209, select(_e216, mix(_e223, _e230, _e233), ((_e241 == _e248) && (abs(_e256) < 340000000000000000000000000000000000000f))), ((_e268 == _e275) && (abs(_e283) < 340000000000000000000000000000000000000f)));
    let _e301 = state[((idx * 8u) + 1u)];
    let _e308 = x[((idx * 3u) + 1u)];
    let _e315 = state[((idx * 8u) + 1u)];
    let _e322 = x[((idx * 3u) + 1u)];
    let _e325 = constants.alpha_u;
    let _e333 = state[((idx * 8u) + 1u)];
    let _e340 = state[((idx * 8u) + 1u)];
    let _e348 = state[((idx * 8u) + 1u)];
    let _e360 = x[((idx * 3u) + 1u)];
    let _e367 = x[((idx * 3u) + 1u)];
    let _e375 = x[((idx * 3u) + 1u)];
    x[((idx * 3u) + 1u)] = select(_e301, select(_e308, mix(_e315, _e322, _e325), ((_e333 == _e340) && (abs(_e348) < 340000000000000000000000000000000000000f))), ((_e360 == _e367) && (abs(_e375) < 340000000000000000000000000000000000000f)));
    let _e393 = state[((idx * 8u) + 2u)];
    let _e400 = x[((idx * 3u) + 2u)];
    let _e407 = state[((idx * 8u) + 2u)];
    let _e414 = x[((idx * 3u) + 2u)];
    let _e417 = constants.alpha_p;
    let _e425 = state[((idx * 8u) + 2u)];
    let _e432 = state[((idx * 8u) + 2u)];
    let _e440 = state[((idx * 8u) + 2u)];
    let _e452 = x[((idx * 3u) + 2u)];
    let _e459 = x[((idx * 3u) + 2u)];
    let _e467 = x[((idx * 3u) + 2u)];
    state[((idx * 8u) + 2u)] = select(_e393, select(_e400, mix(_e407, _e414, _e417), ((_e425 == _e432) && (abs(_e440) < 340000000000000000000000000000000000000f))), ((_e452 == _e459) && (abs(_e467) < 340000000000000000000000000000000000000f)));
    let _e485 = state[((idx * 8u) + 2u)];
    let _e492 = x[((idx * 3u) + 2u)];
    let _e499 = state[((idx * 8u) + 2u)];
    let _e506 = x[((idx * 3u) + 2u)];
    let _e509 = constants.alpha_p;
    let _e517 = state[((idx * 8u) + 2u)];
    let _e524 = state[((idx * 8u) + 2u)];
    let _e532 = state[((idx * 8u) + 2u)];
    let _e544 = x[((idx * 3u) + 2u)];
    let _e551 = x[((idx * 3u) + 2u)];
    let _e559 = x[((idx * 3u) + 2u)];
    x[((idx * 3u) + 2u)] = select(_e485, select(_e492, mix(_e499, _e506, _e509), ((_e517 == _e524) && (abs(_e532) < 340000000000000000000000000000000000000f))), ((_e544 == _e551) && (abs(_e559) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod packed_state_gradients_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsCompressible::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsCompressible::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_compressible :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsCompressible::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedPackedStateGradientsCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_1_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_2_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_3_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_4_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_5_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_6_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_7_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 22u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 22u) + 0u)];
            let _e125 = state[((idx * 22u) + 0u)];
            let _e132 = bc_value[((face_idx * 8u) + 0u)];
            let _e139 = bc_kind[((face_idx * 8u) + 0u)];
            let _e149 = state[((idx * 22u) + 0u)];
            let _e156 = bc_value[((face_idx * 8u) + 0u)];
            let _e165 = bc_kind[((face_idx * 8u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
            let _e177 = normal_vec;
            let _e184 = state[((idx * 22u) + 1u)];
            let _e185 = lambda;
            let _e187 = other_idx;
            let _e194 = state[((_e187 * 22u) + 1u)];
            let _e201 = state[((idx * 22u) + 1u)];
            let _e208 = bc_value[((face_idx * 8u) + 1u)];
            let _e215 = bc_kind[((face_idx * 8u) + 1u)];
            let _e225 = state[((idx * 22u) + 1u)];
            let _e232 = bc_value[((face_idx * 8u) + 1u)];
            let _e241 = bc_kind[((face_idx * 8u) + 1u)];
            let _e251 = grad_acc_1_;
            grad_acc_1_ = (_e251 + ((_e177 * ((_e184 * _e185) + (select(_e194, select(select(_e201, _e208, (_e215 == 1u)), (_e225 + (_e232 * d_own)), (_e241 == 2u)), is_boundary) * lambda_other))) * area));
            let _e253 = normal_vec;
            let _e260 = state[((idx * 22u) + 2u)];
            let _e261 = lambda;
            let _e263 = other_idx;
            let _e270 = state[((_e263 * 22u) + 2u)];
            let _e277 = state[((idx * 22u) + 2u)];
            let _e284 = bc_value[((face_idx * 8u) + 2u)];
            let _e291 = bc_kind[((face_idx * 8u) + 2u)];
            let _e301 = state[((idx * 22u) + 2u)];
            let _e308 = bc_value[((face_idx * 8u) + 2u)];
            let _e317 = bc_kind[((face_idx * 8u) + 2u)];
            let _e327 = grad_acc_2_;
            grad_acc_2_ = (_e327 + ((_e253 * ((_e260 * _e261) + (select(_e270, select(select(_e277, _e284, (_e291 == 1u)), (_e301 + (_e308 * d_own)), (_e317 == 2u)), is_boundary) * lambda_other))) * area));
            let _e329 = normal_vec;
            let _e336 = state[((idx * 22u) + 3u)];
            let _e337 = lambda;
            let _e339 = other_idx;
            let _e346 = state[((_e339 * 22u) + 3u)];
            let _e353 = state[((idx * 22u) + 3u)];
            let _e360 = bc_value[((face_idx * 8u) + 3u)];
            let _e367 = bc_kind[((face_idx * 8u) + 3u)];
            let _e377 = state[((idx * 22u) + 3u)];
            let _e384 = bc_value[((face_idx * 8u) + 3u)];
            let _e393 = bc_kind[((face_idx * 8u) + 3u)];
            let _e403 = grad_acc_3_;
            grad_acc_3_ = (_e403 + ((_e329 * ((_e336 * _e337) + (select(_e346, select(select(_e353, _e360, (_e367 == 1u)), (_e377 + (_e384 * d_own)), (_e393 == 2u)), is_boundary) * lambda_other))) * area));
            let _e405 = normal_vec;
            let _e412 = state[((idx * 22u) + 4u)];
            let _e413 = lambda;
            let _e415 = other_idx;
            let _e422 = state[((_e415 * 22u) + 4u)];
            let _e429 = state[((idx * 22u) + 4u)];
            let _e436 = bc_value[((face_idx * 8u) + 4u)];
            let _e443 = bc_kind[((face_idx * 8u) + 4u)];
            let _e453 = state[((idx * 22u) + 4u)];
            let _e460 = bc_value[((face_idx * 8u) + 4u)];
            let _e469 = bc_kind[((face_idx * 8u) + 4u)];
            let _e479 = grad_acc_4_;
            grad_acc_4_ = (_e479 + ((_e405 * ((_e412 * _e413) + (select(_e422, select(select(_e429, _e436, (_e443 == 1u)), (_e453 + (_e460 * d_own)), (_e469 == 2u)), is_boundary) * lambda_other))) * area));
            let _e481 = normal_vec;
            let _e488 = state[((idx * 22u) + 5u)];
            let _e489 = lambda;
            let _e491 = other_idx;
            let _e498 = state[((_e491 * 22u) + 5u)];
            let _e505 = state[((idx * 22u) + 5u)];
            let _e512 = bc_value[((face_idx * 8u) + 5u)];
            let _e519 = bc_kind[((face_idx * 8u) + 5u)];
            let _e529 = state[((idx * 22u) + 5u)];
            let _e536 = bc_value[((face_idx * 8u) + 5u)];
            let _e545 = bc_kind[((face_idx * 8u) + 5u)];
            let _e555 = grad_acc_5_;
            grad_acc_5_ = (_e555 + ((_e481 * ((_e488 * _e489) + (select(_e498, select(select(_e505, _e512, (_e519 == 1u)), (_e529 + (_e536 * d_own)), (_e545 == 2u)), is_boundary) * lambda_other))) * area));
            let _e557 = normal_vec;
            let _e564 = state[((idx * 22u) + 6u)];
            let _e565 = lambda;
            let _e567 = other_idx;
            let _e574 = state[((_e567 * 22u) + 6u)];
            let _e581 = state[((idx * 22u) + 6u)];
            let _e588 = bc_value[((face_idx * 8u) + 6u)];
            let _e595 = bc_kind[((face_idx * 8u) + 6u)];
            let _e605 = state[((idx * 22u) + 6u)];
            let _e612 = bc_value[((face_idx * 8u) + 6u)];
            let _e621 = bc_kind[((face_idx * 8u) + 6u)];
            let _e631 = grad_acc_6_;
            grad_acc_6_ = (_e631 + ((_e557 * ((_e564 * _e565) + (select(_e574, select(select(_e581, _e588, (_e595 == 1u)), (_e605 + (_e612 * d_own)), (_e621 == 2u)), is_boundary) * lambda_other))) * area));
            let _e633 = normal_vec;
            let _e640 = state[((idx * 22u) + 7u)];
            let _e641 = lambda;
            let _e643 = other_idx;
            let _e650 = state[((_e643 * 22u) + 7u)];
            let _e657 = state[((idx * 22u) + 7u)];
            let _e664 = bc_value[((face_idx * 8u) + 7u)];
            let _e671 = bc_kind[((face_idx * 8u) + 7u)];
            let _e681 = state[((idx * 22u) + 7u)];
            let _e688 = bc_value[((face_idx * 8u) + 7u)];
            let _e697 = bc_kind[((face_idx * 8u) + 7u)];
            let _e707 = grad_acc_7_;
            grad_acc_7_ = (_e707 + ((_e633 * ((_e640 * _e641) + (select(_e650, select(select(_e657, _e664, (_e671 == 1u)), (_e681 + (_e688 * d_own)), (_e697 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e710 = k;
            k = (_e710 + 1u);
        }
    }
    let _e712 = grad_acc_0_;
    let grad_out_0_ = ((_e712 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 22u) + 0u)].y = grad_out_0_.y;
    let _e735 = grad_acc_1_;
    let grad_out_1_ = ((_e735 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 1u)].x = grad_out_1_.x;
    grad_state[((idx * 22u) + 1u)].y = grad_out_1_.y;
    let _e758 = grad_acc_2_;
    let grad_out_2_ = ((_e758 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 2u)].x = grad_out_2_.x;
    grad_state[((idx * 22u) + 2u)].y = grad_out_2_.y;
    let _e781 = grad_acc_3_;
    let grad_out_3_ = ((_e781 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 3u)].x = grad_out_3_.x;
    grad_state[((idx * 22u) + 3u)].y = grad_out_3_.y;
    let _e804 = grad_acc_4_;
    let grad_out_4_ = ((_e804 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 4u)].x = grad_out_4_.x;
    grad_state[((idx * 22u) + 4u)].y = grad_out_4_.y;
    let _e827 = grad_acc_5_;
    let grad_out_5_ = ((_e827 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 5u)].x = grad_out_5_.x;
    grad_state[((idx * 22u) + 5u)].y = grad_out_5_.y;
    let _e850 = grad_acc_6_;
    let grad_out_6_ = ((_e850 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 6u)].x = grad_out_6_.x;
    grad_state[((idx * 22u) + 6u)].y = grad_out_6_.y;
    let _e873 = grad_acc_7_;
    let grad_out_7_ = ((_e873 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 7u)].x = grad_out_7_.x;
    grad_state[((idx * 22u) + 7u)].y = grad_out_7_.y;
    return;
}
"#;
    }
    pub mod packed_state_gradients_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_generic_diffusion_demo :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 1u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 1u) + 0u)];
            let _e125 = state[((idx * 1u) + 0u)];
            let _e132 = bc_value[((face_idx * 1u) + 0u)];
            let _e139 = bc_kind[((face_idx * 1u) + 0u)];
            let _e149 = state[((idx * 1u) + 0u)];
            let _e156 = bc_value[((face_idx * 1u) + 0u)];
            let _e165 = bc_kind[((face_idx * 1u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e178 = k;
            k = (_e178 + 1u);
        }
    }
    let _e180 = grad_acc_0_;
    let grad_out_0_ = ((_e180 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 1u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 1u) + 0u)].y = grad_out_0_.y;
    return;
}
"#;
    }
    pub mod packed_state_gradients_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_generic_diffusion_demo_neumann.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 1u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 1u) + 0u)];
            let _e125 = state[((idx * 1u) + 0u)];
            let _e132 = bc_value[((face_idx * 1u) + 0u)];
            let _e139 = bc_kind[((face_idx * 1u) + 0u)];
            let _e149 = state[((idx * 1u) + 0u)];
            let _e156 = bc_value[((face_idx * 1u) + 0u)];
            let _e165 = bc_kind[((face_idx * 1u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e178 = k;
            k = (_e178 + 1u);
        }
    }
    let _e180 = grad_acc_0_;
    let grad_out_0_ = ((_e180 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 1u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 1u) + 0u)].y = grad_out_0_.y;
    return;
}
"#;
    }
    pub mod packed_state_gradients_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_incompressible_momentum :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_1_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_2_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 8u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 8u) + 0u)];
            let _e125 = state[((idx * 8u) + 0u)];
            let _e132 = bc_value[((face_idx * 3u) + 0u)];
            let _e139 = bc_kind[((face_idx * 3u) + 0u)];
            let _e149 = state[((idx * 8u) + 0u)];
            let _e156 = bc_value[((face_idx * 3u) + 0u)];
            let _e165 = bc_kind[((face_idx * 3u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
            let _e177 = normal_vec;
            let _e184 = state[((idx * 8u) + 1u)];
            let _e185 = lambda;
            let _e187 = other_idx;
            let _e194 = state[((_e187 * 8u) + 1u)];
            let _e201 = state[((idx * 8u) + 1u)];
            let _e208 = bc_value[((face_idx * 3u) + 1u)];
            let _e215 = bc_kind[((face_idx * 3u) + 1u)];
            let _e225 = state[((idx * 8u) + 1u)];
            let _e232 = bc_value[((face_idx * 3u) + 1u)];
            let _e241 = bc_kind[((face_idx * 3u) + 1u)];
            let _e251 = grad_acc_1_;
            grad_acc_1_ = (_e251 + ((_e177 * ((_e184 * _e185) + (select(_e194, select(select(_e201, _e208, (_e215 == 1u)), (_e225 + (_e232 * d_own)), (_e241 == 2u)), is_boundary) * lambda_other))) * area));
            let _e253 = normal_vec;
            let _e260 = state[((idx * 8u) + 2u)];
            let _e261 = lambda;
            let _e263 = other_idx;
            let _e270 = state[((_e263 * 8u) + 2u)];
            let _e277 = state[((idx * 8u) + 2u)];
            let _e284 = bc_value[((face_idx * 3u) + 2u)];
            let _e291 = bc_kind[((face_idx * 3u) + 2u)];
            let _e301 = state[((idx * 8u) + 2u)];
            let _e308 = bc_value[((face_idx * 3u) + 2u)];
            let _e317 = bc_kind[((face_idx * 3u) + 2u)];
            let _e327 = grad_acc_2_;
            grad_acc_2_ = (_e327 + ((_e253 * ((_e260 * _e261) + (select(_e270, select(select(_e277, _e284, (_e291 == 1u)), (_e301 + (_e308 * d_own)), (_e317 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e330 = k;
            k = (_e330 + 1u);
        }
    }
    let _e332 = grad_acc_0_;
    let grad_out_0_ = ((_e332 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 8u) + 0u)].y = grad_out_0_.y;
    let _e355 = grad_acc_1_;
    let grad_out_1_ = ((_e355 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 1u)].x = grad_out_1_.x;
    grad_state[((idx * 8u) + 1u)].y = grad_out_1_.y;
    let _e378 = grad_acc_2_;
    let grad_out_2_ = ((_e378 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 2u)].x = grad_out_2_.x;
    grad_state[((idx * 8u) + 2u)].y = grad_out_2_.y;
    return;
}
"#;
    }
    pub mod rhie_chow_correct_velocity_delta_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: rhie_chow_correct_velocity_delta_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum::PipelineLayout",
                ),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rhie_chow_correct_velocity_delta_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let base = (idx * 8u);
    let d_p = state[(base + 3u)];
    let grad_px = state[(base + 4u)];
    let grad_py = state[(base + 5u)];
    let grad_old_x = state[(base + 6u)];
    let grad_old_y = state[(base + 7u)];
    let corr_x = (d_p * (grad_px - grad_old_x));
    let corr_y = (d_p * (grad_py - grad_old_y));
    let _e52 = state[(base + 0u)];
    state[(base + 0u)] = (_e52 - corr_x);
    let _e62 = state[(base + 1u)];
    state[(base + 1u)] = (_e62 - corr_y);
    return;
}
"#;
    }
    pub mod rhie_chow_grad_p_update_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: rhie_chow_grad_p_update_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedRhieChowGradPUpdateIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rhie_chow_grad_p_update_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_p: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e31 = k;
        if (_e31 < end) {
        } else {
            break;
        }
        {
            let _e34 = k;
            let face_idx = cell_faces[_e34];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e60 = face_normals[face_idx].x;
            let _e64 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e60, _e64);
            let _e68 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e68) < 0f) {
                let _e72 = normal_vec;
                normal_vec = -(_e72);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e81 = other_idx;
                let other_center = cell_centers[_e81];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let _e88 = normal_vec;
            let d_own = abs(dot((face_center_vec - cell_center_vec), _e88));
            let _e91 = other_center_vec;
            let _e93 = normal_vec;
            let d_neigh = abs(dot((_e91 - face_center_vec), _e93));
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e102 = lambda;
            let lambda_other = (1f - _e102);
            let _e105 = normal_vec;
            let _e112 = state[((idx * 8u) + 2u)];
            let _e113 = lambda;
            let _e115 = other_idx;
            let _e122 = state[((_e115 * 8u) + 2u)];
            let _e129 = state[((idx * 8u) + 2u)];
            let _e136 = bc_value[((face_idx * 3u) + 2u)];
            let _e143 = bc_kind[((face_idx * 3u) + 2u)];
            let _e153 = state[((idx * 8u) + 2u)];
            let _e160 = bc_value[((face_idx * 3u) + 2u)];
            let _e169 = bc_kind[((face_idx * 3u) + 2u)];
            let _e179 = grad_acc_p;
            grad_acc_p = (_e179 + ((_e105 * ((_e112 * _e113) + (select(_e122, select(select(_e129, _e136, (_e143 == 1u)), (_e153 + (_e160 * d_own)), (_e169 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e182 = k;
            k = (_e182 + 1u);
        }
    }
    let _e184 = grad_acc_p;
    let grad_out_p = ((_e184 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 8u) + 4u)] = grad_out_p.x;
    state[((idx * 8u) + 5u)] = grad_out_p.y;
    return;
}
"#;
    }
    pub mod rhie_chow_store_grad_p_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowStoreGradPIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: rhie_chow_store_grad_p_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedRhieChowStoreGradPIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedRhieChowStoreGradPIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rhie_chow_store_grad_p_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let base = (idx * 8u);
    let _e23 = state[(base + 4u)];
    state[(base + 6u)] = _e23;
    let _e32 = state[(base + 5u)];
    state[(base + 7u)] = _e32;
    return;
}
"#;
    }
}
pub mod generic_coupled_schur_setup {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SetupParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub u_len: u32,
        #[doc = "offset: 16, size: 16, type: `vec4<u32>`"]
        pub u0123: [u32; 4],
        #[doc = "offset: 32, size: 16, type: `vec4<u32>`"]
        pub u4567: [u32; 4],
    }
    impl SetupParams {
        pub const fn new(
            num_cells: u32,
            unknowns_per_cell: u32,
            p: u32,
            u_len: u32,
            u0123: [u32; 4],
            u4567: [u32; 4],
        ) -> Self {
            Self {
                num_cells,
                unknowns_per_cell,
                p,
                u_len,
                u0123,
                u4567,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const BUILD_DIAG_AND_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_build_diag_and_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline build_diag_and_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("build_diag_and_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_BUILD_DIAG_AND_PRESSURE: &str = "build_diag_and_pressure";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        pub diagonal_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        pub diagonal_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                scalar_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                },
                diagonal_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
                params: wgpu::BindGroupEntry {
                    binding: 6,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
            [
                self.scalar_row_offsets,
                self.diagonal_indices,
                self.matrix_values,
                self.diag_u_inv,
                self.diag_p_inv,
                self.p_matrix_values,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GenericCoupledSchurSetup::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"scalar_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diagonal_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(6): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::generic_coupled_schur_setup::SetupParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GenericCoupledSchurSetup::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GenericCoupledSchurSetup::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("generic_coupled_schur_setup.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SetupParams {
    num_cells: u32,
    unknowns_per_cell: u32,
    p: u32,
    u_len: u32,
    u0123_: vec4<u32>,
    u4567_: vec4<u32>,
}

@group(0) @binding(0) 
var<storage> scalar_row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(0) @binding(5) 
var<storage, read_write> p_matrix_values: array<f32>;
@group(0) @binding(6) 
var<uniform> params: SetupParams;

fn u_index(i_1: u32) -> u32 {
    if (i_1 < 4u) {
        let _e6 = params.u0123_[i_1];
        return _e6;
    }
    let _e12 = params.u4567_[(i_1 - 4u)];
    return _e12;
}

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn build_diag_and_pressure(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var i: u32 = 0u;
    var rank: u32 = 0u;

    let cell = ((global_id.y * (num_workgroups.x * 64u)) + global_id.x);
    let _e12 = params.num_cells;
    if (cell >= _e12) {
        return;
    }
    let scalar_offset = scalar_row_offsets[cell];
    let scalar_end = scalar_row_offsets[(cell + 1u)];
    let num_neighbors = (scalar_end - scalar_offset);
    let _e25 = diagonal_indices[cell];
    let diag_rank = (_e25 - scalar_offset);
    let _e29 = params.unknowns_per_cell;
    let _e32 = params.unknowns_per_cell;
    let block_stride = (_e29 * _e32);
    let start_row_0_ = (scalar_offset * block_stride);
    let _e37 = params.unknowns_per_cell;
    let row_stride = (num_neighbors * _e37);
    let _e41 = params.p;
    let start_row_p = (start_row_0_ + (_e41 * row_stride));
    let _e46 = params.unknowns_per_cell;
    let _e52 = params.p;
    let diag_p = matrix_values[((start_row_p + (diag_rank * _e46)) + _e52)];
    loop {
        let _e57 = i;
        let _e60 = params.u_len;
        if (_e57 < _e60) {
        } else {
            break;
        }
        {
            let _e62 = i;
            let _e63 = u_index(_e62);
            let start_row_u = (start_row_0_ + (_e63 * row_stride));
            let _e69 = params.unknowns_per_cell;
            let diag_u = matrix_values[((start_row_u + (diag_rank * _e69)) + _e63)];
            let _e75 = safe_inverse(diag_u);
            let _e79 = params.u_len;
            let _e81 = i;
            diag_u_inv[((cell * _e79) + _e81)] = _e75;
        }
        continuing {
            let _e85 = i;
            i = (_e85 + 1u);
        }
    }
    let _e89 = safe_inverse(diag_p);
    diag_p_inv[cell] = _e89;
    loop {
        let _e91 = rank;
        if (_e91 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e94 = rank;
            let _e97 = rank;
            let _e100 = params.unknowns_per_cell;
            let _e106 = params.p;
            let _e109 = matrix_values[((start_row_p + (_e97 * _e100)) + _e106)];
            p_matrix_values[(scalar_offset + _e94)] = _e109;
        }
        continuing {
            let _e111 = rank;
            rank = (_e111 + 1u);
        }
    }
    return;
}
"#;
}
pub mod gmres_cgs {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Params {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub column_offset: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub pad3: u32,
    }
    impl Params {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            max_restart: u32,
            column_offset: u32,
            pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                max_restart,
                column_offset,
                pad3,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub const SCALAR_STOP: u32 = 8u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const CALC_DOTS_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_calc_dots_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline calc_dots_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("calc_dots_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_DOTS_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_dots_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_dots_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_dots_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UPDATE_W_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_update_w_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_w_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_w_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_CALC_DOTS_CGS: &str = "calc_dots_cgs";
    pub const ENTRY_REDUCE_DOTS_CGS: &str = "reduce_dots_cgs";
    pub const ENTRY_UPDATE_W_CGS: &str = "update_w_cgs";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub b_basis: wgpu::BufferBinding<'a>,
        pub b_w: wgpu::BufferBinding<'a>,
        pub b_dot_partial: wgpu::BufferBinding<'a>,
        pub b_hessenberg: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub b_basis: wgpu::BindGroupEntry<'a>,
        pub b_w: wgpu::BindGroupEntry<'a>,
        pub b_dot_partial: wgpu::BindGroupEntry<'a>,
        pub b_hessenberg: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                b_basis: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.b_basis),
                },
                b_w: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.b_w),
                },
                b_dot_partial: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.b_dot_partial),
                },
                b_hessenberg: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.b_hessenberg),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
            [
                self.params,
                self.b_basis,
                self.b_w,
                self.b_dot_partial,
                self.b_hessenberg,
                self.scalars,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresCgs::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_cgs::Params,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"b_basis\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"b_w\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"b_dot_partial\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"b_hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresCgs::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresCgs::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_cgs.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct Params {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    max_restart: u32,
    column_offset: u32,
    pad3_: u32,
}

const WORKGROUP_SIZE: u32 = 64u;
const SCALAR_STOP: u32 = 8u;

@group(0) @binding(0) 
var<uniform> params: Params;
@group(0) @binding(1) 
var<storage> b_basis: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> b_w: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> b_dot_partial: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> b_hessenberg: array<f32>;
@group(0) @binding(5) 
var<storage> scalars: array<f32>;
var<workgroup> sdata: array<f32, 64>;
var<workgroup> sdata_vec4_: array<vec4<f32>, 64>;

@compute @workgroup_size(64, 1, 1) 
fn calc_dots_cgs(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var w_val: f32 = 0f;
    var i: u32 = 0u;
    var v: vec4<f32>;

    let _e4 = scalars[8];
    if (_e4 > 0.5f) {
        return;
    }
    let j = params.num_iters;
    let n = params.n;
    let num_groups_n = ((n + 63u) / WORKGROUP_SIZE);
    let stride_x = (num_workgroups.x * WORKGROUP_SIZE);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let group_flat = ((group_id.y * num_workgroups.x) + group_id.x);
    if (group_flat >= num_groups_n) {
        return;
    }
    let stride_bytes = (((n * 4u) + 255u) & 4294967040u);
    let stride_words = (stride_bytes / 4u);
    if (idx < n) {
        let _e44 = b_w[idx];
        w_val = _e44;
    }
    loop {
        let _e47 = i;
        if (_e47 <= j) {
        } else {
            break;
        }
        {
            v = vec4(0f);
            if (idx < n) {
                let _e53 = i;
                if (_e53 <= j) {
                    let _e57 = i;
                    let _e61 = b_basis[((_e57 * stride_words) + idx)];
                    v.x = _e61;
                }
                let _e62 = i;
                if ((_e62 + 1u) <= j) {
                    let _e67 = i;
                    let _e74 = b_basis[(((_e67 + 1u) * stride_words) + idx)];
                    v.y = _e74;
                }
                let _e75 = i;
                if ((_e75 + 2u) <= j) {
                    let _e80 = i;
                    let _e87 = b_basis[(((_e80 + 2u) * stride_words) + idx)];
                    v.z = _e87;
                }
                let _e88 = i;
                if ((_e88 + 3u) <= j) {
                    let _e93 = i;
                    let _e100 = b_basis[(((_e93 + 3u) * stride_words) + idx)];
                    v.w = _e100;
                }
            }
            let _e101 = v;
            let _e102 = w_val;
            let prod = (_e101 * _e102);
            sdata_vec4_[local_id.x] = prod;
            workgroupBarrier();
            if (local_id.x < 32u) {
                let _e119 = sdata_vec4_[(local_id.x + 32u)];
                let _e120 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e120 + _e119);
            }
            workgroupBarrier();
            if (local_id.x < 16u) {
                let _e133 = sdata_vec4_[(local_id.x + 16u)];
                let _e134 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e134 + _e133);
            }
            workgroupBarrier();
            if (local_id.x < 8u) {
                let _e147 = sdata_vec4_[(local_id.x + 8u)];
                let _e148 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e148 + _e147);
            }
            workgroupBarrier();
            if (local_id.x < 4u) {
                let _e161 = sdata_vec4_[(local_id.x + 4u)];
                let _e162 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e162 + _e161);
            }
            workgroupBarrier();
            if (local_id.x < 2u) {
                let _e175 = sdata_vec4_[(local_id.x + 2u)];
                let _e176 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e176 + _e175);
            }
            workgroupBarrier();
            if (local_id.x < 1u) {
                let _e189 = sdata_vec4_[(local_id.x + 1u)];
                let _e190 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e190 + _e189);
                let sum_1 = sdata_vec4_[0];
                let _e195 = i;
                if (_e195 <= j) {
                    let _e198 = i;
                    b_dot_partial[((_e198 * num_groups_n) + group_flat)] = sum_1.x;
                }
                let _e203 = i;
                if ((_e203 + 1u) <= j) {
                    let _e207 = i;
                    b_dot_partial[(((_e207 + 1u) * num_groups_n) + group_flat)] = sum_1.y;
                }
                let _e215 = i;
                if ((_e215 + 2u) <= j) {
                    let _e219 = i;
                    b_dot_partial[(((_e219 + 2u) * num_groups_n) + group_flat)] = sum_1.z;
                }
                let _e227 = i;
                if ((_e227 + 3u) <= j) {
                    let _e231 = i;
                    b_dot_partial[(((_e231 + 3u) * num_groups_n) + group_flat)] = sum_1.w;
                }
            }
            workgroupBarrier();
        }
        continuing {
            let _e240 = i;
            i = (_e240 + 4u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn reduce_dots_cgs(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(local_invocation_id) local_id_1: vec3<u32>, @builtin(workgroup_id) group_id_1: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let _e3 = scalars[8];
    if (_e3 > 0.5f) {
        return;
    }
    let i_2 = group_id_1.x;
    let j_1 = params.num_iters;
    let _e14 = params.max_restart;
    if ((i_2 > j_1) || (i_2 >= _e14)) {
        return;
    }
    let _e19 = params.n;
    let num_groups_n_1 = ((_e19 + 63u) / 64u);
    k = local_id_1.x;
    loop {
        let _e27 = k;
        if (_e27 < num_groups_n_1) {
        } else {
            break;
        }
        {
            let _e32 = k;
            let _e35 = b_dot_partial[((i_2 * num_groups_n_1) + _e32)];
            let _e36 = sum;
            sum = (_e36 + _e35);
        }
        continuing {
            let _e39 = k;
            k = (_e39 + 64u);
        }
    }
    let _e44 = sum;
    sdata[local_id_1.x] = _e44;
    workgroupBarrier();
    if (local_id_1.x < 32u) {
        let _e56 = sdata[(local_id_1.x + 32u)];
        let _e57 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e57 + _e56);
    }
    workgroupBarrier();
    if (local_id_1.x < 16u) {
        let _e70 = sdata[(local_id_1.x + 16u)];
        let _e71 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e71 + _e70);
    }
    workgroupBarrier();
    if (local_id_1.x < 8u) {
        let _e84 = sdata[(local_id_1.x + 8u)];
        let _e85 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e85 + _e84);
    }
    workgroupBarrier();
    if (local_id_1.x < 4u) {
        let _e98 = sdata[(local_id_1.x + 4u)];
        let _e99 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e99 + _e98);
    }
    workgroupBarrier();
    if (local_id_1.x < 2u) {
        let _e112 = sdata[(local_id_1.x + 2u)];
        let _e113 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e113 + _e112);
    }
    workgroupBarrier();
    if (local_id_1.x < 1u) {
        let _e126 = sdata[(local_id_1.x + 1u)];
        let _e127 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e127 + _e126);
        let max_restart = params.max_restart;
        let h_idx = ((j_1 * (max_restart + 1u)) + i_2);
        let _e140 = sdata[0];
        b_hessenberg[h_idx] = _e140;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn update_w_cgs(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var correction: f32 = 0f;
    var i_1: u32 = 0u;

    let _e4 = scalars[8];
    if (_e4 > 0.5f) {
        return;
    }
    let stride_x_1 = (num_workgroups_1.x * WORKGROUP_SIZE);
    let idx_1 = ((global_id_2.y * stride_x_1) + global_id_2.x);
    let j_2 = params.num_iters;
    let n_1 = params.n;
    let max_restart_1 = params.max_restart;
    let stride_bytes_1 = (((n_1 * 4u) + 255u) & 4294967040u);
    let stride_words_1 = (stride_bytes_1 / 4u);
    if (idx_1 >= n_1) {
        return;
    }
    loop {
        let _e35 = i_1;
        if (_e35 <= j_2) {
        } else {
            break;
        }
        {
            let _e37 = i_1;
            if (_e37 <= j_2) {
                let _e43 = i_1;
                let h_val = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + _e43)];
                let _e48 = i_1;
                let v_val = b_basis[((_e48 * stride_words_1) + idx_1)];
                let _e55 = correction;
                correction = (_e55 + (h_val * v_val));
            }
            let _e57 = i_1;
            if ((_e57 + 1u) <= j_2) {
                let _e64 = i_1;
                let h_val_1 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e64 + 1u))];
                let _e71 = i_1;
                let v_val_1 = b_basis[(((_e71 + 1u) * stride_words_1) + idx_1)];
                let _e80 = correction;
                correction = (_e80 + (h_val_1 * v_val_1));
            }
            let _e82 = i_1;
            if ((_e82 + 2u) <= j_2) {
                let _e89 = i_1;
                let h_val_2 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e89 + 2u))];
                let _e96 = i_1;
                let v_val_2 = b_basis[(((_e96 + 2u) * stride_words_1) + idx_1)];
                let _e105 = correction;
                correction = (_e105 + (h_val_2 * v_val_2));
            }
            let _e107 = i_1;
            if ((_e107 + 3u) <= j_2) {
                let _e114 = i_1;
                let h_val_3 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e114 + 3u))];
                let _e121 = i_1;
                let v_val_3 = b_basis[(((_e121 + 3u) * stride_words_1) + idx_1)];
                let _e130 = correction;
                correction = (_e130 + (h_val_3 * v_val_3));
            }
        }
        continuing {
            let _e133 = i_1;
            i_1 = (_e133 + 4u);
        }
    }
    let _e139 = b_w[idx_1];
    let _e140 = correction;
    b_w[idx_1] = (_e139 - _e140);
    return;
}
"#;
}
pub mod gmres_logic {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub const SCALAR_STOP: u32 = 8u32;
    pub const SCALAR_CONVERGED: u32 = 9u32;
    pub const SCALAR_ITERS_USED: u32 = 10u32;
    pub const SCALAR_RESIDUAL_EST: u32 = 11u32;
    pub const SCALAR_TOL_REL_RHS: u32 = 12u32;
    pub const SCALAR_TOL_ABS: u32 = 13u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const UPDATE_HESSENBERG_GIVENS_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_update_hessenberg_givens_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_hessenberg_givens"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_hessenberg_givens"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SOLVE_TRIANGULAR_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_solve_triangular_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline solve_triangular"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("solve_triangular"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const FINISH_NORM_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_finish_norm_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline finish_norm"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("finish_norm"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_UPDATE_HESSENBERG_GIVENS: &str = "update_hessenberg_givens";
    pub const ENTRY_SOLVE_TRIANGULAR: &str = "solve_triangular";
    pub const ENTRY_FINISH_NORM: &str = "finish_norm";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub givens: wgpu::BufferBinding<'a>,
        pub g_rhs: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub givens: wgpu::BindGroupEntry<'a>,
        pub g_rhs: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                hessenberg: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                givens: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.givens),
                },
                g_rhs: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.g_rhs),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [self.hessenberg, self.givens, self.g_rhs, self.y_sol]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresLogic::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"givens\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"g_rhs\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresLogic::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub iter_params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub indirect_args: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub indirect_args: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                iter_params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                indirect_args: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.indirect_args),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.iter_params, self.scalars, self.indirect_args]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresLogic::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_logic::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"indirect_args\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresLogic::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresLogic::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_logic.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

const SCALAR_STOP: u32 = 8u;
const SCALAR_CONVERGED: u32 = 9u;
const SCALAR_ITERS_USED: u32 = 10u;
const SCALAR_RESIDUAL_EST: u32 = 11u;
const SCALAR_TOL_REL_RHS: u32 = 12u;
const SCALAR_TOL_ABS: u32 = 13u;

@group(0) @binding(0) 
var<storage, read_write> hessenberg: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> givens: array<vec2<f32>>;
@group(0) @binding(2) 
var<storage, read_write> g_rhs: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> y_sol: array<f32>;
@group(1) @binding(0) 
var<uniform> iter_params: IterParams;
@group(1) @binding(1) 
var<storage, read_write> scalars: array<f32>;
@group(1) @binding(2) 
var<storage, read_write> indirect_args: array<vec4<u32>>;

fn h_idx(row: u32, col: u32) -> u32 {
    let _e2 = iter_params.max_restart;
    return ((col * (_e2 + 1u)) + row);
}

@compute @workgroup_size(1, 1, 1) 
fn update_hessenberg_givens(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var i: u32 = 0u;
    var c: f32 = 1f;
    var s: f32 = 0f;
    var rho: f32;

    let _e5 = scalars[8];
    if (_e5 > 0.5f) {
        return;
    }
    let j_1 = iter_params.current_idx;
    loop {
        let _e12 = i;
        if (_e12 < j_1) {
        } else {
            break;
        }
        {
            let _e14 = i;
            let _e15 = h_idx(_e14, j_1);
            let _e16 = i;
            let _e19 = h_idx((_e16 + 1u), j_1);
            let h_ij = hessenberg[_e15];
            let h_i1j = hessenberg[_e19];
            let _e27 = i;
            let cs = givens[_e27];
            let c_1 = cs.x;
            let s_1 = cs.y;
            hessenberg[_e15] = ((c_1 * h_ij) + (s_1 * h_i1j));
            hessenberg[_e19] = ((-(s_1) * h_ij) + (c_1 * h_i1j));
        }
        continuing {
            let _e44 = i;
            i = (_e44 + 1u);
        }
    }
    let _e46 = h_idx(j_1, j_1);
    let _e49 = h_idx((j_1 + 1u), j_1);
    let h_jj = hessenberg[_e46];
    let h_j1j = hessenberg[_e49];
    rho = sqrt(((h_jj * h_jj) + (h_j1j * h_j1j)));
    let _e61 = rho;
    if (abs(_e61) > 0.00000000000000000001f) {
        let _e65 = rho;
        c = (h_jj / _e65);
        let _e68 = rho;
        s = (h_j1j / _e68);
    }
    let _e73 = c;
    let _e74 = s;
    givens[j_1] = vec2<f32>(_e73, _e74);
    let _e78 = rho;
    hessenberg[_e46] = _e78;
    hessenberg[_e49] = 0f;
    let g_j = g_rhs[j_1];
    let g_j1_ = g_rhs[(j_1 + 1u)];
    let _e92 = c;
    let _e94 = s;
    g_rhs[j_1] = ((_e92 * g_j) + (_e94 * g_j1_));
    let _e101 = s;
    let _e104 = c;
    g_rhs[(j_1 + 1u)] = ((-(_e101) * g_j) + (_e104 * g_j1_));
    let _e111 = g_rhs[(j_1 + 1u)];
    let residual = abs(_e111);
    scalars[11] = residual;
    let tol_rel_rhs = scalars[12];
    let tol_abs = scalars[13];
    if ((residual <= tol_rel_rhs) || (residual <= tol_abs)) {
        scalars[8] = 1f;
        scalars[9] = 1f;
        scalars[10] = f32((j_1 + 1u));
        indirect_args[0] = vec4<u32>(0u, 0u, 0u, 0u);
        indirect_args[1] = vec4<u32>(0u, 0u, 0u, 0u);
        indirect_args[2] = vec4<u32>(0u, 0u, 0u, 0u);
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(1, 1, 1) 
fn solve_triangular(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    var loop_i: u32 = 0u;
    var sum: f32;
    var j: u32;

    let _e3 = scalars[10];
    let _e7 = iter_params.max_restart;
    let k = u32(clamp(round(_e3), 1f, f32(_e7)));
    loop {
        let _e13 = loop_i;
        if (_e13 < k) {
        } else {
            break;
        }
        {
            let _e17 = loop_i;
            let i_1 = ((k - 1u) - _e17);
            let _e21 = g_rhs[i_1];
            sum = _e21;
            j = (i_1 + 1u);
            loop {
                let _e26 = j;
                if (_e26 < k) {
                } else {
                    break;
                }
                {
                    let _e28 = j;
                    let _e29 = h_idx(i_1, _e28);
                    let _e32 = hessenberg[_e29];
                    let _e34 = j;
                    let _e36 = y_sol[_e34];
                    let _e38 = sum;
                    sum = (_e38 - (_e32 * _e36));
                }
                continuing {
                    let _e41 = j;
                    j = (_e41 + 1u);
                }
            }
            let _e43 = h_idx(i_1, i_1);
            let diag = hessenberg[_e43];
            if (abs(diag) > 0.000000000001f) {
                let _e52 = sum;
                y_sol[i_1] = (_e52 / diag);
            } else {
                y_sol[i_1] = 0f;
            }
        }
        continuing {
            let _e58 = loop_i;
            loop_i = (_e58 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn finish_norm(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    let norm_sq = scalars[0];
    let norm = sqrt(norm_sq);
    let _e7 = iter_params.current_idx;
    hessenberg[_e7] = norm;
    if (norm > 0.00000000000000000001f) {
        scalars[0] = (1f / norm);
        return;
    } else {
        scalars[0] = 0f;
        return;
    }
}
"#;
}
pub mod gmres_ops {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GmresParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad2: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad3: u32,
    }
    impl GmresParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            _pad1: u32,
            _pad2: u32,
            _pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                _pad1,
                _pad2,
                _pad3,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub const SCALAR_STOP: u32 = 8u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const SPMV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpy_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpy"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpy"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPY_FROM_Y_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpy_from_y_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpy_from_y"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpy_from_y"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPBY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpby_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpby"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpby"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SCALE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_scale_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline scale"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("scale"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SCALE_IN_PLACE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_scale_in_place_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline scale_in_place"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("scale_in_place"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const COPY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_copy_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline copy"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("copy"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const DOT_PRODUCT_PARTIAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_dot_product_partial_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline dot_product_partial"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("dot_product_partial"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const NORM_SQ_PARTIAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_norm_sq_partial_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline norm_sq_partial"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("norm_sq_partial"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const ORTHOGONALIZE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_orthogonalize_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline orthogonalize"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("orthogonalize"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_FINAL_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_reduce_final_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_final"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_final"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_FINAL_AND_FINISH_NORM_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_reduce_final_and_finish_norm_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_final_and_finish_norm"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_final_and_finish_norm"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const EXTRACT_DIAG_INV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_extract_diag_inv_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline extract_diag_inv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("extract_diag_inv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const APPLY_DIAG_INV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_apply_diag_inv_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline apply_diag_inv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("apply_diag_inv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SPMV: &str = "spmv";
    pub const ENTRY_AXPY: &str = "axpy";
    pub const ENTRY_AXPY_FROM_Y: &str = "axpy_from_y";
    pub const ENTRY_AXPBY: &str = "axpby";
    pub const ENTRY_SCALE: &str = "scale";
    pub const ENTRY_SCALE_IN_PLACE: &str = "scale_in_place";
    pub const ENTRY_COPY: &str = "copy";
    pub const ENTRY_DOT_PRODUCT_PARTIAL: &str = "dot_product_partial";
    pub const ENTRY_NORM_SQ_PARTIAL: &str = "norm_sq_partial";
    pub const ENTRY_ORTHOGONALIZE: &str = "orthogonalize";
    pub const ENTRY_REDUCE_FINAL: &str = "reduce_final";
    pub const ENTRY_REDUCE_FINAL_AND_FINISH_NORM: &str = "reduce_final_and_finish_norm";
    pub const ENTRY_EXTRACT_DIAG_INV: &str = "extract_diag_inv";
    pub const ENTRY_APPLY_DIAG_INV: &str = "apply_diag_inv";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub vec_x: wgpu::BufferBinding<'a>,
        pub vec_y: wgpu::BufferBinding<'a>,
        pub vec_z: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub vec_x: wgpu::BindGroupEntry<'a>,
        pub vec_y: wgpu::BindGroupEntry<'a>,
        pub vec_z: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                vec_x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.vec_x),
                },
                vec_y: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.vec_y),
                },
                vec_z: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.vec_z),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.vec_x, self.vec_y, self.vec_z]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"vec_x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"vec_y\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"vec_z\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u: wgpu::BufferBinding<'a>,
        pub diag_v: wgpu::BufferBinding<'a>,
        pub diag_p: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u: wgpu::BindGroupEntry<'a>,
        pub diag_v: wgpu::BindGroupEntry<'a>,
        pub diag_p: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u),
                },
                diag_v: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_v),
                },
                diag_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.diag_p),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.diag_u, self.diag_v, self.diag_p]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_v\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"diag_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub iter_params: wgpu::BufferBinding<'a>,
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                iter_params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                hessenberg: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.scalars,
                self.iter_params,
                self.hessenberg,
                self.y_sol,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_ops::GmresParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_ops::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresOps::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_ops.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GmresParams {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    _pad1_: u32,
    _pad2_: u32,
    _pad3_: u32,
}

struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

const WORKGROUP_SIZE: u32 = 64u;
const SCALAR_STOP: u32 = 8u;

@group(0) @binding(0) 
var<storage> vec_x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> vec_y: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> vec_z: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_v: array<f32>;
@group(2) @binding(2) 
var<storage, read_write> diag_p: array<f32>;
@group(3) @binding(0) 
var<uniform> params: GmresParams;
@group(3) @binding(1) 
var<storage, read_write> scalars: array<f32>;
@group(3) @binding(2) 
var<uniform> iter_params: IterParams;
@group(3) @binding(3) 
var<storage, read_write> hessenberg: array<f32>;
@group(3) @binding(4) 
var<storage> y_sol: array<f32>;
var<workgroup> partial_sums: array<f32, 64>;

fn global_index(global_id_14: vec3<u32>, num_workgroups_12: vec3<u32>) -> u32 {
    return ((global_id_14.y * (num_workgroups_12.x * WORKGROUP_SIZE)) + global_id_14.x);
}

fn workgroup_index(group_id_2: vec3<u32>, num_workgroups_13: vec3<u32>) -> u32 {
    return ((group_id_2.y * num_workgroups_13.x) + group_id_2.x);
}

fn safe_inverse(val: f32) -> f32 {
    let abs_val = abs(val);
    if (abs_val > 0.000000000001f) {
        return (1f / val);
    }
    if (abs_val > 0f) {
        return (sign(val) * 1000000000000f);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn spmv(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let _e3 = global_index(global_id, num_workgroups);
    let _e6 = params.n;
    if (_e3 >= _e6) {
        return;
    }
    let start = row_offsets[_e3];
    let end = row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col = col_indices[_e20];
            let _e24 = k;
            let val_1 = matrix_values[_e24];
            let _e30 = vec_x[col];
            let _e32 = sum;
            sum = (_e32 + (val_1 * _e30));
        }
        continuing {
            let _e35 = k;
            k = (_e35 + 1u);
        }
    }
    let _e39 = sum;
    vec_y[_e3] = _e39;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpy(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    let _e2 = global_index(global_id_1, num_workgroups_1);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha = scalars[0];
    let _e14 = vec_x[_e2];
    let _e18 = vec_y[_e2];
    vec_y[_e2] = ((alpha * _e14) + _e18);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpy_from_y(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    let _e2 = global_index(global_id_2, num_workgroups_2);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let _e10 = iter_params.current_idx;
    let alpha_1 = y_sol[_e10];
    let _e17 = vec_x[_e2];
    let _e21 = vec_y[_e2];
    vec_y[_e2] = ((alpha_1 * _e17) + _e21);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpby(@builtin(global_invocation_id) global_id_3: vec3<u32>, @builtin(num_workgroups) num_workgroups_3: vec3<u32>) {
    let _e2 = global_index(global_id_3, num_workgroups_3);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha_2 = scalars[0];
    let beta = scalars[1];
    let _e17 = vec_x[_e2];
    let _e21 = vec_y[_e2];
    vec_z[_e2] = ((alpha_2 * _e17) + (beta * _e21));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn scale(@builtin(global_invocation_id) global_id_4: vec3<u32>, @builtin(num_workgroups) num_workgroups_4: vec3<u32>) {
    let _e2 = global_index(global_id_4, num_workgroups_4);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha_3 = scalars[0];
    let _e14 = vec_x[_e2];
    vec_y[_e2] = (alpha_3 * _e14);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn scale_in_place(@builtin(global_invocation_id) global_id_5: vec3<u32>, @builtin(num_workgroups) num_workgroups_5: vec3<u32>) {
    let _e2 = global_index(global_id_5, num_workgroups_5);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha_4 = scalars[0];
    let _e14 = vec_y[_e2];
    vec_y[_e2] = (alpha_4 * _e14);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn copy(@builtin(global_invocation_id) global_id_6: vec3<u32>, @builtin(num_workgroups) num_workgroups_6: vec3<u32>) {
    let _e2 = global_index(global_id_6, num_workgroups_6);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let _e11 = vec_x[_e2];
    vec_y[_e2] = _e11;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn dot_product_partial(@builtin(global_invocation_id) global_id_7: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups_7: vec3<u32>) {
    var local_sum: f32 = 0f;
    var stride: u32 = 32u;

    let _e4 = global_index(global_id_7, num_workgroups_7);
    let lid = local_id.x;
    let _e9 = params.n;
    if (_e4 < _e9) {
        let _e13 = vec_x[_e4];
        let _e16 = vec_y[_e4];
        local_sum = (_e13 * _e16);
    }
    let _e21 = local_sum;
    partial_sums[lid] = _e21;
    workgroupBarrier();
    loop {
        let _e23 = stride;
        if (_e23 > 0u) {
        } else {
            break;
        }
        {
            let _e26 = stride;
            if (lid < _e26) {
                let _e31 = stride;
                let _e34 = partial_sums[(lid + _e31)];
                let _e35 = partial_sums[lid];
                partial_sums[lid] = (_e35 + _e34);
            }
            workgroupBarrier();
        }
        continuing {
            let _e38 = stride;
            stride = (_e38 >> 1u);
        }
    }
    if (lid == 0u) {
        let _e43 = workgroup_index(group_id, num_workgroups_7);
        let _e46 = params.n;
        let num_groups_n = ((_e46 + 63u) / WORKGROUP_SIZE);
        if (_e43 < num_groups_n) {
            let _e56 = partial_sums[0];
            vec_z[_e43] = _e56;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn norm_sq_partial(@builtin(global_invocation_id) global_id_8: vec3<u32>, @builtin(local_invocation_id) local_id_1: vec3<u32>, @builtin(workgroup_id) group_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_8: vec3<u32>) {
    var local_sum_1: f32 = 0f;
    var stride_1: u32 = 32u;

    let _e4 = global_index(global_id_8, num_workgroups_8);
    let lid_1 = local_id_1.x;
    let _e9 = params.n;
    if (_e4 < _e9) {
        let val_2 = vec_x[_e4];
        local_sum_1 = (val_2 * val_2);
    }
    let _e18 = local_sum_1;
    partial_sums[lid_1] = _e18;
    workgroupBarrier();
    loop {
        let _e20 = stride_1;
        if (_e20 > 0u) {
        } else {
            break;
        }
        {
            let _e23 = stride_1;
            if (lid_1 < _e23) {
                let _e28 = stride_1;
                let _e31 = partial_sums[(lid_1 + _e28)];
                let _e32 = partial_sums[lid_1];
                partial_sums[lid_1] = (_e32 + _e31);
            }
            workgroupBarrier();
        }
        continuing {
            let _e35 = stride_1;
            stride_1 = (_e35 >> 1u);
        }
    }
    if (lid_1 == 0u) {
        let _e40 = workgroup_index(group_id_1, num_workgroups_8);
        let _e43 = params.n;
        let num_groups_n_1 = ((_e43 + 63u) / WORKGROUP_SIZE);
        if (_e40 < num_groups_n_1) {
            let _e53 = partial_sums[0];
            vec_z[_e40] = _e53;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn orthogonalize(@builtin(global_invocation_id) global_id_9: vec3<u32>, @builtin(num_workgroups) num_workgroups_9: vec3<u32>) {
    let _e2 = global_index(global_id_9, num_workgroups_9);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let h = scalars[0];
    let _e14 = vec_y[_e2];
    let _e17 = vec_x[_e2];
    vec_y[_e2] = (_e14 - (h * _e17));
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn reduce_final(@builtin(global_invocation_id) global_id_10: vec3<u32>) {
    var total_sum: f32 = 0f;
    var i: u32 = 0u;

    let num_partials = params.n;
    loop {
        let _e6 = i;
        if (_e6 < num_partials) {
        } else {
            break;
        }
        {
            let _e10 = i;
            let _e12 = vec_x[_e10];
            let _e13 = total_sum;
            total_sum = (_e13 + _e12);
        }
        continuing {
            let _e16 = i;
            i = (_e16 + 1u);
        }
    }
    let _e20 = total_sum;
    scalars[0] = _e20;
    let _e24 = iter_params.current_idx;
    let _e26 = total_sum;
    hessenberg[_e24] = _e26;
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn reduce_final_and_finish_norm(@builtin(global_invocation_id) global_id_11: vec3<u32>) {
    var total_sum_1: f32 = 0f;
    var i_1: u32 = 0u;

    let _e4 = scalars[8];
    if (_e4 > 0.5f) {
        return;
    }
    let num_partials_1 = params.n;
    loop {
        let _e11 = i_1;
        if (_e11 < num_partials_1) {
        } else {
            break;
        }
        {
            let _e15 = i_1;
            let _e17 = vec_x[_e15];
            let _e18 = total_sum_1;
            total_sum_1 = (_e18 + _e17);
        }
        continuing {
            let _e21 = i_1;
            i_1 = (_e21 + 1u);
        }
    }
    let _e23 = total_sum_1;
    let norm = sqrt(_e23);
    let _e28 = iter_params.current_idx;
    hessenberg[_e28] = norm;
    if (norm > 0.00000000000000000001f) {
        scalars[0] = (1f / norm);
        return;
    } else {
        scalars[0] = 0f;
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn extract_diag_inv(@builtin(global_invocation_id) global_id_12: vec3<u32>, @builtin(num_workgroups) num_workgroups_10: vec3<u32>) {
    var diag: f32 = 1f;
    var k_1: u32;

    let _e3 = global_index(global_id_12, num_workgroups_10);
    let _e6 = params.n;
    if (_e3 >= _e6) {
        return;
    }
    let start_1 = row_offsets[_e3];
    let end_1 = row_offsets[(_e3 + 1u)];
    k_1 = start_1;
    loop {
        let _e17 = k_1;
        if (_e17 < end_1) {
        } else {
            break;
        }
        {
            let _e20 = k_1;
            let _e22 = col_indices[_e20];
            if (_e22 == _e3) {
                let _e25 = k_1;
                let _e27 = matrix_values[_e25];
                diag = _e27;
                break;
            }
        }
        continuing {
            let _e29 = k_1;
            k_1 = (_e29 + 1u);
        }
    }
    let _e32 = diag;
    let _e33 = safe_inverse(_e32);
    diag_u[_e3] = _e33;
    diag_v[_e3] = _e33;
    diag_p[_e3] = _e33;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn apply_diag_inv(@builtin(global_invocation_id) global_id_13: vec3<u32>, @builtin(num_workgroups) num_workgroups_11: vec3<u32>) {
    let _e2 = global_index(global_id_13, num_workgroups_11);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let _e11 = diag_u[_e2];
    let _e14 = vec_x[_e2];
    vec_y[_e2] = (_e11 * _e14);
    return;
}
"#;
}
pub mod linear_solver {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GpuScalars {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub rho_old: f32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub rho_new: f32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub alpha: f32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub beta: f32,
        #[doc = "offset: 16, size: 4, type: `f32`"]
        pub r0_v: f32,
        #[doc = "offset: 20, size: 4, type: `f32`"]
        pub r_r: f32,
    }
    impl GpuScalars {
        pub const fn new(
            rho_old: f32,
            rho_new: f32,
            alpha: f32,
            beta: f32,
            r0_v: f32,
            r_r: f32,
        ) -> Self {
            Self {
                rho_old,
                rho_new,
                alpha,
                beta,
                r0_v,
                r_r,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
    }
    impl SolverParams {
        pub const fn new(n: u32) -> Self {
            Self { n }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const SPMV_P_V_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_p_v_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv_p_v"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv_p_v"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CG_UPDATE_X_R_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_cg_update_x_r_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline cg_update_x_r"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("cg_update_x_r"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CG_UPDATE_P_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_cg_update_p_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline cg_update_p"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("cg_update_p"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SPMV_P_V: &str = "spmv_p_v";
    pub const ENTRY_CG_UPDATE_X_R: &str = "cg_update_x_r";
    pub const ENTRY_CG_UPDATE_P: &str = "cg_update_p";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub x: wgpu::BufferBinding<'a>,
        pub r: wgpu::BufferBinding<'a>,
        pub p: wgpu::BufferBinding<'a>,
        pub v: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub x: wgpu::BindGroupEntry<'a>,
        pub r: wgpu::BindGroupEntry<'a>,
        pub p: wgpu::BindGroupEntry<'a>,
        pub v: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.x),
                },
                r: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.r),
                },
                p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p),
                },
                v: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.v),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [self.x, self.r, self.p, self.v]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("LinearSolver::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"r\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"v\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("LinearSolver::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                params: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.row_offsets,
                self.col_indices,
                self.matrix_values,
                self.scalars,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("LinearSolver::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::linear_solver::GpuScalars,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::linear_solver::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("LinearSolver::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("LinearSolver::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("linear_solver.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GpuScalars {
    rho_old: f32,
    rho_new: f32,
    alpha: f32,
    beta: f32,
    r0_v: f32,
    r_r: f32,
}

struct SolverParams {
    n: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage, read_write> x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> r: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> v: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> scalars: GpuScalars;
@group(1) @binding(4) 
var<uniform> params: SolverParams;

fn global_index(global_id_3: vec3<u32>, num_workgroups_3: vec3<u32>) -> u32 {
    return ((global_id_3.y * (num_workgroups_3.x * WORKGROUP_SIZE)) + global_id_3.x);
}

@compute @workgroup_size(64, 1, 1) 
fn spmv_p_v(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let _e3 = global_index(global_id, num_workgroups);
    let _e6 = params.n;
    if (_e3 >= _e6) {
        return;
    }
    let start = row_offsets[_e3];
    let end = row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col = col_indices[_e20];
            let _e24 = k;
            let val = matrix_values[_e24];
            let _e30 = p[col];
            let _e32 = sum;
            sum = (_e32 + (val * _e30));
        }
        continuing {
            let _e35 = k;
            k = (_e35 + 1u);
        }
    }
    let _e39 = sum;
    v[_e3] = _e39;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn cg_update_x_r(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var alpha: f32 = 0f;

    let _e3 = global_index(global_id_1, num_workgroups_1);
    let _e6 = scalars.r0_v;
    if (abs(_e6) >= 0.00000000000000000001f) {
        let _e12 = scalars.rho_old;
        let _e15 = scalars.r0_v;
        alpha = (_e12 / _e15);
    }
    if (_e3 == 0u) {
        let _e22 = alpha;
        scalars.alpha = _e22;
    }
    let _e25 = params.n;
    if (_e3 >= _e25) {
        return;
    }
    let _e29 = alpha;
    let _e32 = p[_e3];
    let _e34 = x[_e3];
    x[_e3] = (_e34 + (_e29 * _e32));
    let _e38 = alpha;
    let _e41 = v[_e3];
    let _e43 = r[_e3];
    r[_e3] = (_e43 - (_e38 * _e41));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn cg_update_p(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var beta: f32 = 0f;

    let _e3 = global_index(global_id_2, num_workgroups_2);
    let _e6 = scalars.rho_old;
    if (abs(_e6) >= 0.00000000000000000001f) {
        let _e12 = scalars.rho_new;
        let _e15 = scalars.rho_old;
        beta = (_e12 / _e15);
    }
    if (_e3 == 0u) {
        let _e22 = beta;
        scalars.beta = _e22;
        let _e27 = scalars.rho_new;
        scalars.rho_old = _e27;
    }
    let _e30 = params.n;
    if (_e3 >= _e30) {
        return;
    }
    let _e36 = r[_e3];
    let _e37 = beta;
    let _e40 = p[_e3];
    p[_e3] = (_e36 + (_e37 * _e40));
    return;
}
"#;
}
pub mod outer_convergence {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Params {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub stride: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_targets: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad0: u32,
    }
    impl Params {
        pub const fn new(num_cells: u32, stride: u32, num_targets: u32, _pad0: u32) -> Self {
            Self {
                num_cells,
                stride,
                num_targets,
                _pad0,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct TargetDesc {
        #[doc = "offset: 0, size: 16, type: `array<u32, 4>`"]
        pub offsets: [u32; 4],
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub num_comps: u32,
        #[doc = "offset: 20, size: 12, type: `array<u32, 3>`"]
        pub _pad0: [u32; 3],
    }
    impl TargetDesc {
        pub const fn new(offsets: [u32; 4], num_comps: u32, _pad0: [u32; 3]) -> Self {
            Self {
                offsets,
                num_comps,
                _pad0,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub input: wgpu::BufferBinding<'a>,
        pub targets: wgpu::BufferBinding<'a>,
        pub out_bits: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub input: wgpu::BindGroupEntry<'a>,
        pub targets: wgpu::BindGroupEntry<'a>,
        pub out_bits: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                input: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.input),
                },
                targets: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.targets),
                },
                out_bits: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.out_bits),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [self.input, self.targets, self.out_bits, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("OuterConvergence::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"input\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"targets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"out_bits\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::outer_convergence::Params,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("OuterConvergence::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("OuterConvergence::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("outer_convergence.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct Params {
    num_cells: u32,
    stride: u32,
    num_targets: u32,
    _pad0_: u32,
}

struct TargetDesc {
    offsets: array<u32, 4>,
    num_comps: u32,
    _pad0_: array<u32, 3>,
}

@group(0) @binding(0) 
var<storage> input: array<f32>;
@group(0) @binding(1) 
var<storage> targets: array<TargetDesc>;
@group(0) @binding(2) 
var<storage, read_write> out_bits: array<atomic<u32>>;
@group(0) @binding(3) 
var<uniform> params: Params;

@compute @workgroup_size(256, 1, 1) 
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
    var t: u32 = 0u;
    var mag2_: f32;
    var c: u32;

    let cell = gid.x;
    let _e5 = params.num_cells;
    if (cell >= _e5) {
        return;
    }
    let _e9 = params.stride;
    let base = (cell * _e9);
    loop {
        let _e12 = t;
        let _e15 = params.num_targets;
        if (_e12 < _e15) {
        } else {
            break;
        }
        {
            let _e18 = t;
            let desc = targets[_e18];
            mag2_ = 0f;
            c = 0u;
            loop {
                let _e25 = c;
                if (_e25 < desc.num_comps) {
                } else {
                    break;
                }
                {
                    let _e29 = c;
                    let off = desc.offsets[_e29];
                    let v = input[(base + off)];
                    let _e35 = mag2_;
                    mag2_ = (_e35 + (v * v));
                }
                continuing {
                    let _e38 = c;
                    c = (_e38 + 1u);
                }
            }
            let _e41 = mag2_;
            let mag = sqrt(_e41);
            let bits = bitcast<u32>(mag);
            let _e45 = t;
            let _e47 = atomicMax((&out_bits[_e45]), bits);
        }
        continuing {
            let _e48 = t;
            t = (_e48 + 1u);
        }
    }
    return;
}
"#;
}
pub mod scalars {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GpuScalars {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub rho_old: f32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub rho_new: f32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub alpha: f32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub beta: f32,
        #[doc = "offset: 16, size: 4, type: `f32`"]
        pub r0_v: f32,
        #[doc = "offset: 20, size: 4, type: `f32`"]
        pub r_r: f32,
    }
    impl GpuScalars {
        pub const fn new(
            rho_old: f32,
            rho_new: f32,
            alpha: f32,
            beta: f32,
            r0_v: f32,
            r_r: f32,
        ) -> Self {
            Self {
                rho_old,
                rho_new,
                alpha,
                beta,
                r0_v,
                r_r,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct ReduceParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_groups: u32,
    }
    impl ReduceParams {
        pub const fn new(n: u32, num_groups: u32) -> Self {
            Self { n, num_groups }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const REDUCE_RHO_NEW_R_R_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_rho_new_r_r_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_rho_new_r_r"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_rho_new_r_r"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_R0_V_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_r0_v_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_r0_v"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_r0_v"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const INIT_CG_SCALARS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_init_cg_scalars_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline init_cg_scalars"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("init_cg_scalars"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_REDUCE_RHO_NEW_R_R: &str = "reduce_rho_new_r_r";
    pub const ENTRY_REDUCE_R0_V: &str = "reduce_r0_v";
    pub const ENTRY_INIT_CG_SCALARS: &str = "init_cg_scalars";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub scalars: wgpu::BufferBinding<'a>,
        pub dot_result_1: wgpu::BufferBinding<'a>,
        pub dot_result_2: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub dot_result_1: wgpu::BindGroupEntry<'a>,
        pub dot_result_2: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                scalars: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                dot_result_1: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_1),
                },
                dot_result_2: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_2),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [
                self.scalars,
                self.dot_result_1,
                self.dot_result_2,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Scalars::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::scalars::GpuScalars,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_result_1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_result_2\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::scalars::ReduceParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Scalars::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Scalars::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("scalars.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GpuScalars {
    rho_old: f32,
    rho_new: f32,
    alpha: f32,
    beta: f32,
    r0_v: f32,
    r_r: f32,
}

struct ReduceParams {
    n: u32,
    num_groups: u32,
}

@group(0) @binding(0) 
var<storage, read_write> scalars: GpuScalars;
@group(0) @binding(1) 
var<storage> dot_result_1_: array<f32>;
@group(0) @binding(2) 
var<storage> dot_result_2_: array<f32>;
@group(0) @binding(3) 
var<uniform> params: ReduceParams;
var<workgroup> scratch1_: array<f32, 64>;
var<workgroup> scratch2_: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn reduce_rho_new_r_r(@builtin(local_invocation_id) local_id: vec3<u32>) {
    var sum1_: f32 = 0f;
    var sum2_: f32 = 0f;
    var i: u32;
    var i_1: u32 = 32u;

    let n = params.num_groups;
    let lid = local_id.x;
    i = lid;
    loop {
        let _e8 = i;
        if (_e8 < n) {
        } else {
            break;
        }
        {
            let _e12 = i;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum1_;
            sum1_ = (_e15 + _e14);
            let _e19 = i;
            let _e21 = dot_result_2_[_e19];
            let _e22 = sum2_;
            sum2_ = (_e22 + _e21);
        }
        continuing {
            let _e25 = i;
            i = (_e25 + 64u);
        }
    }
    let _e29 = sum1_;
    scratch1_[lid] = _e29;
    let _e32 = sum2_;
    scratch2_[lid] = _e32;
    workgroupBarrier();
    loop {
        let _e34 = i_1;
        if (_e34 > 0u) {
        } else {
            break;
        }
        {
            let _e37 = i_1;
            if (lid < _e37) {
                let _e42 = i_1;
                let _e45 = scratch1_[(lid + _e42)];
                let _e46 = scratch1_[lid];
                scratch1_[lid] = (_e46 + _e45);
                let _e51 = i_1;
                let _e54 = scratch2_[(lid + _e51)];
                let _e55 = scratch2_[lid];
                scratch2_[lid] = (_e55 + _e54);
            }
            workgroupBarrier();
        }
        continuing {
            let _e58 = i_1;
            i_1 = (_e58 >> 1u);
        }
    }
    if (lid == 0u) {
        let _e66 = scratch1_[0];
        scalars.rho_new = _e66;
        let _e71 = scratch2_[0];
        scalars.r_r = _e71;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn reduce_r0_v(@builtin(local_invocation_id) local_id_1: vec3<u32>) {
    var sum: f32 = 0f;
    var i_2: u32;
    var i_3: u32 = 32u;

    let n_1 = params.num_groups;
    let lid_1 = local_id_1.x;
    i_2 = lid_1;
    loop {
        let _e8 = i_2;
        if (_e8 < n_1) {
        } else {
            break;
        }
        {
            let _e12 = i_2;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum;
            sum = (_e15 + _e14);
        }
        continuing {
            let _e18 = i_2;
            i_2 = (_e18 + 64u);
        }
    }
    let _e22 = sum;
    scratch1_[lid_1] = _e22;
    workgroupBarrier();
    loop {
        let _e24 = i_3;
        if (_e24 > 0u) {
        } else {
            break;
        }
        {
            let _e27 = i_3;
            if (lid_1 < _e27) {
                let _e32 = i_3;
                let _e35 = scratch1_[(lid_1 + _e32)];
                let _e36 = scratch1_[lid_1];
                scratch1_[lid_1] = (_e36 + _e35);
            }
            workgroupBarrier();
        }
        continuing {
            let _e39 = i_3;
            i_3 = (_e39 >> 1u);
        }
    }
    if (lid_1 == 0u) {
        let _e47 = scratch1_[0];
        scalars.r0_v = _e47;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn init_cg_scalars(@builtin(local_invocation_id) local_id_2: vec3<u32>) {
    var sum_1: f32 = 0f;
    var i_4: u32;
    var i_5: u32 = 32u;

    let n_2 = params.num_groups;
    let lid_2 = local_id_2.x;
    i_4 = lid_2;
    loop {
        let _e8 = i_4;
        if (_e8 < n_2) {
        } else {
            break;
        }
        {
            let _e12 = i_4;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum_1;
            sum_1 = (_e15 + _e14);
        }
        continuing {
            let _e18 = i_4;
            i_4 = (_e18 + 64u);
        }
    }
    let _e22 = sum_1;
    scratch1_[lid_2] = _e22;
    workgroupBarrier();
    loop {
        let _e24 = i_5;
        if (_e24 > 0u) {
        } else {
            break;
        }
        {
            let _e27 = i_5;
            if (lid_2 < _e27) {
                let _e32 = i_5;
                let _e35 = scratch1_[(lid_2 + _e32)];
                let _e36 = scratch1_[lid_2];
                scratch1_[lid_2] = (_e36 + _e35);
            }
            workgroupBarrier();
        }
        continuing {
            let _e39 = i_5;
            i_5 = (_e39 >> 1u);
        }
    }
    if (lid_2 == 0u) {
        let _e47 = scratch1_[0];
        scalars.rho_old = _e47;
        scalars.alpha = 0f;
        scalars.beta = 0f;
        return;
    } else {
        return;
    }
}
"#;
}
pub mod schur_precond {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PrecondParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub u0: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub u1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad0: u32,
    }
    impl PrecondParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            omega: f32,
            unknowns_per_cell: u32,
            u0: u32,
            u1: u32,
            p: u32,
            _pad0: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                omega,
                unknowns_per_cell,
                u0,
                u1,
                p,
                _pad0,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const RELAX_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_relax_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline relax_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("relax_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CORRECT_VELOCITY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_correct_velocity_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline correct_velocity"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("correct_velocity"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PREDICT_AND_FORM_SCHUR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_predict_and_form_schur_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline predict_and_form_schur"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("predict_and_form_schur"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_RELAX_PRESSURE: &str = "relax_pressure";
    pub const ENTRY_CORRECT_VELOCITY: &str = "correct_velocity";
    pub const ENTRY_PREDICT_AND_FORM_SCHUR: &str = "predict_and_form_schur";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub r_in: wgpu::BufferBinding<'a>,
        pub z_out: wgpu::BufferBinding<'a>,
        pub temp_p: wgpu::BufferBinding<'a>,
        pub p_sol: wgpu::BufferBinding<'a>,
        pub p_prev: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub r_in: wgpu::BindGroupEntry<'a>,
        pub z_out: wgpu::BindGroupEntry<'a>,
        pub temp_p: wgpu::BindGroupEntry<'a>,
        pub p_sol: wgpu::BindGroupEntry<'a>,
        pub p_prev: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                r_in: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.r_in),
                },
                z_out: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.z_out),
                },
                temp_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.temp_p),
                },
                p_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.p_sol),
                },
                p_prev: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.p_prev),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [self.r_in, self.z_out, self.temp_p, self.p_sol, self.p_prev]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"r_in\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"z_out\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"temp_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"p_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"p_prev\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_v_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_v_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_v_inv: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_v_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [
                self.diag_u_inv,
                self.diag_v_inv,
                self.diag_p_inv,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_v_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::schur_precond::PrecondParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub p_row_offsets: wgpu::BufferBinding<'a>,
        pub p_col_indices: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub p_row_offsets: wgpu::BindGroupEntry<'a>,
        pub p_col_indices: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                p_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.p_row_offsets),
                },
                p_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.p_col_indices),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.p_row_offsets, self.p_col_indices, self.p_matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"p_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"p_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("SchurPrecond::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("schur_precond.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PrecondParams {
    n: u32,
    num_cells: u32,
    omega: f32,
    unknowns_per_cell: u32,
    u0_: u32,
    u1_: u32,
    p: u32,
    _pad0_: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage> r_in: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> z_out: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> temp_p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> p_sol: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> p_prev: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_v_inv: array<f32>;
@group(2) @binding(2) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(2) @binding(3) 
var<uniform> params: PrecondParams;
@group(3) @binding(0) 
var<storage> p_row_offsets: array<u32>;
@group(3) @binding(1) 
var<storage> p_col_indices: array<u32>;
@group(3) @binding(2) 
var<storage> p_matrix_values: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

fn global_cell(global_id_3: vec3<u32>, num_workgroups_3: vec3<u32>) -> u32 {
    return ((global_id_3.y * (num_workgroups_3.x * WORKGROUP_SIZE)) + global_id_3.x);
}

@compute @workgroup_size(64, 1, 1) 
fn relax_pressure(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sigma: f32 = 0f;
    var k: u32;

    let _e3 = global_cell(global_id, num_workgroups);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let start = p_row_offsets[_e3];
    let end = p_row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col_cell = p_col_indices[_e20];
            if (col_cell != _e3) {
                let _e25 = k;
                let _e27 = p_matrix_values[_e25];
                let _e31 = p_sol[col_cell];
                let _e33 = sigma;
                sigma = (_e33 + (_e27 * _e31));
            }
        }
        continuing {
            let _e36 = k;
            k = (_e36 + 1u);
        }
    }
    let d_inv = diag_p_inv[_e3];
    let rhs = temp_p[_e3];
    let _e44 = sigma;
    let hat_x = (d_inv * (rhs - _e44));
    let x_prev = p_prev[_e3];
    let _e52 = params.omega;
    let x_new = mix(x_prev, hat_x, _e52);
    p_prev[_e3] = x_new;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn correct_velocity(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var correction_u: f32 = 0f;
    var k_1: u32;
    var correction_v: f32 = 0f;
    var k_2: u32;

    let _e3 = global_cell(global_id_1, num_workgroups_1);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base = (_e3 * _e10);
    let _e14 = params.u0_;
    let row_u = (base + _e14);
    let _e18 = params.u1_;
    let row_v = (base + _e18);
    let p_val = p_sol[_e3];
    let start_u = row_offsets[row_u];
    let end_u = row_offsets[(row_u + 1u)];
    k_1 = start_u;
    loop {
        let _e32 = k_1;
        if (_e32 < end_u) {
        } else {
            break;
        }
        {
            let _e35 = k_1;
            let col = col_indices[_e35];
            let _e40 = params.unknowns_per_cell;
            let _e44 = params.p;
            if ((col % _e40) == _e44) {
                let _e48 = params.unknowns_per_cell;
                let p_cell = (col / _e48);
                let _e51 = k_1;
                let _e53 = matrix_values[_e51];
                let _e57 = p_sol[p_cell];
                let _e59 = correction_u;
                correction_u = (_e59 + (_e53 * _e57));
            }
        }
        continuing {
            let _e62 = k_1;
            k_1 = (_e62 + 1u);
        }
    }
    let _e68 = diag_u_inv[_e3];
    let _e69 = correction_u;
    let _e71 = z_out[row_u];
    z_out[row_u] = (_e71 - (_e68 * _e69));
    let start_v = row_offsets[row_v];
    let end_v = row_offsets[(row_v + 1u)];
    k_2 = start_v;
    loop {
        let _e82 = k_2;
        if (_e82 < end_v) {
        } else {
            break;
        }
        {
            let _e85 = k_2;
            let col_1 = col_indices[_e85];
            let _e90 = params.unknowns_per_cell;
            let _e94 = params.p;
            if ((col_1 % _e90) == _e94) {
                let _e98 = params.unknowns_per_cell;
                let p_cell_1 = (col_1 / _e98);
                let _e101 = k_2;
                let _e103 = matrix_values[_e101];
                let _e107 = p_sol[p_cell_1];
                let _e109 = correction_v;
                correction_v = (_e109 + (_e103 * _e107));
            }
        }
        continuing {
            let _e112 = k_2;
            k_2 = (_e112 + 1u);
        }
    }
    let _e118 = diag_v_inv[_e3];
    let _e119 = correction_v;
    let _e121 = z_out[row_v];
    z_out[row_v] = (_e121 - (_e118 * _e119));
    let _e126 = params.p;
    z_out[(base + _e126)] = p_val;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn predict_and_form_schur(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var c: u32 = 0u;
    var rhs_p: f32;
    var k_3: u32;
    var z_val: f32;

    let _e3 = global_cell(global_id_2, num_workgroups_2);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base_1 = (_e3 * _e10);
    let _e14 = params.u0_;
    let row_u_1 = (base_1 + _e14);
    let _e18 = params.u1_;
    let row_v_1 = (base_1 + _e18);
    let _e22 = params.p;
    let row_p = (base_1 + _e22);
    loop {
        let _e25 = c;
        let _e28 = params.unknowns_per_cell;
        if (_e25 < _e28) {
        } else {
            break;
        }
        {
            let _e31 = c;
            let _e35 = c;
            let _e38 = r_in[(base_1 + _e35)];
            z_out[(base_1 + _e31)] = _e38;
        }
        continuing {
            let _e40 = c;
            c = (_e40 + 1u);
        }
    }
    let r_u = r_in[row_u_1];
    let r_v = r_in[row_v_1];
    let _e52 = diag_u_inv[_e3];
    z_out[row_u_1] = (_e52 * r_u);
    let _e58 = diag_v_inv[_e3];
    z_out[row_v_1] = (_e58 * r_v);
    z_out[row_p] = 0f;
    let _e65 = r_in[row_p];
    rhs_p = _e65;
    let start_1 = row_offsets[row_p];
    let end_1 = row_offsets[(row_p + 1u)];
    k_3 = start_1;
    loop {
        let _e76 = k_3;
        if (_e76 < end_1) {
        } else {
            break;
        }
        {
            let _e79 = k_3;
            let col_2 = col_indices[_e79];
            let _e84 = params.unknowns_per_cell;
            let rem = (col_2 % _e84);
            z_val = 0f;
            let _e90 = params.u0_;
            if (rem == _e90) {
                let _e94 = params.unknowns_per_cell;
                let c_1 = (col_2 / _e94);
                let _e98 = r_in[col_2];
                let _e101 = diag_u_inv[c_1];
                z_val = (_e98 * _e101);
            } else {
                let _e105 = params.u1_;
                if (rem == _e105) {
                    let _e109 = params.unknowns_per_cell;
                    let c_2 = (col_2 / _e109);
                    let _e113 = r_in[col_2];
                    let _e116 = diag_v_inv[c_2];
                    z_val = (_e113 * _e116);
                }
            }
            let _e119 = k_3;
            let _e121 = matrix_values[_e119];
            let _e122 = z_val;
            let _e124 = rhs_p;
            rhs_p = (_e124 - (_e121 * _e122));
        }
        continuing {
            let _e127 = k_3;
            k_3 = (_e127 + 1u);
        }
    }
    let _e131 = rhs_p;
    temp_p[_e3] = _e131;
    let _e136 = diag_p_inv[_e3];
    let _e137 = rhs_p;
    p_sol[_e3] = (_e136 * _e137);
    p_prev[_e3] = 0f;
    return;
}
"#;
}
pub mod schur_precond_generic {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PrecondParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub u_len: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad0: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 32, size: 16, type: `vec4<u32>`"]
        pub u0123: [u32; 4],
        #[doc = "offset: 48, size: 16, type: `vec4<u32>`"]
        pub u4567: [u32; 4],
    }
    impl PrecondParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            omega: f32,
            unknowns_per_cell: u32,
            p: u32,
            u_len: u32,
            _pad0: u32,
            _pad1: u32,
            u0123: [u32; 4],
            u4567: [u32; 4],
        ) -> Self {
            Self {
                n,
                num_cells,
                omega,
                unknowns_per_cell,
                p,
                u_len,
                _pad0,
                _pad1,
                u0123,
                u4567,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const RELAX_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_relax_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline relax_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("relax_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CORRECT_VELOCITY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_correct_velocity_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline correct_velocity"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("correct_velocity"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PREDICT_AND_FORM_SCHUR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_predict_and_form_schur_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline predict_and_form_schur"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("predict_and_form_schur"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_RELAX_PRESSURE: &str = "relax_pressure";
    pub const ENTRY_CORRECT_VELOCITY: &str = "correct_velocity";
    pub const ENTRY_PREDICT_AND_FORM_SCHUR: &str = "predict_and_form_schur";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub r_in: wgpu::BufferBinding<'a>,
        pub z_out: wgpu::BufferBinding<'a>,
        pub temp_p: wgpu::BufferBinding<'a>,
        pub p_sol: wgpu::BufferBinding<'a>,
        pub p_prev: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub r_in: wgpu::BindGroupEntry<'a>,
        pub z_out: wgpu::BindGroupEntry<'a>,
        pub temp_p: wgpu::BindGroupEntry<'a>,
        pub p_sol: wgpu::BindGroupEntry<'a>,
        pub p_prev: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                r_in: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.r_in),
                },
                z_out: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.z_out),
                },
                temp_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.temp_p),
                },
                p_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.p_sol),
                },
                p_prev: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.p_prev),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [self.r_in, self.z_out, self.temp_p, self.p_sol, self.p_prev]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"r_in\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"z_out\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"temp_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"p_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"p_prev\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.diag_u_inv, self.diag_p_inv, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::schur_precond_generic::PrecondParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub p_row_offsets: wgpu::BufferBinding<'a>,
        pub p_col_indices: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub p_row_offsets: wgpu::BindGroupEntry<'a>,
        pub p_col_indices: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                p_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.p_row_offsets),
                },
                p_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.p_col_indices),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.p_row_offsets, self.p_col_indices, self.p_matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"p_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"p_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("SchurPrecondGeneric::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("schur_precond_generic.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PrecondParams {
    n: u32,
    num_cells: u32,
    omega: f32,
    unknowns_per_cell: u32,
    p: u32,
    u_len: u32,
    _pad0_: u32,
    _pad1_: u32,
    u0123_: vec4<u32>,
    u4567_: vec4<u32>,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage> r_in: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> z_out: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> temp_p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> p_sol: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> p_prev: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(2) @binding(2) 
var<uniform> params: PrecondParams;
@group(3) @binding(0) 
var<storage> p_row_offsets: array<u32>;
@group(3) @binding(1) 
var<storage> p_col_indices: array<u32>;
@group(3) @binding(2) 
var<storage> p_matrix_values: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

fn u_index(i_3: u32) -> u32 {
    if (i_3 < 4u) {
        let _e6 = params.u0123_[i_3];
        return _e6;
    }
    let _e12 = params.u4567_[(i_3 - 4u)];
    return _e12;
}

fn global_cell(global_id_3: vec3<u32>, num_workgroups_3: vec3<u32>) -> u32 {
    return ((global_id_3.y * (num_workgroups_3.x * WORKGROUP_SIZE)) + global_id_3.x);
}

@compute @workgroup_size(64, 1, 1) 
fn relax_pressure(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sigma: f32 = 0f;
    var k: u32;

    let _e3 = global_cell(global_id, num_workgroups);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let start = p_row_offsets[_e3];
    let end = p_row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col_cell = p_col_indices[_e20];
            if (col_cell != _e3) {
                let _e25 = k;
                let _e27 = p_matrix_values[_e25];
                let _e31 = p_sol[col_cell];
                let _e33 = sigma;
                sigma = (_e33 + (_e27 * _e31));
            }
        }
        continuing {
            let _e36 = k;
            k = (_e36 + 1u);
        }
    }
    let d_inv = diag_p_inv[_e3];
    let rhs = temp_p[_e3];
    let _e44 = sigma;
    let hat_x = (d_inv * (rhs - _e44));
    let x_prev = p_prev[_e3];
    let _e52 = params.omega;
    let x_new = mix(x_prev, hat_x, _e52);
    p_prev[_e3] = x_new;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn correct_velocity(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var i: u32 = 0u;
    var correction_u: f32;
    var k_1: u32;

    let _e3 = global_cell(global_id_1, num_workgroups_1);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base = (_e3 * _e10);
    let p_val = p_sol[_e3];
    loop {
        let _e16 = i;
        let _e19 = params.u_len;
        if (_e16 < _e19) {
        } else {
            break;
        }
        {
            let _e21 = i;
            let _e22 = u_index(_e21);
            let row_u = (base + _e22);
            let start_u = row_offsets[row_u];
            let end_u = row_offsets[(row_u + 1u)];
            correction_u = 0f;
            k_1 = start_u;
            loop {
                let _e35 = k_1;
                if (_e35 < end_u) {
                } else {
                    break;
                }
                {
                    let _e38 = k_1;
                    let col = col_indices[_e38];
                    let _e43 = params.unknowns_per_cell;
                    let _e47 = params.p;
                    if ((col % _e43) == _e47) {
                        let _e51 = params.unknowns_per_cell;
                        let p_cell = (col / _e51);
                        let _e54 = k_1;
                        let _e56 = matrix_values[_e54];
                        let _e59 = p_sol[p_cell];
                        let _e61 = correction_u;
                        correction_u = (_e61 + (_e56 * _e59));
                    }
                }
                continuing {
                    let _e64 = k_1;
                    k_1 = (_e64 + 1u);
                }
            }
            let _e71 = params.u_len;
            let _e73 = i;
            let _e76 = diag_u_inv[((_e3 * _e71) + _e73)];
            let _e77 = correction_u;
            let _e79 = z_out[row_u];
            z_out[row_u] = (_e79 - (_e76 * _e77));
        }
        continuing {
            let _e82 = i;
            i = (_e82 + 1u);
        }
    }
    let _e87 = params.p;
    z_out[(base + _e87)] = p_val;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn predict_and_form_schur(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var c: u32 = 0u;
    var i_1: u32 = 0u;
    var rhs_p: f32;
    var k_2: u32;
    var z_val: f32;
    var i_2: u32;

    let _e3 = global_cell(global_id_2, num_workgroups_2);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base_1 = (_e3 * _e10);
    let _e14 = params.p;
    let row_p = (base_1 + _e14);
    loop {
        let _e17 = c;
        let _e20 = params.unknowns_per_cell;
        if (_e17 < _e20) {
        } else {
            break;
        }
        {
            let _e23 = c;
            let _e27 = c;
            let _e30 = r_in[(base_1 + _e27)];
            z_out[(base_1 + _e23)] = _e30;
        }
        continuing {
            let _e32 = c;
            c = (_e32 + 1u);
        }
    }
    loop {
        let _e35 = i_1;
        let _e38 = params.u_len;
        if (_e35 < _e38) {
        } else {
            break;
        }
        {
            let _e40 = i_1;
            let _e41 = u_index(_e40);
            let row_u_1 = (base_1 + _e41);
            let _e48 = params.u_len;
            let _e50 = i_1;
            let _e53 = diag_u_inv[((_e3 * _e48) + _e50)];
            let _e56 = r_in[row_u_1];
            z_out[row_u_1] = (_e53 * _e56);
        }
        continuing {
            let _e59 = i_1;
            i_1 = (_e59 + 1u);
        }
    }
    z_out[row_p] = 0f;
    let _e66 = r_in[row_p];
    rhs_p = _e66;
    let start_1 = row_offsets[row_p];
    let end_1 = row_offsets[(row_p + 1u)];
    k_2 = start_1;
    loop {
        let _e77 = k_2;
        if (_e77 < end_1) {
        } else {
            break;
        }
        {
            let _e80 = k_2;
            let col_1 = col_indices[_e80];
            let _e85 = params.unknowns_per_cell;
            let rem = (col_1 % _e85);
            z_val = 0f;
            i_2 = 0u;
            loop {
                let _e91 = i_2;
                let _e94 = params.u_len;
                if (_e91 < _e94) {
                } else {
                    break;
                }
                {
                    let _e96 = i_2;
                    let _e97 = u_index(_e96);
                    if (rem == _e97) {
                        let _e101 = params.unknowns_per_cell;
                        let c_1 = (col_1 / _e101);
                        let _e105 = r_in[col_1];
                        let _e109 = params.u_len;
                        let _e111 = i_2;
                        let _e114 = diag_u_inv[((c_1 * _e109) + _e111)];
                        z_val = (_e105 * _e114);
                        break;
                    }
                }
                continuing {
                    let _e117 = i_2;
                    i_2 = (_e117 + 1u);
                }
            }
            let _e120 = k_2;
            let _e122 = matrix_values[_e120];
            let _e123 = z_val;
            let _e125 = rhs_p;
            rhs_p = (_e125 - (_e122 * _e123));
        }
        continuing {
            let _e128 = k_2;
            k_2 = (_e128 + 1u);
        }
    }
    let _e132 = rhs_p;
    temp_p[_e3] = _e132;
    let _e137 = diag_p_inv[_e3];
    let _e138 = rhs_p;
    p_sol[_e3] = (_e137 * _e138);
    p_prev[_e3] = 0f;
    return;
}
"#;
}
