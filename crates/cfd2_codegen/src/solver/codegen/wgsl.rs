use crate::solver::gpu::enums::TimeScheme;
use crate::solver::scheme::Scheme;

use super::dsl::EnumExpr;
use super::ir::{DiscreteOp, DiscreteOpKind, DiscreteSystem};
use super::wgsl_ast::{Block, Expr, Function, Item, Module, Param, Stmt, Type};
use super::wgsl_dsl as dsl;
use crate::solver::ir::{Coefficient, FieldKind};

pub fn generate_wgsl(system: &DiscreteSystem) -> String {
    generate_wgsl_module(system).to_wgsl()
}

pub fn generate_wgsl_library(system: &DiscreteSystem) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (library)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(generate_wgsl_library_items(system));
    module.to_wgsl()
}

pub fn generate_wgsl_library_items(system: &DiscreteSystem) -> Vec<Item> {
    let mut items = Vec::new();

    for equation in &system.equations {
        items.push(Item::Comment(format!(
            "equation: {} ({})",
            equation.target.name(),
            equation.target.kind().as_str()
        )));
        for op in &equation.ops {
            items.push(Item::Comment(term_comment(op)));
            items.push(Item::Function(term_function(op)));
        }
        items.push(Item::Function(codegen_assemble_fn(equation)));
    }

    if has_convection(system) {
        items.push(Item::Function(codegen_conv_coeff_fn()));
    }
    if has_diffusion(system) {
        items.push(Item::Function(codegen_diff_coeff_fn()));
    }

    items
}

fn generate_wgsl_module(system: &DiscreteSystem) -> Module {
    assert_system_main_supported(system);
    let mut module = Module::new();
    module.push(Item::Comment("GENERATED BY CFD2 CODEGEN".to_string()));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));

    for equation in &system.equations {
        module.push(Item::Comment(format!(
            "equation: {} ({})",
            equation.target.name(),
            equation.target.kind().as_str()
        )));
        for op in &equation.ops {
            module.push(Item::Comment(term_comment(op)));
            module.push(Item::Function(term_function(op)));
        }
        module.push(Item::Function(equation_assemble_fn(equation)));
    }

    module.push(Item::Function(main_fn(system)));

    if has_convection(system) {
        module.push(Item::Function(codegen_conv_coeff_fn()));
    }
    if has_diffusion(system) {
        module.push(Item::Function(codegen_diff_coeff_fn()));
    }

    module
}

fn assert_system_main_supported(system: &DiscreteSystem) {
    for eq in &system.equations {
        if matches!(eq.target.kind(), FieldKind::Vector3) {
            panic!(
                "system_main WGSL codegen does not support FieldKind::Vector3 yet; use the generic-coupled pipeline or extend src/solver/codegen/wgsl.rs"
            );
        }
    }
}

fn term_comment(op: &DiscreteOp) -> String {
    let mut line = format!(
        "term: {} target={} field={} discretization={} scheme={}",
        op.kind.as_str(),
        op.target.name(),
        op.field.name(),
        op.discretization.as_str(),
        scheme_name(op.scheme),
    );

    if let Some(flux) = &op.flux {
        line.push_str(&format!(" flux={}", flux.name()));
    }

    if let Some(coeff) = &op.coeff {
        line.push(' ');
        line.push_str("coeff=");
        line.push_str(&format_coeff(coeff));
    }

    line
}

fn term_function(op: &DiscreteOp) -> Function {
    match op.kind {
        DiscreteOpKind::TimeDerivative => term_ddt_fn(op),
        DiscreteOpKind::Convection => term_div_fn(op),
        DiscreteOpKind::Diffusion => term_laplacian_fn(op),
        DiscreteOpKind::Gradient => term_grad_fn(op),
        DiscreteOpKind::Source => term_source_fn(op),
    }
}

fn term_ddt_fn(op: &DiscreteOp) -> Function {
    let name = term_function_name(op);
    let params = match op.target.kind() {
        FieldKind::Vector2 => vec![
            Param::new("vol", Type::F32, Vec::new()),
            Param::new("rho", Type::F32, Vec::new()),
            Param::new("dt", Type::F32, Vec::new()),
            Param::new("dt_old", Type::F32, Vec::new()),
            Param::new("time_scheme", Type::U32, Vec::new()),
            Param::new("phi_n", Type::vec2_f32(), Vec::new()),
            Param::new("phi_nm1", Type::vec2_f32(), Vec::new()),
        ],
        FieldKind::Vector3 => unreachable!("Vector3 rejected by assert_system_main_supported"),
        FieldKind::Scalar => vec![
            Param::new("vol", Type::F32, Vec::new()),
            Param::new("rho", Type::F32, Vec::new()),
            Param::new("dt", Type::F32, Vec::new()),
            Param::new("dt_old", Type::F32, Vec::new()),
            Param::new("time_scheme", Type::U32, Vec::new()),
            Param::new("phi_n", Type::F32, Vec::new()),
            Param::new("phi_nm1", Type::F32, Vec::new()),
        ],
    };

    let mut body = Vec::new();
    body.push(Stmt::Comment(
        "implicit time derivative (BDF1/BDF2)".to_string(),
    ));
    body.push(dsl::let_expr(
        "base_coeff",
        Expr::ident("rho") * Expr::ident("vol") / Expr::ident("dt"),
    ));
    body.push(dsl::var_typed_expr(
        "diag",
        Type::F32,
        Some(Expr::ident("base_coeff")),
    ));

    match op.target.kind() {
        FieldKind::Vector2 => {
            body.push(dsl::var_typed_expr(
                "rhs_x",
                Type::F32,
                Some(Expr::ident("base_coeff") * Expr::ident("phi_n").field("x")),
            ));
            body.push(dsl::var_typed_expr(
                "rhs_y",
                Type::F32,
                Some(Expr::ident("base_coeff") * Expr::ident("phi_n").field("y")),
            ));
            body.push(dsl::if_block_expr(
                EnumExpr::<TimeScheme>::from_expr(Expr::ident("time_scheme")).eq(TimeScheme::BDF2),
                dsl::block(vec![
                    dsl::let_expr("r", Expr::ident("dt") / Expr::ident("dt_old")),
                    dsl::assign_expr(
                        Expr::ident("diag"),
                        Expr::ident("base_coeff") * (Expr::ident("r") * 2.0 + 1.0)
                            / (Expr::ident("r") + 1.0),
                    ),
                    dsl::let_expr("factor_n", Expr::ident("r") + 1.0),
                    dsl::let_expr(
                        "factor_nm1",
                        (Expr::ident("r") * Expr::ident("r")) / (Expr::ident("r") + 1.0),
                    ),
                    dsl::assign_expr(
                        Expr::ident("rhs_x"),
                        Expr::ident("base_coeff")
                            * (Expr::ident("factor_n") * Expr::ident("phi_n").field("x")
                                - Expr::ident("factor_nm1") * Expr::ident("phi_nm1").field("x")),
                    ),
                    dsl::assign_expr(
                        Expr::ident("rhs_y"),
                        Expr::ident("base_coeff")
                            * (Expr::ident("factor_n") * Expr::ident("phi_n").field("y")
                                - Expr::ident("factor_nm1") * Expr::ident("phi_nm1").field("y")),
                    ),
                ]),
                None,
            ));
            body.push(Stmt::Return(Some(Expr::call_named(
                "vec3<f32>",
                vec![
                    Expr::ident("diag"),
                    Expr::ident("rhs_x"),
                    Expr::ident("rhs_y"),
                ],
            ))));
            Function::new(
                name,
                params,
                Some(Type::Vec3(Box::new(Type::F32))),
                Vec::new(),
                Block::new(body),
            )
        }
        FieldKind::Vector3 => unreachable!("Vector3 rejected by assert_system_main_supported"),
        FieldKind::Scalar => {
            body.push(dsl::var_typed_expr(
                "rhs",
                Type::F32,
                Some(Expr::ident("base_coeff") * Expr::ident("phi_n")),
            ));
            body.push(dsl::if_block_expr(
                EnumExpr::<TimeScheme>::from_expr(Expr::ident("time_scheme")).eq(TimeScheme::BDF2),
                dsl::block(vec![
                    dsl::let_expr("r", Expr::ident("dt") / Expr::ident("dt_old")),
                    dsl::assign_expr(
                        Expr::ident("diag"),
                        Expr::ident("base_coeff") * (Expr::ident("r") * 2.0 + 1.0)
                            / (Expr::ident("r") + 1.0),
                    ),
                    dsl::let_expr("factor_n", Expr::ident("r") + 1.0),
                    dsl::let_expr(
                        "factor_nm1",
                        (Expr::ident("r") * Expr::ident("r")) / (Expr::ident("r") + 1.0),
                    ),
                    dsl::assign_expr(
                        Expr::ident("rhs"),
                        Expr::ident("base_coeff")
                            * (Expr::ident("factor_n") * Expr::ident("phi_n")
                                - Expr::ident("factor_nm1") * Expr::ident("phi_nm1")),
                    ),
                ]),
                None,
            ));
            body.push(Stmt::Return(Some(Expr::call_named(
                "vec2<f32>",
                vec![Expr::ident("diag"), Expr::ident("rhs")],
            ))));
            Function::new(
                name,
                params,
                Some(Type::Vec2(Box::new(Type::F32))),
                Vec::new(),
                Block::new(body),
            )
        }
    }
}

fn term_div_fn(op: &DiscreteOp) -> Function {
    let name = term_function_name(op);
    let mut body = Vec::new();
    body.push(Stmt::Comment(
        "finite-volume convection with optional higher-order correction".to_string(),
    ));
    body.push(dsl::let_expr(
        "conv_coeff",
        Expr::call_named("codegen_conv_coeff", vec![Expr::ident("flux")]),
    ));
    body.push(dsl::let_expr(
        "diag_coeff",
        Expr::ident("conv_coeff").field("x"),
    ));
    body.push(dsl::let_expr(
        "off_coeff",
        Expr::ident("conv_coeff").field("y"),
    ));

    match op.target.kind() {
        FieldKind::Vector2 => {
            let params = vec![
                Param::new("flux", Type::F32, Vec::new()),
                Param::new("phi_own", Type::vec2_f32(), Vec::new()),
                Param::new("phi_neigh", Type::vec2_f32(), Vec::new()),
                Param::new("grad_own_u", Type::vec2_f32(), Vec::new()),
                Param::new("grad_own_v", Type::vec2_f32(), Vec::new()),
                Param::new("grad_neigh_u", Type::vec2_f32(), Vec::new()),
                Param::new("grad_neigh_v", Type::vec2_f32(), Vec::new()),
                Param::new("r_upwind", Type::vec2_f32(), Vec::new()),
                Param::new("r_downwind", Type::vec2_f32(), Vec::new()),
                Param::new("r_cd", Type::vec2_f32(), Vec::new()),
            ];

            body.push(dsl::var_typed_expr(
                "phi_upwind",
                Type::vec2_f32(),
                Some(Expr::ident("phi_own")),
            ));
            body.push(dsl::var_typed_expr(
                "phi_ho",
                Type::vec2_f32(),
                Some(Expr::ident("phi_own")),
            ));
            body.push(dsl::if_block_expr(
                Expr::ident("flux").le(0.0),
                dsl::block(vec![
                    dsl::assign_expr(Expr::ident("phi_upwind"), Expr::ident("phi_neigh")),
                    dsl::assign_expr(Expr::ident("phi_ho"), Expr::ident("phi_neigh")),
                ]),
                None,
            ));

            match op.scheme {
                Scheme::SecondOrderUpwind
                | Scheme::SecondOrderUpwindMinMod
                | Scheme::SecondOrderUpwindVanLeer => {
                    body.push(dsl::if_block_expr(
                        Expr::ident("flux").gt(0.0),
                        dsl::block(vec![
                            dsl::assign_expr(
                                Expr::ident("phi_ho").field("x"),
                                Expr::ident("phi_own").field("x")
                                    + (Expr::ident("grad_own_u").field("x")
                                        * Expr::ident("r_upwind").field("x")
                                        + Expr::ident("grad_own_u").field("y")
                                            * Expr::ident("r_upwind").field("y")),
                            ),
                            dsl::assign_expr(
                                Expr::ident("phi_ho").field("y"),
                                Expr::ident("phi_own").field("y")
                                    + (Expr::ident("grad_own_v").field("x")
                                        * Expr::ident("r_upwind").field("x")
                                        + Expr::ident("grad_own_v").field("y")
                                            * Expr::ident("r_upwind").field("y")),
                            ),
                        ]),
                        Some(dsl::block(vec![
                            dsl::assign_expr(
                                Expr::ident("phi_ho").field("x"),
                                Expr::ident("phi_neigh").field("x")
                                    + (Expr::ident("grad_neigh_u").field("x")
                                        * Expr::ident("r_downwind").field("x")
                                        + Expr::ident("grad_neigh_u").field("y")
                                            * Expr::ident("r_downwind").field("y")),
                            ),
                            dsl::assign_expr(
                                Expr::ident("phi_ho").field("y"),
                                Expr::ident("phi_neigh").field("y")
                                    + (Expr::ident("grad_neigh_v").field("x")
                                        * Expr::ident("r_downwind").field("x")
                                        + Expr::ident("grad_neigh_v").field("y")
                                            * Expr::ident("r_downwind").field("y")),
                            ),
                        ])),
                    ));
                }
                Scheme::QUICK | Scheme::QUICKMinMod | Scheme::QUICKVanLeer => {
                    body.push(dsl::if_block_expr(
                        Expr::ident("flux").gt(0.0),
                        dsl::block(vec![
                            dsl::assign_expr(
                                Expr::ident("phi_ho").field("x"),
                                Expr::ident("phi_own").field("x") * 0.625
                                    + Expr::ident("phi_neigh").field("x") * 0.375
                                    + (Expr::ident("grad_own_u").field("x")
                                        * Expr::ident("r_cd").field("x")
                                        + Expr::ident("grad_own_u").field("y")
                                            * Expr::ident("r_cd").field("y"))
                                        * 0.125,
                            ),
                            dsl::assign_expr(
                                Expr::ident("phi_ho").field("y"),
                                Expr::ident("phi_own").field("y") * 0.625
                                    + Expr::ident("phi_neigh").field("y") * 0.375
                                    + (Expr::ident("grad_own_v").field("x")
                                        * Expr::ident("r_cd").field("x")
                                        + Expr::ident("grad_own_v").field("y")
                                            * Expr::ident("r_cd").field("y"))
                                        * 0.125,
                            ),
                        ]),
                        Some(dsl::block(vec![
                            dsl::assign_expr(
                                Expr::ident("phi_ho").field("x"),
                                Expr::ident("phi_neigh").field("x") * 0.625
                                    + Expr::ident("phi_own").field("x") * 0.375
                                    + (Expr::ident("grad_neigh_u").field("x")
                                        * Expr::ident("r_cd").field("x")
                                        + Expr::ident("grad_neigh_u").field("y")
                                            * Expr::ident("r_cd").field("y"))
                                        * 0.125,
                            ),
                            dsl::assign_expr(
                                Expr::ident("phi_ho").field("y"),
                                Expr::ident("phi_neigh").field("y") * 0.625
                                    + Expr::ident("phi_own").field("y") * 0.375
                                    + (Expr::ident("grad_neigh_v").field("x")
                                        * Expr::ident("r_cd").field("x")
                                        + Expr::ident("grad_neigh_v").field("y")
                                            * Expr::ident("r_cd").field("y"))
                                        * 0.125,
                            ),
                        ])),
                    ));
                }
                Scheme::Upwind => {}
            }

            body.push(dsl::let_expr(
                "rhs_corr_x",
                Expr::ident("flux")
                    * (Expr::ident("phi_ho").field("x") - Expr::ident("phi_upwind").field("x")),
            ));
            body.push(dsl::let_expr(
                "rhs_corr_y",
                Expr::ident("flux")
                    * (Expr::ident("phi_ho").field("y") - Expr::ident("phi_upwind").field("y")),
            ));
            body.push(Stmt::Return(Some(Expr::call_named(
                "vec4<f32>",
                vec![
                    Expr::ident("diag_coeff"),
                    Expr::ident("off_coeff"),
                    Expr::ident("rhs_corr_x"),
                    Expr::ident("rhs_corr_y"),
                ],
            ))));
            Function::new(
                name,
                params,
                Some(Type::Vec4(Box::new(Type::F32))),
                Vec::new(),
                Block::new(body),
            )
        }
        FieldKind::Vector3 => unreachable!("Vector3 rejected by assert_system_main_supported"),
        FieldKind::Scalar => {
            let params = vec![
                Param::new("flux", Type::F32, Vec::new()),
                Param::new("phi_own", Type::F32, Vec::new()),
                Param::new("phi_neigh", Type::F32, Vec::new()),
                Param::new("grad_own", Type::vec2_f32(), Vec::new()),
                Param::new("grad_neigh", Type::vec2_f32(), Vec::new()),
                Param::new("r_upwind", Type::vec2_f32(), Vec::new()),
                Param::new("r_downwind", Type::vec2_f32(), Vec::new()),
                Param::new("r_cd", Type::vec2_f32(), Vec::new()),
            ];

            body.push(dsl::var_typed_expr(
                "phi_upwind",
                Type::F32,
                Some(Expr::ident("phi_own")),
            ));
            body.push(dsl::var_typed_expr(
                "phi_ho",
                Type::F32,
                Some(Expr::ident("phi_own")),
            ));
            body.push(dsl::if_block_expr(
                Expr::ident("flux").le(0.0),
                dsl::block(vec![
                    dsl::assign_expr(Expr::ident("phi_upwind"), Expr::ident("phi_neigh")),
                    dsl::assign_expr(Expr::ident("phi_ho"), Expr::ident("phi_neigh")),
                ]),
                None,
            ));

            match op.scheme {
                Scheme::SecondOrderUpwind
                | Scheme::SecondOrderUpwindMinMod
                | Scheme::SecondOrderUpwindVanLeer => {
                    body.push(dsl::if_block_expr(
                        Expr::ident("flux").gt(0.0),
                        dsl::block(vec![dsl::assign_expr(
                            Expr::ident("phi_ho"),
                            Expr::ident("phi_own")
                                + (Expr::ident("grad_own").field("x")
                                    * Expr::ident("r_upwind").field("x")
                                    + Expr::ident("grad_own").field("y")
                                        * Expr::ident("r_upwind").field("y")),
                        )]),
                        Some(dsl::block(vec![dsl::assign_expr(
                            Expr::ident("phi_ho"),
                            Expr::ident("phi_neigh")
                                + (Expr::ident("grad_neigh").field("x")
                                    * Expr::ident("r_downwind").field("x")
                                    + Expr::ident("grad_neigh").field("y")
                                        * Expr::ident("r_downwind").field("y")),
                        )])),
                    ));
                }
                Scheme::QUICK | Scheme::QUICKMinMod | Scheme::QUICKVanLeer => {
                    body.push(dsl::if_block_expr(
                        Expr::ident("flux").gt(0.0),
                        dsl::block(vec![dsl::assign_expr(
                            Expr::ident("phi_ho"),
                            Expr::ident("phi_own") * 0.625
                                + Expr::ident("phi_neigh") * 0.375
                                + (Expr::ident("grad_own").field("x")
                                    * Expr::ident("r_cd").field("x")
                                    + Expr::ident("grad_own").field("y")
                                        * Expr::ident("r_cd").field("y"))
                                    * 0.125,
                        )]),
                        Some(dsl::block(vec![dsl::assign_expr(
                            Expr::ident("phi_ho"),
                            Expr::ident("phi_neigh") * 0.625
                                + Expr::ident("phi_own") * 0.375
                                + (Expr::ident("grad_neigh").field("x")
                                    * Expr::ident("r_cd").field("x")
                                    + Expr::ident("grad_neigh").field("y")
                                        * Expr::ident("r_cd").field("y"))
                                    * 0.125,
                        )])),
                    ));
                }
                Scheme::Upwind => {}
            }

            body.push(dsl::let_expr(
                "rhs_corr",
                Expr::ident("flux") * (Expr::ident("phi_ho") - Expr::ident("phi_upwind")),
            ));
            body.push(Stmt::Return(Some(Expr::call_named(
                "vec3<f32>",
                vec![
                    Expr::ident("diag_coeff"),
                    Expr::ident("off_coeff"),
                    Expr::ident("rhs_corr"),
                ],
            ))));
            Function::new(
                name,
                params,
                Some(Type::Vec3(Box::new(Type::F32))),
                Vec::new(),
                Block::new(body),
            )
        }
    }
}

fn term_laplacian_fn(op: &DiscreteOp) -> Function {
    let name = term_function_name(op);
    let params = vec![
        Param::new("mu", Type::F32, Vec::new()),
        Param::new("area", Type::F32, Vec::new()),
        Param::new("dist", Type::F32, Vec::new()),
    ];
    let body = Block::new(vec![
        Stmt::Comment("diffusion coefficient from mu * area / dist".to_string()),
        dsl::let_expr(
            "coeff",
            Expr::ident("mu") * Expr::ident("area") / Expr::ident("dist"),
        ),
        Stmt::Return(Some(Expr::call_named(
            "vec2<f32>",
            vec![Expr::ident("coeff"), -Expr::ident("coeff")],
        ))),
    ]);
    Function::new(
        name,
        params,
        Some(Type::Vec2(Box::new(Type::F32))),
        Vec::new(),
        body,
    )
}

fn term_grad_fn(op: &DiscreteOp) -> Function {
    let name = term_function_name(op);
    let params = vec![
        Param::new("area", Type::F32, Vec::new()),
        Param::new("normal", Type::vec2_f32(), Vec::new()),
        Param::new("lambda", Type::F32, Vec::new()),
    ];
    let body = match op.target.kind() {
        FieldKind::Vector2 => Block::new(vec![
            Stmt::Comment("pressure gradient coupling weights".to_string()),
            dsl::let_expr(
                "force_x",
                Expr::ident("area") * Expr::ident("normal").field("x"),
            ),
            dsl::let_expr(
                "force_y",
                Expr::ident("area") * Expr::ident("normal").field("y"),
            ),
            dsl::let_expr(
                "off_u",
                (Expr::from(1.0) - Expr::ident("lambda")) * Expr::ident("force_x"),
            ),
            dsl::let_expr(
                "off_v",
                (Expr::from(1.0) - Expr::ident("lambda")) * Expr::ident("force_y"),
            ),
            dsl::let_expr("diag_u", Expr::ident("lambda") * Expr::ident("force_x")),
            dsl::let_expr("diag_v", Expr::ident("lambda") * Expr::ident("force_y")),
            Stmt::Return(Some(Expr::call_named(
                "vec4<f32>",
                vec![
                    Expr::ident("off_u"),
                    Expr::ident("off_v"),
                    Expr::ident("diag_u"),
                    Expr::ident("diag_v"),
                ],
            ))),
        ]),
        FieldKind::Vector3 => unreachable!("Vector3 rejected by assert_system_main_supported"),
        FieldKind::Scalar => Block::new(vec![
            Stmt::Comment("gradient term not used for scalar targets".to_string()),
            Stmt::Return(Some(Expr::call_named(
                "vec2<f32>",
                vec![0.0.into(), 0.0.into()],
            ))),
        ]),
    };
    let return_type = match op.target.kind() {
        FieldKind::Vector2 => Type::Vec4(Box::new(Type::F32)),
        FieldKind::Vector3 => unreachable!("Vector3 rejected by assert_system_main_supported"),
        FieldKind::Scalar => Type::Vec2(Box::new(Type::F32)),
    };
    Function::new(name, params, Some(return_type), Vec::new(), body)
}

fn term_source_fn(op: &DiscreteOp) -> Function {
    let name = term_function_name(op);
    let body = match op.target.kind() {
        FieldKind::Vector2 => Block::new(vec![
            Stmt::Comment("source term placeholder".to_string()),
            Stmt::Return(Some(Expr::call_named(
                "vec2<f32>",
                vec![0.0.into(), 0.0.into()],
            ))),
        ]),
        FieldKind::Vector3 => unreachable!("Vector3 rejected by assert_system_main_supported"),
        FieldKind::Scalar => Block::new(vec![
            Stmt::Comment("source term placeholder".to_string()),
            Stmt::Return(Some(0.0.into())),
        ]),
    };
    let return_type = match op.target.kind() {
        FieldKind::Vector2 => Type::Vec2(Box::new(Type::F32)),
        FieldKind::Vector3 => unreachable!("Vector3 rejected by assert_system_main_supported"),
        FieldKind::Scalar => Type::F32,
    };
    Function::new(name, Vec::new(), Some(return_type), Vec::new(), body)
}

fn equation_assemble_fn(equation: &super::ir::DiscreteEquation) -> Function {
    let name = equation_function_name(&equation.target);
    let mut stmts = Vec::new();
    for op in &equation.ops {
        stmts.push(dsl::call_stmt_expr(term_call_expr(op)));
    }
    Function::new(name, Vec::new(), None, Vec::new(), Block::new(stmts))
}

fn codegen_assemble_fn(equation: &super::ir::DiscreteEquation) -> Function {
    let name = codegen_assemble_function_name(&equation.target);
    let mut stmts = Vec::new();
    for op in &equation.ops {
        stmts.push(dsl::call_stmt_expr(term_call_expr(op)));
    }
    Function::new(name, Vec::new(), None, Vec::new(), Block::new(stmts))
}

fn term_call_expr(op: &DiscreteOp) -> Expr {
    let name = term_function_name(op);
    let args: Vec<Expr> = match op.kind {
        DiscreteOpKind::TimeDerivative => match op.target.kind() {
            FieldKind::Vector2 => vec![
                1.0.into(),
                1.0.into(),
                1.0.into(),
                1.0.into(),
                0u32.into(),
                dsl::vec2_f32(0.0, 0.0),
                dsl::vec2_f32(0.0, 0.0),
            ],
            FieldKind::Vector3 => unreachable!("Vector3 rejected by assert_system_main_supported"),
            FieldKind::Scalar => vec![
                1.0.into(),
                1.0.into(),
                1.0.into(),
                1.0.into(),
                0u32.into(),
                0.0.into(),
                0.0.into(),
            ],
        },
        DiscreteOpKind::Convection => match op.target.kind() {
            FieldKind::Vector2 => vec![
                0.0.into(),
                dsl::vec2_f32(0.0, 0.0),
                dsl::vec2_f32(0.0, 0.0),
                dsl::vec2_f32(0.0, 0.0),
                dsl::vec2_f32(0.0, 0.0),
                dsl::vec2_f32(0.0, 0.0),
                dsl::vec2_f32(0.0, 0.0),
                dsl::vec2_f32(0.0, 0.0),
                dsl::vec2_f32(0.0, 0.0),
                dsl::vec2_f32(0.0, 0.0),
            ],
            FieldKind::Vector3 => unreachable!("Vector3 rejected by assert_system_main_supported"),
            FieldKind::Scalar => vec![
                0.0.into(),
                0.0.into(),
                0.0.into(),
                dsl::vec2_f32(0.0, 0.0),
                dsl::vec2_f32(0.0, 0.0),
                dsl::vec2_f32(0.0, 0.0),
                dsl::vec2_f32(0.0, 0.0),
                dsl::vec2_f32(0.0, 0.0),
            ],
        },
        DiscreteOpKind::Diffusion => vec![1.0.into(), 1.0.into(), 1.0.into()],
        DiscreteOpKind::Gradient => vec![1.0.into(), dsl::vec2_f32(0.0, 0.0), 0.5.into()],
        DiscreteOpKind::Source => Vec::new(),
    };
    Expr::call_named(&name, args)
}

fn main_fn(system: &DiscreteSystem) -> Function {
    let mut stmts = Vec::new();
    for equation in &system.equations {
        let name = equation_function_name(&equation.target);
        stmts.push(dsl::call_stmt_expr(Expr::call_named(&name, Vec::new())));
    }
    Function::new("main", Vec::new(), None, Vec::new(), Block::new(stmts))
}

fn codegen_conv_coeff_fn() -> Function {
    let params = vec![Param::new("flux", Type::F32, Vec::new())];
    let body = Block::new(vec![
        dsl::var_typed_expr("conv_coeff_diag", Type::F32, Some(0.0.into())),
        dsl::var_typed_expr("conv_coeff_off", Type::F32, Some(0.0.into())),
        dsl::if_block_expr(
            Expr::ident("flux").gt(0.0),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("conv_coeff_diag"),
                Expr::ident("flux"),
            )]),
            Some(dsl::block(vec![dsl::assign_expr(
                Expr::ident("conv_coeff_off"),
                Expr::ident("flux"),
            )])),
        ),
        Stmt::Return(Some(Expr::call_named(
            "vec2<f32>",
            vec![
                Expr::ident("conv_coeff_diag"),
                Expr::ident("conv_coeff_off"),
            ],
        ))),
    ]);
    Function::new(
        "codegen_conv_coeff",
        params,
        Some(Type::Vec2(Box::new(Type::F32))),
        Vec::new(),
        body,
    )
}

fn codegen_diff_coeff_fn() -> Function {
    let params = vec![
        Param::new("mu", Type::F32, Vec::new()),
        Param::new("area", Type::F32, Vec::new()),
        Param::new("dist", Type::F32, Vec::new()),
    ];
    let body = Block::new(vec![Stmt::Return(Some(
        Expr::ident("mu") * Expr::ident("area") / Expr::ident("dist"),
    ))]);
    Function::new(
        "codegen_diff_coeff",
        params,
        Some(Type::F32),
        Vec::new(),
        body,
    )
}

fn format_coeff(coeff: &Coefficient) -> String {
    match coeff {
        Coefficient::Constant { value, .. } => format!("const({})", value),
        Coefficient::Field(field) => format!("field({})", field.name()),
        Coefficient::MagSqr(field) => format!("mag_sqr({})", field.name()),
        Coefficient::Product(lhs, rhs) => {
            format!("product({}, {})", format_coeff(lhs), format_coeff(rhs))
        }
    }
}

fn scheme_name(scheme: Scheme) -> &'static str {
    scheme.as_str()
}

fn sanitize_ident(value: &str) -> String {
    let mut output = String::with_capacity(value.len());
    for ch in value.chars() {
        if ch.is_ascii_alphanumeric() || ch == '_' {
            output.push(ch);
        } else {
            output.push('_');
        }
    }
    if output.is_empty() {
        "_".to_string()
    } else {
        output
    }
}

fn term_function_name(op: &DiscreteOp) -> String {
    let mut name = String::new();
    name.push_str("term_");
    name.push_str(op.kind.as_str());
    name.push('_');
    if let Some(flux) = &op.flux {
        name.push_str(&sanitize_ident(flux.name()));
        name.push('_');
    }
    name.push_str(&sanitize_ident(op.field.name()));
    name.push('_');
    name.push_str(scheme_name(op.scheme));
    name
}

fn equation_function_name(field: &crate::solver::ir::FieldRef) -> String {
    format!("assemble_{}", sanitize_ident(field.name()))
}

fn codegen_assemble_function_name(field: &crate::solver::ir::FieldRef) -> String {
    format!("codegen_assemble_{}", sanitize_ident(field.name()))
}

fn has_convection(system: &DiscreteSystem) -> bool {
    system
        .equations
        .iter()
        .flat_map(|eq| eq.ops.iter())
        .any(|op| op.kind == super::ir::DiscreteOpKind::Convection)
}

fn has_diffusion(system: &DiscreteSystem) -> bool {
    system
        .equations
        .iter()
        .flat_map(|eq| eq.ops.iter())
        .any(|op| op.kind == super::ir::DiscreteOpKind::Diffusion)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::codegen::ir::lower_system;
    use crate::solver::ir::{
        fvc, fvm, surface_scalar_dim, vol_scalar_dim, vol_vector_dim, SchemeRegistry,
    };
    use cfd2_ir::solver::dimensions::{
        Density, DynamicViscosity, InvTime, MassFlux, Pressure, UnitDimension, Velocity, D_P,
    };

    #[test]
    fn generate_wgsl_emits_terms_and_metadata() {
        let u = vol_vector_dim::<Velocity>("U");
        let p = vol_scalar_dim::<Pressure>("p");
        let phi = surface_scalar_dim::<MassFlux>("phi");
        let mu = vol_scalar_dim::<DynamicViscosity>("mu");

        let mut eqn = crate::solver::ir::Equation::new(u);
        eqn.add_term(fvm::div(phi, u));
        eqn.add_term(fvc::grad(p));
        eqn.add_term(fvm::laplacian(Coefficient::field(mu).unwrap(), u));

        let mut system = crate::solver::ir::EquationSystem::new();
        system.add_equation(eqn);

        let mut registry = SchemeRegistry::new(Scheme::Upwind);
        registry.set_for_term(
            crate::solver::ir::TermOp::Div,
            Some(&phi),
            &u,
            Scheme::QUICK,
        );

        let discrete = lower_system(&system, &registry).unwrap();
        let wgsl = generate_wgsl(&discrete);

        assert!(wgsl.contains("// equation: U (vector2)"));
        assert!(wgsl.contains("term: div"));
        assert!(wgsl.contains("scheme=quick"));
        assert!(wgsl.contains("flux=phi"));
        assert!(wgsl.contains("term: grad"));
        assert!(wgsl.contains("term: laplacian"));
        assert!(wgsl.contains("coeff=field(mu)"));
        assert!(wgsl.contains("fn main()"));
    }

    #[test]
    fn format_helpers_cover_constant_coeff_and_schemes() {
        let coeff = Coefficient::constant(1.5);
        assert_eq!(format_coeff(&coeff), "const(1.5)");
        let rho = vol_scalar_dim::<Density>("rho");
        let d_p = vol_scalar_dim::<D_P>("d_p");
        let coeff = Coefficient::product(
            Coefficient::field(rho).unwrap(),
            Coefficient::field(d_p).unwrap(),
        )
        .unwrap();
        assert_eq!(format_coeff(&coeff), "product(field(rho), field(d_p))");

        assert_eq!(scheme_name(Scheme::Upwind), "upwind");
        assert_eq!(scheme_name(Scheme::SecondOrderUpwind), "sou");
        assert_eq!(scheme_name(Scheme::QUICK), "quick");
        assert_eq!(Scheme::Upwind.gpu_id(), 0);
        assert_eq!(Scheme::SecondOrderUpwind.gpu_id(), 1);
        assert_eq!(Scheme::QUICK.gpu_id(), 2);
    }

    #[test]
    fn generated_line_omits_optional_fields_when_absent() {
        let u = vol_vector_dim::<Velocity>("U");
        let eqn = crate::solver::ir::Equation::new(u).with_term(fvc::grad(u));

        let mut system = crate::solver::ir::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry).unwrap();
        let wgsl = generate_wgsl(&discrete);

        assert!(wgsl.contains("term: grad"));
        assert!(!wgsl.contains("flux="));
        assert!(!wgsl.contains("coeff="));
    }

    #[test]
    fn generate_wgsl_includes_ddt_and_source_terms() {
        let u = vol_vector_dim::<Velocity>("U");
        let eqn = crate::solver::ir::Equation::new(u)
            .with_term(fvm::ddt(u))
            // Source terms are scalar coefficients applied to the unknown.
            // Use an `inv_time` coefficient so the integrated unit matches the `ddt` term.
            .with_term(fvm::source_coeff(
                Coefficient::constant_unit(1.0, InvTime::UNIT),
                u,
            ));

        let mut system = crate::solver::ir::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry).unwrap();
        let wgsl = generate_wgsl(&discrete);

        assert!(wgsl.contains("term: ddt"));
        assert!(wgsl.contains("term: source"));
    }

    #[test]
    fn sanitize_ident_replaces_non_alnum() {
        assert_eq!(sanitize_ident("phi"), "phi");
        assert_eq!(sanitize_ident("phi.face"), "phi_face");
        assert_eq!(sanitize_ident("U[0]"), "U_0_");
        assert_eq!(sanitize_ident(""), "_");
    }

    #[test]
    fn term_function_name_includes_flux_and_scheme() {
        let u = vol_vector_dim::<Velocity>("U");
        let phi = surface_scalar_dim::<MassFlux>("phi.face");
        let eqn = crate::solver::ir::Equation::new(u).with_term(fvm::div(phi, u));

        let mut system = crate::solver::ir::EquationSystem::new();
        system.add_equation(eqn);

        let mut registry = SchemeRegistry::new(Scheme::Upwind);
        registry.set_for_term(
            crate::solver::ir::TermOp::Div,
            Some(&phi),
            &u,
            Scheme::QUICK,
        );

        let discrete = lower_system(&system, &registry).unwrap();
        let name = term_function_name(&discrete.equations[0].ops[0]);
        assert_eq!(name, "term_div_phi_face_U_quick");
    }

    #[test]
    fn generate_wgsl_emits_term_math() {
        let u = vol_vector_dim::<Velocity>("U");
        let rho = vol_scalar_dim::<Density>("rho");
        let p = vol_scalar_dim::<Pressure>("p");
        let phi = surface_scalar_dim::<MassFlux>("phi");
        let eqn = crate::solver::ir::Equation::new(u)
            .with_term(fvm::ddt_coeff(Coefficient::field(rho).unwrap(), u))
            .with_term(fvm::div(phi, u))
            .with_term(fvc::grad(p))
            .with_term(fvm::laplacian(
                Coefficient::constant_unit(0.1, DynamicViscosity::UNIT),
                u,
            ));

        let mut system = crate::solver::ir::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry).unwrap();
        let wgsl = generate_wgsl(&discrete);

        assert!(wgsl.contains("fn term_ddt_U_upwind"));
        assert!(wgsl.contains("time_scheme == 1u"));
        assert!(wgsl.contains("codegen_conv_coeff(flux)"));
        assert!(wgsl.contains("mu * area / dist"));
        assert!(!wgsl.contains("TODO"));
        assert!(wgsl.contains("fn assemble_U()"));
        assert!(wgsl.contains("assemble_U();"));
    }

    #[test]
    fn equation_function_name_is_sanitized() {
        let field = vol_vector_dim::<Velocity>("U-1");
        let name = equation_function_name(&field);
        assert_eq!(name, "assemble_U_1");
    }

    #[test]
    fn generate_wgsl_library_emits_codegen_assemble() {
        let u = vol_vector_dim::<Velocity>("U");
        let phi = surface_scalar_dim::<MassFlux>("phi");
        let mu = vol_scalar_dim::<DynamicViscosity>("mu");
        let eqn = crate::solver::ir::Equation::new(u)
            .with_term(fvm::div(phi, u))
            .with_term(fvm::laplacian(Coefficient::field(mu).unwrap(), u));

        let mut system = crate::solver::ir::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry).unwrap();
        let wgsl = generate_wgsl_library(&discrete);

        assert!(wgsl.contains("codegen_assemble_U"));
        assert!(!wgsl.contains("fn main()"));
        assert!(wgsl.contains("codegen_conv_coeff"));
        assert!(wgsl.contains("codegen_diff_coeff"));
    }

    #[test]
    fn generate_wgsl_library_omits_conv_coeff_when_no_convection() {
        let u = vol_vector_dim::<Velocity>("U");
        let eqn = crate::solver::ir::Equation::new(u).with_term(fvm::ddt(u));

        let mut system = crate::solver::ir::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry).unwrap();
        let wgsl = generate_wgsl_library(&discrete);

        assert!(!wgsl.contains("codegen_conv_coeff"));
        assert!(!wgsl.contains("codegen_diff_coeff"));
    }

    #[test]
    fn generate_wgsl_library_emits_diff_coeff_for_laplacian() {
        let u = vol_vector_dim::<Velocity>("U");
        let mu = vol_scalar_dim::<DynamicViscosity>("mu");
        let eqn = crate::solver::ir::Equation::new(u)
            .with_term(fvm::laplacian(Coefficient::field(mu).unwrap(), u));

        let mut system = crate::solver::ir::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry).unwrap();
        let wgsl = generate_wgsl_library(&discrete);

        assert!(wgsl.contains("codegen_diff_coeff"));
    }
}
