use crate::solver::model::CompressibleFields;
use crate::solver::model::backend::StateLayout;
use super::dsl as typed;
use super::state_access::{state_scalar, state_vec2};
use super::reconstruction::limited_linear_reconstruct_face;
use super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, BinaryOp, Block, Expr, Function, GlobalVar, Item, Module,
    Param, Stmt, StructDef, StructField, Type, UnaryOp,
};
use super::wgsl_dsl as dsl;

pub fn generate_compressible_assembly_wgsl(
    layout: &StateLayout,
    fields: &CompressibleFields,
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (compressible_assembly)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn(layout, fields)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment(
        "Group 1: Fields (consolidated state buffers)".to_string(),
    ));
    items.extend(state_bindings());
    items.push(Item::Comment("Group 2: Solver".to_string()));
    items.extend(solver_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
            StructField::new("precond_type", Type::U32),
            StructField::new("precond_model", Type::U32),
            StructField::new("precond_theta_floor", Type::F32),
            StructField::new("pressure_coupling_alpha", Type::F32),
        ],
    )
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "face_owner",
            Type::array(Type::U32),
            0,
            0,
            AccessMode::Read,
        ),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "face_areas",
            Type::array(Type::F32),
            0,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var(
            "cell_vols",
            Type::array(Type::F32),
            0,
            5,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var(
            "cell_faces",
            Type::array(Type::U32),
            0,
            7,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            8,
            AccessMode::Read,
        ),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            9,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "state",
            Type::array(Type::F32),
            1,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "state_old",
            Type::array(Type::F32),
            1,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
        storage_var(
            "grad_rho",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            5,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_x",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            6,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_y",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            7,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_e",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            8,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "state_iter",
            Type::array(Type::F32),
            1,
            9,
            AccessMode::Read,
        ),
    ]
}

fn solver_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "matrix_values",
            Type::array(Type::F32),
            2,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var("rhs", Type::array(Type::F32), 2, 1, AccessMode::ReadWrite),
        storage_var(
            "scalar_row_offsets",
            Type::array(Type::U32),
            2,
            2,
            AccessMode::Read,
        ),
    ]
}

fn storage_var(
    name: &str,
    ty: Type,
    group: u32,
    binding: u32,
    access: AccessMode,
) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::wgsl_ast::StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::wgsl_ast::StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(layout: &StateLayout, fields: &CompressibleFields) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, fields),
    )
}

fn main_body(layout: &StateLayout, fields: &CompressibleFields) -> Block {
    let mut stmts = Vec::new();
    let rho_field = fields.rho.name();
    let rho_u_field = fields.rho_u.name();
    let rho_e_field = fields.rho_e.name();
    let gamma = 1.4_f32;
    let gamma_minus_1 = gamma - 1.0;
    let block_size = 4u32;
    let block_stride = block_size * block_size;
    let block_shape = typed::BlockShape::new(block_size as u8, block_size as u8);
    let block_matrix = typed::BlockCsrSoaMatrix::from_start_row_prefix(
        "matrix_values",
        "start_row",
        block_shape,
        typed::ScalarType::F32,
        typed::UnitDim::dimensionless(),
    );

    stmts.push(dsl::let_expr("idx", Expr::ident("global_id").field("x")));
    stmts.push(dsl::if_block_expr(
        Expr::binary(
            Expr::ident("idx"),
            BinaryOp::GreaterEq,
            Expr::call_named(
                "arrayLength",
                vec![Expr::unary(UnaryOp::AddressOf, Expr::ident("cell_vols"))],
            ),
        ),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));
    stmts.push(dsl::let_expr(
        "center",
        Expr::ident("cell_centers").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "start",
        Expr::ident("cell_face_offsets").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "end",
        Expr::ident("cell_face_offsets").index(Expr::ident("idx") + Expr::lit_u32(1)),
    ));
    stmts.push(dsl::let_expr(
        "vol",
        Expr::ident("cell_vols").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "scalar_offset",
        Expr::ident("scalar_row_offsets").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "num_neighbors",
        Expr::ident("scalar_row_offsets").index(Expr::ident("idx") + Expr::lit_u32(1))
            - Expr::ident("scalar_offset"),
    ));
    stmts.push(dsl::let_expr(
        "start_row_0",
        Expr::lit_u32(block_stride) * Expr::ident("scalar_offset"),
    ));
    stmts.push(dsl::let_expr(
        "start_row_1",
        Expr::ident("start_row_0") + Expr::lit_u32(block_size) * Expr::ident("num_neighbors"),
    ));
    stmts.push(dsl::let_expr(
        "start_row_2",
        Expr::ident("start_row_0")
            + Expr::lit_u32(block_size * 2) * Expr::ident("num_neighbors"),
    ));
    stmts.push(dsl::let_expr(
        "start_row_3",
        Expr::ident("start_row_0")
            + Expr::lit_u32(block_size * 3) * Expr::ident("num_neighbors"),
    ));
    stmts.push(dsl::let_expr(
        "scheme_id",
        Expr::ident("constants").field("scheme"),
    ));

    stmts.push(dsl::comment("Jacobian rows/cols: rho, rho_u_x, rho_u_y, rho_e"));
    stmts.extend(typed::MatExpr::<4, 4>::var_prefix("diag", Expr::lit_f32(0.0)));
    let diag_mat = typed::MatExpr::<4, 4>::from_prefix("diag");

    stmts.push(dsl::var_typed_expr("sum_rho", Type::F32, Some(Expr::lit_f32(0.0))));
    stmts.push(dsl::var_typed_expr(
        "sum_rho_u_x",
        Type::F32,
        Some(Expr::lit_f32(0.0)),
    ));
    stmts.push(dsl::var_typed_expr(
        "sum_rho_u_y",
        Type::F32,
        Some(Expr::lit_f32(0.0)),
    ));
    stmts.push(dsl::var_typed_expr("sum_rho_e", Type::F32, Some(Expr::lit_f32(0.0))));

    let rho_expr = state_scalar(layout, "state", "idx", rho_field);
    let rho_u_expr = state_vec2(layout, "state", "idx", rho_u_field);
    let rho_e_expr = state_scalar(layout, "state", "idx", rho_e_field);
    let rho_old_expr = state_scalar(layout, "state_old", "idx", rho_field);
    let rho_u_old_expr = state_vec2(layout, "state_old", "idx", rho_u_field);
    let rho_e_old_expr = state_scalar(layout, "state_old", "idx", rho_e_field);
    let rho_iter_expr = state_scalar(layout, "state_iter", "idx", rho_field);
    let rho_u_iter_expr = state_vec2(layout, "state_iter", "idx", rho_u_field);
    let rho_e_iter_expr = state_scalar(layout, "state_iter", "idx", rho_e_field);
    stmts.push(dsl::let_expr("rho", rho_expr));
    stmts.push(dsl::let_typed_expr("rho_u", Type::vec2_f32(), rho_u_expr));
    stmts.push(dsl::let_expr("rho_e", rho_e_expr));
    stmts.push(dsl::let_expr("rho_old", rho_old_expr));
    stmts.push(dsl::let_typed_expr("rho_u_old", Type::vec2_f32(), rho_u_old_expr));
    stmts.push(dsl::let_expr("rho_e_old", rho_e_old_expr));

    stmts.push(dsl::var_typed_expr(
        "coeff_time",
        Type::F32,
        Some(Expr::ident("vol") / Expr::ident("constants").field("dt")),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_time_rho",
        Type::F32,
        Some(Expr::ident("coeff_time") * Expr::ident("rho_old")),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_time_rho_u_x",
        Type::F32,
        Some(Expr::ident("coeff_time") * Expr::ident("rho_u_old").field("x")),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_time_rho_u_y",
        Type::F32,
        Some(Expr::ident("coeff_time") * Expr::ident("rho_u_old").field("y")),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_time_rho_e",
        Type::F32,
        Some(Expr::ident("coeff_time") * Expr::ident("rho_e_old")),
    ));
    stmts.push(dsl::var_typed_expr("coeff_pseudo", Type::F32, Some(Expr::lit_f32(0.0))));
    stmts.push(dsl::var_typed_expr(
        "rhs_pseudo_rho",
        Type::F32,
        Some(Expr::lit_f32(0.0)),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_pseudo_rho_u_x",
        Type::F32,
        Some(Expr::lit_f32(0.0)),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_pseudo_rho_u_y",
        Type::F32,
        Some(Expr::lit_f32(0.0)),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_pseudo_rho_e",
        Type::F32,
        Some(Expr::lit_f32(0.0)),
    ));

    let pseudo_block = dsl::block(vec![
        dsl::let_expr("rho_iter", rho_iter_expr),
        dsl::let_typed_expr("rho_u_iter", Type::vec2_f32(), rho_u_iter_expr),
        dsl::let_expr("rho_e_iter", rho_e_iter_expr),
        dsl::assign_expr(
            Expr::ident("coeff_pseudo"),
            Expr::ident("vol") / Expr::ident("constants").field("dtau"),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_pseudo_rho"),
            Expr::ident("coeff_pseudo") * Expr::ident("rho_iter"),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_pseudo_rho_u_x"),
            Expr::ident("coeff_pseudo") * Expr::ident("rho_u_iter").field("x"),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_pseudo_rho_u_y"),
            Expr::ident("coeff_pseudo") * Expr::ident("rho_u_iter").field("y"),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_pseudo_rho_e"),
            Expr::ident("coeff_pseudo") * Expr::ident("rho_e_iter"),
        ),
    ]);
    stmts.push(dsl::if_block_expr(
        Expr::binary(
            Expr::ident("constants").field("dtau"),
            BinaryOp::Greater,
            Expr::lit_f32(0.0),
        ),
        pseudo_block,
        None,
    ));

    let rho_old_old_expr = state_scalar(layout, "state_old_old", "idx", rho_field);
    let rho_u_old_old_expr = state_vec2(layout, "state_old_old", "idx", rho_u_field);
    let rho_e_old_old_expr = state_scalar(layout, "state_old_old", "idx", rho_e_field);
    let bdf2_block = dsl::block(vec![
        dsl::let_expr("dt", Expr::ident("constants").field("dt")),
        dsl::let_expr("dt_old", Expr::ident("constants").field("dt_old")),
        dsl::let_expr("r", Expr::ident("dt") / Expr::ident("dt_old")),
        dsl::let_expr("rho_old_old", rho_old_old_expr),
        dsl::let_typed_expr("rho_u_old_old", Type::vec2_f32(), rho_u_old_old_expr),
        dsl::let_expr("rho_e_old_old", rho_e_old_old_expr),
        dsl::assign_expr(
            Expr::ident("coeff_time"),
            Expr::ident("vol")
                / Expr::ident("dt")
                * (Expr::lit_f32(1.0) + Expr::lit_f32(2.0) * Expr::ident("r"))
                / (Expr::lit_f32(1.0) + Expr::ident("r")),
        ),
        dsl::let_expr("factor_n", Expr::lit_f32(1.0) + Expr::ident("r")),
        dsl::let_expr(
            "factor_nm1",
            (Expr::ident("r") * Expr::ident("r")) / (Expr::lit_f32(1.0) + Expr::ident("r")),
        ),
        dsl::let_expr("coeff_base", Expr::ident("vol") / Expr::ident("dt")),
        dsl::assign_expr(
            Expr::ident("rhs_time_rho"),
            Expr::ident("coeff_base")
                * (Expr::ident("factor_n") * Expr::ident("rho_old")
                    - Expr::ident("factor_nm1") * Expr::ident("rho_old_old")),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_time_rho_u_x"),
            Expr::ident("coeff_base")
                * (Expr::ident("factor_n") * Expr::ident("rho_u_old").field("x")
                    - Expr::ident("factor_nm1") * Expr::ident("rho_u_old_old").field("x")),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_time_rho_u_y"),
            Expr::ident("coeff_base")
                * (Expr::ident("factor_n") * Expr::ident("rho_u_old").field("y")
                    - Expr::ident("factor_nm1") * Expr::ident("rho_u_old_old").field("y")),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_time_rho_e"),
            Expr::ident("coeff_base")
                * (Expr::ident("factor_n") * Expr::ident("rho_e_old")
                    - Expr::ident("factor_nm1") * Expr::ident("rho_e_old_old")),
        ),
    ]);

    stmts.push(dsl::if_block_expr(
        Expr::binary(
            Expr::ident("constants").field("time_scheme"),
            BinaryOp::Equal,
            Expr::lit_u32(1),
        ),
        bdf2_block,
        None,
    ));

    let rho_r_expr = state_scalar(layout, "state", "other_idx", rho_field);
    let rho_u_r_expr = state_vec2(layout, "state", "other_idx", rho_u_field);
    let rho_e_r_expr = state_scalar(layout, "state", "other_idx", rho_e_field);

    let mut loop_body = Vec::new();
    loop_body.push(dsl::let_expr(
        "face_idx",
        Expr::ident("cell_faces").index(Expr::ident("face_offset")),
    ));
    loop_body.push(dsl::let_expr(
        "owner",
        Expr::ident("face_owner").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "neighbor",
        Expr::ident("face_neighbor").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "boundary_type",
        Expr::ident("face_boundary").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "area",
        Expr::ident("face_areas").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "normal",
        Type::Custom("Vector2".to_string()),
        Some(Expr::ident("face_normals").index(Expr::ident("face_idx"))),
    ));
    loop_body.push(dsl::let_expr(
        "f_center",
        Expr::ident("face_centers").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "is_boundary",
        Type::Bool,
        Some(Expr::lit_bool(false)),
    ));
    loop_body.push(dsl::var_typed_expr(
        "other_idx",
        Type::U32,
        Some(Expr::lit_u32(0)),
    ));
    loop_body.push(dsl::var_typed_expr(
        "center_r",
        Type::Custom("Vector2".to_string()),
        None,
    ));

    loop_body.push(dsl::if_block_expr(
        Expr::binary(Expr::ident("owner"), BinaryOp::NotEqual, Expr::ident("idx")),
        dsl::block(vec![
            dsl::assign_expr(
                Expr::ident("normal").field("x"),
                Expr::unary(UnaryOp::Negate, Expr::ident("normal").field("x")),
            ),
            dsl::assign_expr(
                Expr::ident("normal").field("y"),
                Expr::unary(UnaryOp::Negate, Expr::ident("normal").field("y")),
            ),
        ]),
        None,
    ));

    let interior_block = dsl::block(vec![
        dsl::let_typed_expr(
            "neigh_idx",
            Type::U32,
            Expr::call_named("u32", vec![Expr::ident("neighbor")]),
        ),
        dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("neigh_idx")),
        dsl::if_block_expr(
            Expr::binary(Expr::ident("owner"), BinaryOp::NotEqual, Expr::ident("idx")),
            dsl::block(vec![dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("owner"))]),
            None,
        ),
        dsl::assign_expr(
            Expr::ident("center_r"),
            Expr::ident("cell_centers").index(Expr::ident("other_idx")),
        ),
        dsl::let_expr("rho_neigh", rho_r_expr),
        dsl::let_typed_expr("rho_u_neigh", Type::vec2_f32(), rho_u_r_expr),
        dsl::let_expr("rho_e_neigh", rho_e_r_expr),
        dsl::assign_expr(Expr::ident("rho_r"), Expr::ident("rho_neigh")),
        dsl::assign_expr(Expr::ident("rho_u_r"), Expr::ident("rho_u_neigh")),
        dsl::assign_expr(Expr::ident("rho_e_r"), Expr::ident("rho_e_neigh")),
    ]);

    let boundary_block = dsl::block(vec![
        dsl::assign_expr(Expr::ident("is_boundary"), Expr::lit_bool(true)),
        dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("idx")),
        dsl::assign_expr(Expr::ident("center_r"), Expr::ident("f_center")),
    ]);

    let rho_l_expr = state_scalar(layout, "state", "idx", rho_field);
    let rho_u_l_expr = state_vec2(layout, "state", "idx", rho_u_field);
    let rho_e_l_expr = state_scalar(layout, "state", "idx", rho_e_field);
    loop_body.push(dsl::let_expr("rho_l_cell", rho_l_expr));
    loop_body.push(dsl::let_typed_expr("rho_u_l_cell", Type::vec2_f32(), rho_u_l_expr));
    loop_body.push(dsl::let_expr("rho_e_l_cell", rho_e_l_expr));
    loop_body.push(dsl::var_typed_expr("rho_l", Type::F32, Some(Expr::ident("rho_l_cell"))));
    loop_body.push(dsl::var_typed_expr(
        "rho_u_l",
        Type::vec2_f32(),
        Some(Expr::ident("rho_u_l_cell")),
    ));
    loop_body.push(dsl::var_typed_expr("rho_e_l", Type::F32, Some(Expr::ident("rho_e_l_cell"))));
    loop_body.push(dsl::var_typed_expr("rho_r", Type::F32, Some(Expr::ident("rho_l"))));
    loop_body.push(dsl::var_typed_expr(
        "rho_u_r",
        Type::vec2_f32(),
        Some(Expr::ident("rho_u_l")),
    ));
    loop_body.push(dsl::var_typed_expr("rho_e_r", Type::F32, Some(Expr::ident("rho_e_l"))));

    loop_body.push(dsl::if_block_expr(
        Expr::binary(Expr::ident("neighbor"), BinaryOp::NotEqual, Expr::lit_i32(-1)),
        interior_block,
        Some(boundary_block),
    ));

    let inlet_block = dsl::block(vec![dsl::assign_expr(
        Expr::ident("rho_u_r"),
        typed::VecExpr::<2>::from_components([
            Expr::ident("rho_r") * Expr::ident("constants").field("inlet_velocity"),
            Expr::lit_f32(0.0),
        ])
        .expr(),
    )]);

    let wall_block = dsl::block(vec![
        dsl::let_typed_expr(
            "normal_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(Expr::ident("normal")).expr(),
        ),
        dsl::let_expr(
            "m_dot_n",
            typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_l"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
        ),
        dsl::assign_expr(
            Expr::ident("rho_u_r"),
            typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_l"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                        .mul_scalar(Expr::lit_f32(2.0) * Expr::ident("m_dot_n")),
                )
                .expr(),
        ),
    ]);

    let boundary_state = dsl::block(vec![dsl::if_block_expr(
        Expr::binary(
            Expr::ident("boundary_type"),
            BinaryOp::Equal,
            Expr::lit_u32(1),
        ),
        inlet_block,
        Some(dsl::block(vec![dsl::if_block_expr(
            Expr::binary(
                Expr::ident("boundary_type"),
                BinaryOp::Equal,
                Expr::lit_u32(3),
            ),
            wall_block,
            None,
        )])),
    )]);

    loop_body.push(dsl::if_block_expr(Expr::ident("is_boundary"), boundary_state, None));

    loop_body.push(dsl::let_expr("rho_r_cell", Expr::ident("rho_r")));
    loop_body.push(dsl::let_typed_expr(
        "rho_u_r_cell",
        Type::vec2_f32(),
        Expr::ident("rho_u_r"),
    ));
    loop_body.push(dsl::let_expr("rho_e_r_cell", Expr::ident("rho_e_r")));

    let reconstruct_block = {
        let mut block = Vec::new();
        block.push(dsl::let_expr(
            "r_l_x",
            Expr::binary(
                Expr::ident("f_center").field("x"),
                BinaryOp::Sub,
                Expr::ident("center").field("x"),
            ),
        ));
        block.push(dsl::let_expr(
            "r_l_y",
            Expr::binary(
                Expr::ident("f_center").field("y"),
                BinaryOp::Sub,
                Expr::ident("center").field("y"),
            ),
        ));
        block.push(dsl::let_expr(
            "r_r_x",
            Expr::binary(
                Expr::ident("f_center").field("x"),
                BinaryOp::Sub,
                Expr::ident("center_r").field("x"),
            ),
        ));
        block.push(dsl::let_expr(
            "r_r_y",
            Expr::binary(
                Expr::ident("f_center").field("y"),
                BinaryOp::Sub,
                Expr::ident("center_r").field("y"),
            ),
        ));

        // Reconstruct conservative variables directly for robustness.
        block.push(dsl::let_expr(
            "grad_rho_l",
            Expr::ident("grad_rho").index(Expr::ident("idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_x_l",
            Expr::ident("grad_rho_u_x").index(Expr::ident("idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_y_l",
            Expr::ident("grad_rho_u_y").index(Expr::ident("idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_e_l",
            Expr::ident("grad_rho_e").index(Expr::ident("idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_r",
            Expr::ident("grad_rho").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_x_r",
            Expr::ident("grad_rho_u_x").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_y_r",
            Expr::ident("grad_rho_u_y").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_e_r",
            Expr::ident("grad_rho_e").index(Expr::ident("other_idx")),
        ));

        let (rho_l_stmts, rho_l_face) = limited_linear_reconstruct_face(
            "rho",
            "l",
            Expr::ident("rho_l_cell"),
            Expr::ident("rho_r_cell"),
            Expr::ident("grad_rho_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_l_stmts);
        let (rho_u_x_l_stmts, rho_u_x_l_face) = limited_linear_reconstruct_face(
            "rho_u_x",
            "l",
            Expr::ident("rho_u_l_cell").field("x"),
            Expr::ident("rho_u_r_cell").field("x"),
            Expr::ident("grad_rho_u_x_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_u_x_l_stmts);
        let (rho_u_y_l_stmts, rho_u_y_l_face) = limited_linear_reconstruct_face(
            "rho_u_y",
            "l",
            Expr::ident("rho_u_l_cell").field("y"),
            Expr::ident("rho_u_r_cell").field("y"),
            Expr::ident("grad_rho_u_y_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_u_y_l_stmts);
        let (rho_e_l_stmts, rho_e_l_face) = limited_linear_reconstruct_face(
            "rho_e",
            "l",
            Expr::ident("rho_e_l_cell"),
            Expr::ident("rho_e_r_cell"),
            Expr::ident("grad_rho_e_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_e_l_stmts);

        let (rho_r_stmts, rho_r_face) = limited_linear_reconstruct_face(
            "rho",
            "r",
            Expr::ident("rho_r_cell"),
            Expr::ident("rho_l_cell"),
            Expr::ident("grad_rho_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_r_stmts);
        let (rho_u_x_r_stmts, rho_u_x_r_face) = limited_linear_reconstruct_face(
            "rho_u_x",
            "r",
            Expr::ident("rho_u_r_cell").field("x"),
            Expr::ident("rho_u_l_cell").field("x"),
            Expr::ident("grad_rho_u_x_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_u_x_r_stmts);
        let (rho_u_y_r_stmts, rho_u_y_r_face) = limited_linear_reconstruct_face(
            "rho_u_y",
            "r",
            Expr::ident("rho_u_r_cell").field("y"),
            Expr::ident("rho_u_l_cell").field("y"),
            Expr::ident("grad_rho_u_y_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_u_y_r_stmts);
        let (rho_e_r_stmts, rho_e_r_face) = limited_linear_reconstruct_face(
            "rho_e",
            "r",
            Expr::ident("rho_e_r_cell"),
            Expr::ident("rho_e_l_cell"),
            Expr::ident("grad_rho_e_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_e_r_stmts);

        block.push(dsl::assign_expr(Expr::ident("rho_l"), rho_l_face));
        block.push(dsl::assign_expr(
            Expr::ident("rho_u_l"),
            dsl::vec2_f32(rho_u_x_l_face, rho_u_y_l_face),
        ));
        block.push(dsl::assign_expr(Expr::ident("rho_e_l"), rho_e_l_face));
        block.push(dsl::assign_expr(Expr::ident("rho_r"), rho_r_face));
        block.push(dsl::assign_expr(
            Expr::ident("rho_u_r"),
            dsl::vec2_f32(rho_u_x_r_face, rho_u_y_r_face),
        ));
        block.push(dsl::assign_expr(Expr::ident("rho_e_r"), rho_e_r_face));

        dsl::block(block)
    };

    // For compressible KT fluxes, keep reconstruction conservative and stable:
    // - `scheme=0` and `scheme=2` default to piecewise-constant states.
    // - `scheme=1` enables limited linear reconstruction.
    loop_body.push(dsl::if_block_expr(
        Expr::binary(
            Expr::unary(UnaryOp::Not, Expr::ident("is_boundary")),
            BinaryOp::And,
            Expr::binary(Expr::ident("scheme_id"), BinaryOp::Equal, Expr::lit_u32(1)),
        ),
        reconstruct_block,
        None,
    ));

    loop_body.push(dsl::let_expr(
        "inv_rho_l",
        Expr::lit_f32(1.0)
            / Expr::call_named("max", vec![Expr::ident("rho_l"), Expr::lit_f32(1e-8)]),
    ));
    loop_body.push(dsl::let_expr(
        "u_l_x",
        Expr::ident("rho_u_l").field("x") * Expr::ident("inv_rho_l"),
    ));
    loop_body.push(dsl::let_expr(
        "u_l_y",
        Expr::ident("rho_u_l").field("y") * Expr::ident("inv_rho_l"),
    ));
    loop_body.push(dsl::let_expr(
        "ke_l",
        Expr::lit_f32(0.5)
            * Expr::ident("rho_l")
            * (Expr::ident("u_l_x") * Expr::ident("u_l_x")
                + Expr::ident("u_l_y") * Expr::ident("u_l_y")),
    ));
    loop_body.push(dsl::let_expr(
        "p_l",
        Expr::call_named(
            "max",
            vec![
                Expr::lit_f32(0.0),
                Expr::lit_f32(gamma_minus_1) * (Expr::ident("rho_e_l") - Expr::ident("ke_l")),
            ],
        ),
    ));
    loop_body.push(dsl::let_expr(
        "u_n_l",
        Expr::ident("u_l_x") * Expr::ident("normal").field("x")
            + Expr::ident("u_l_y") * Expr::ident("normal").field("y"),
    ));
    loop_body.push(dsl::let_expr(
        "c_l",
        Expr::call_named(
            "sqrt",
            vec![Expr::lit_f32(gamma) * Expr::ident("p_l") * Expr::ident("inv_rho_l")],
        ),
    ));

    loop_body.push(dsl::let_expr(
        "inv_rho_r",
        Expr::lit_f32(1.0)
            / Expr::call_named("max", vec![Expr::ident("rho_r"), Expr::lit_f32(1e-8)]),
    ));
    loop_body.push(dsl::let_expr(
        "u_r_x",
        Expr::ident("rho_u_r").field("x") * Expr::ident("inv_rho_r"),
    ));
    loop_body.push(dsl::let_expr(
        "u_r_y",
        Expr::ident("rho_u_r").field("y") * Expr::ident("inv_rho_r"),
    ));
    loop_body.push(dsl::let_expr(
        "ke_r",
        Expr::lit_f32(0.5)
            * Expr::ident("rho_r")
            * (Expr::ident("u_r_x") * Expr::ident("u_r_x")
                + Expr::ident("u_r_y") * Expr::ident("u_r_y")),
    ));
    loop_body.push(dsl::let_expr(
        "p_r",
        Expr::call_named(
            "max",
            vec![
                Expr::lit_f32(0.0),
                Expr::lit_f32(gamma_minus_1) * (Expr::ident("rho_e_r") - Expr::ident("ke_r")),
            ],
        ),
    ));
    loop_body.push(dsl::let_expr(
        "u_n_r",
        Expr::ident("u_r_x") * Expr::ident("normal").field("x")
            + Expr::ident("u_r_y") * Expr::ident("normal").field("y"),
    ));
    loop_body.push(dsl::let_expr(
        "c_r",
        Expr::call_named(
            "sqrt",
            vec![Expr::lit_f32(gamma) * Expr::ident("p_r") * Expr::ident("inv_rho_r")],
        ),
    ));
    loop_body.push(dsl::let_expr(
        "u_face_x",
        Expr::lit_f32(0.5) * (Expr::ident("u_l_x") + Expr::ident("u_r_x")),
    ));
    loop_body.push(dsl::let_expr(
        "u_face_y",
        Expr::lit_f32(0.5) * (Expr::ident("u_l_y") + Expr::ident("u_r_y")),
    ));
    loop_body.push(dsl::let_expr(
        "u_face_n",
        Expr::ident("u_face_x") * Expr::ident("normal").field("x")
            + Expr::ident("u_face_y") * Expr::ident("normal").field("y"),
    ));
    loop_body.push(dsl::let_expr(
        "c_bar",
        Expr::lit_f32(0.5) * (Expr::ident("c_l") + Expr::ident("c_r")),
    ));
    loop_body.push(dsl::let_expr(
        "mach",
        Expr::call_named("abs", vec![Expr::ident("u_face_n")])
            / Expr::call_named("max", vec![Expr::ident("c_bar"), Expr::lit_f32(1e-6)]),
    ));
    loop_body.push(dsl::let_expr("mach2", Expr::ident("mach") * Expr::ident("mach")));
    // Low-Mach preconditioning (optional). Default is `precond_model=2` (off) for
    // rhoCentralFoam-like transient behavior (e.g., acoustics).
    loop_body.push(dsl::var_typed_expr("c_l_eff", Type::F32, Some(Expr::ident("c_l"))));
    loop_body.push(dsl::var_typed_expr("c_r_eff", Type::F32, Some(Expr::ident("c_r"))));

    let precond_legacy_block = dsl::block(vec![
        dsl::assign_expr(Expr::ident("c_l_eff"), Expr::ident("c_l") * Expr::ident("mach")),
        dsl::assign_expr(Expr::ident("c_r_eff"), Expr::ident("c_r") * Expr::ident("mach")),
    ]);
    let precond_weiss_smith_block = dsl::block(vec![
        dsl::let_expr(
            "theta",
            Expr::call_named(
                "min",
                vec![
                    Expr::lit_f32(1.0),
                    Expr::call_named(
                        "max",
                        vec![Expr::ident("mach2"), Expr::ident("constants").field("precond_theta_floor")],
                    ),
                ],
            ),
        ),
        dsl::let_expr("one_minus_theta", Expr::lit_f32(1.0) - Expr::ident("theta")),
        dsl::assign_expr(
            Expr::ident("c_l_eff"),
            Expr::call_named(
                "sqrt",
                vec![
                    Expr::ident("theta") * Expr::ident("c_l") * Expr::ident("c_l")
                        + Expr::ident("one_minus_theta") * Expr::ident("u_n_l") * Expr::ident("u_n_l"),
                ],
            ),
        ),
        dsl::assign_expr(
            Expr::ident("c_r_eff"),
            Expr::call_named(
                "sqrt",
                vec![
                    Expr::ident("theta") * Expr::ident("c_r") * Expr::ident("c_r")
                        + Expr::ident("one_minus_theta") * Expr::ident("u_n_r") * Expr::ident("u_n_r"),
                ],
            ),
        ),
    ]);
    let precond_else_block = dsl::block(vec![dsl::if_block_expr(
        Expr::binary(
            Expr::ident("constants").field("precond_model"),
            BinaryOp::Equal,
            Expr::lit_u32(1),
        ),
        precond_weiss_smith_block,
        None,
    )]);
    loop_body.push(dsl::if_block_expr(
        Expr::binary(
            Expr::ident("constants").field("precond_model"),
            BinaryOp::Equal,
            Expr::lit_u32(0),
        ),
        precond_legacy_block,
        Some(precond_else_block),
    ));
    loop_body.push(dsl::let_expr(
        "flux_adv",
        Expr::ident("u_face_n") * Expr::ident("area"),
    ));
    loop_body.push(dsl::let_expr(
        "dx",
        Expr::ident("center_r").field("x") - Expr::ident("center").field("x"),
    ));
    loop_body.push(dsl::let_expr(
        "dy",
        Expr::ident("center_r").field("y") - Expr::ident("center").field("y"),
    ));
    loop_body.push(dsl::let_expr(
        "dist",
        Expr::call_named(
            "max",
            vec![
                Expr::call_named(
                    "sqrt",
                    vec![Expr::ident("dx") * Expr::ident("dx")
                        + Expr::ident("dy") * Expr::ident("dy")],
                ),
                Expr::lit_f32(1e-6),
            ],
        ),
    ));
    loop_body.push(dsl::let_expr(
        "mu",
        Expr::ident("constants").field("viscosity"),
    ));

    loop_body.push(dsl::let_expr(
        "a_plus",
        Expr::call_named(
            "max",
            vec![
                Expr::lit_f32(0.0),
                Expr::call_named(
                    "max",
                    vec![
                        Expr::ident("u_n_l") + Expr::ident("c_l_eff"),
                        Expr::ident("u_n_r") + Expr::ident("c_r_eff"),
                    ],
                ),
            ],
        ),
    ));
    loop_body.push(dsl::let_expr(
        "a_minus",
        Expr::call_named(
            "min",
            vec![
                Expr::lit_f32(0.0),
                Expr::call_named(
                    "min",
                    vec![
                        Expr::ident("u_n_l") - Expr::ident("c_l_eff"),
                        Expr::ident("u_n_r") - Expr::ident("c_r_eff"),
                    ],
                ),
            ],
        ),
    ));
    loop_body.push(dsl::let_expr(
        "denom",
        Expr::call_named(
            "max",
            vec![
                Expr::ident("a_plus") - Expr::ident("a_minus"),
                Expr::lit_f32(1e-6),
            ],
        ),
    ));
    loop_body.push(dsl::let_expr(
        "a_prod",
        Expr::ident("a_plus") * Expr::ident("a_minus"),
    ));
    loop_body.push(dsl::let_expr(
        "a_pos",
        Expr::ident("a_plus") / Expr::ident("denom"),
    ));
    loop_body.push(dsl::let_expr("a_neg", Expr::lit_f32(1.0) - Expr::ident("a_pos")));
    loop_body.push(dsl::let_expr(
        "a_prod_scaled",
        Expr::ident("a_prod") / Expr::ident("denom"),
    ));

    loop_body.push(dsl::let_expr(
        "flux_rho_l",
        Expr::ident("rho_l") * Expr::ident("u_n_l"),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_r",
        Expr::ident("rho_r") * Expr::ident("u_n_r"),
    ));
    loop_body.push(dsl::var_typed_expr(
        "flux_rho",
        Type::F32,
        Some(
            Expr::ident("a_pos") * Expr::ident("flux_rho_l")
                + Expr::ident("a_neg") * Expr::ident("flux_rho_r")
                + Expr::ident("a_prod_scaled") * (Expr::ident("rho_r") - Expr::ident("rho_l")),
        ),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_u_x_l",
        Expr::ident("rho_u_l").field("x") * Expr::ident("u_n_l")
            + Expr::ident("p_l") * Expr::ident("normal").field("x"),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_u_x_r",
        Expr::ident("rho_u_r").field("x") * Expr::ident("u_n_r")
            + Expr::ident("p_r") * Expr::ident("normal").field("x"),
    ));
    loop_body.push(dsl::var_typed_expr(
        "flux_rho_u_x",
        Type::F32,
        Some(
            Expr::ident("a_pos") * Expr::ident("flux_rho_u_x_l")
                + Expr::ident("a_neg") * Expr::ident("flux_rho_u_x_r")
                + Expr::ident("a_prod_scaled")
                    * (Expr::ident("rho_u_r").field("x") - Expr::ident("rho_u_l").field("x")),
        ),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_u_y_l",
        Expr::ident("rho_u_l").field("y") * Expr::ident("u_n_l")
            + Expr::ident("p_l") * Expr::ident("normal").field("y"),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_u_y_r",
        Expr::ident("rho_u_r").field("y") * Expr::ident("u_n_r")
            + Expr::ident("p_r") * Expr::ident("normal").field("y"),
    ));
    loop_body.push(dsl::var_typed_expr(
        "flux_rho_u_y",
        Type::F32,
        Some(
            Expr::ident("a_pos") * Expr::ident("flux_rho_u_y_l")
                + Expr::ident("a_neg") * Expr::ident("flux_rho_u_y_r")
                + Expr::ident("a_prod_scaled")
                    * (Expr::ident("rho_u_r").field("y") - Expr::ident("rho_u_l").field("y")),
        ),
    ));
    loop_body.push(dsl::let_expr(
        "diff_u_x",
        Expr::unary(UnaryOp::Negate, Expr::ident("mu"))
            * (Expr::ident("u_r_x") - Expr::ident("u_l_x"))
            / Expr::ident("dist"),
    ));
    loop_body.push(dsl::let_expr(
        "diff_u_y",
        Expr::unary(UnaryOp::Negate, Expr::ident("mu"))
            * (Expr::ident("u_r_y") - Expr::ident("u_l_y"))
            / Expr::ident("dist"),
    ));
    loop_body.push(dsl::assign_expr(
        Expr::ident("flux_rho_u_x"),
        Expr::ident("flux_rho_u_x") + Expr::ident("diff_u_x"),
    ));
    loop_body.push(dsl::assign_expr(
        Expr::ident("flux_rho_u_y"),
        Expr::ident("flux_rho_u_y") + Expr::ident("diff_u_y"),
    ));

    loop_body.push(dsl::let_expr(
        "flux_rho_e_l",
        (Expr::ident("rho_e_l") + Expr::ident("p_l")) * Expr::ident("u_n_l"),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_e_r",
        (Expr::ident("rho_e_r") + Expr::ident("p_r")) * Expr::ident("u_n_r"),
    ));
    loop_body.push(dsl::var_typed_expr(
        "flux_rho_e",
        Type::F32,
        Some(
            Expr::ident("a_pos") * Expr::ident("flux_rho_e_l")
                + Expr::ident("a_neg") * Expr::ident("flux_rho_e_r")
                + Expr::ident("a_prod_scaled") * (Expr::ident("rho_e_r") - Expr::ident("rho_e_l")),
        ),
    ));

    // Rhieâ€“Chow-style pressure flux coupling is only used with low-Mach preconditioning.
    // (In the pure KT mode it can introduce dispersive/odd-even pressure ringing.)
    let pressure_coupling_block = dsl::block(vec![
        dsl::let_typed_expr(
            "normal_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(Expr::ident("normal")).expr(),
        ),
        dsl::let_expr(
            "inv_rho_l_cell",
            Expr::lit_f32(1.0)
                / Expr::call_named("max", vec![Expr::ident("rho_l_cell"), Expr::lit_f32(1e-8)]),
        ),
        dsl::let_expr(
            "inv_rho_r_cell",
            Expr::lit_f32(1.0)
                / Expr::call_named("max", vec![Expr::ident("rho_r_cell"), Expr::lit_f32(1e-8)]),
        ),
        dsl::let_typed_expr(
            "u_l_cell",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_l_cell"))
                .mul_scalar(Expr::ident("inv_rho_l_cell"))
                .expr(),
        ),
        dsl::let_typed_expr(
            "u_r_cell",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_r_cell"))
                .mul_scalar(Expr::ident("inv_rho_r_cell"))
                .expr(),
        ),
        dsl::let_expr(
            "u2_l_cell",
            typed::VecExpr::<2>::from_expr(Expr::ident("u_l_cell"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("u_l_cell"))),
        ),
        dsl::let_expr(
            "u2_r_cell",
            typed::VecExpr::<2>::from_expr(Expr::ident("u_r_cell"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("u_r_cell"))),
        ),
        dsl::let_typed_expr(
            "grad_rho_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(Expr::ident("grad_rho").index(Expr::ident("idx")))
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u_x_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho_u_x").index(Expr::ident("idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u_y_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho_u_y").index(Expr::ident("idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_e_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(Expr::ident("grad_rho_e").index(Expr::ident("idx")))
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho").index(Expr::ident("other_idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u_x_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho_u_x").index(Expr::ident("other_idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u_y_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho_u_y").index(Expr::ident("other_idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_e_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho_e").index(Expr::ident("other_idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u_x_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_x_l_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_l_vec"))
                        .mul_scalar(Expr::ident("u_l_cell").field("x")),
                )
                .mul_scalar(Expr::ident("inv_rho_l_cell"))
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u_y_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_y_l_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_l_vec"))
                        .mul_scalar(Expr::ident("u_l_cell").field("y")),
                )
                .mul_scalar(Expr::ident("inv_rho_l_cell"))
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u_x_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_x_r_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_r_vec"))
                        .mul_scalar(Expr::ident("u_r_cell").field("x")),
                )
                .mul_scalar(Expr::ident("inv_rho_r_cell"))
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u_y_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_y_r_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_r_vec"))
                        .mul_scalar(Expr::ident("u_r_cell").field("y")),
                )
                .mul_scalar(Expr::ident("inv_rho_r_cell"))
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u2_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_x_l_vec"))
                .mul_scalar(Expr::lit_f32(2.0) * Expr::ident("u_l_cell").field("x"))
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_y_l_vec")).mul_scalar(
                        Expr::lit_f32(2.0) * Expr::ident("u_l_cell").field("y"),
                    ),
                )
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u2_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_x_r_vec"))
                .mul_scalar(Expr::lit_f32(2.0) * Expr::ident("u_r_cell").field("x"))
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_y_r_vec")).mul_scalar(
                        Expr::lit_f32(2.0) * Expr::ident("u_r_cell").field("y"),
                    ),
                )
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u2_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_l_vec"))
                .mul_scalar(Expr::ident("u2_l_cell"))
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u2_l_vec"))
                        .mul_scalar(Expr::ident("rho_l_cell")),
                )
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u2_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_r_vec"))
                .mul_scalar(Expr::ident("u2_r_cell"))
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u2_r_vec"))
                        .mul_scalar(Expr::ident("rho_r_cell")),
                )
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_p_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_e_l_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u2_l_vec"))
                        .mul_scalar(Expr::lit_f32(0.5)),
                )
                .mul_scalar(Expr::lit_f32(gamma_minus_1))
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_p_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_e_r_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u2_r_vec"))
                        .mul_scalar(Expr::lit_f32(0.5)),
                )
                .mul_scalar(Expr::lit_f32(gamma_minus_1))
                .expr(),
        ),
        dsl::let_expr(
            "grad_p_l_n",
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_l_vec"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
        ),
        dsl::let_expr(
            "grad_p_r_n",
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_r_vec"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
        ),
        dsl::let_expr(
            "grad_p_face_n",
            Expr::lit_f32(0.5) * (Expr::ident("grad_p_l_n") + Expr::ident("grad_p_r_n")),
        ),
        dsl::let_expr(
            "grad_p_jump_n",
            (Expr::ident("p_r") - Expr::ident("p_l")) / Expr::ident("dist"),
        ),
        dsl::let_expr(
            "rho_face",
            Expr::lit_f32(0.5) * (Expr::ident("rho_l") + Expr::ident("rho_r")),
        ),
        dsl::let_expr(
            "p_bar",
            Expr::lit_f32(0.5) * (Expr::ident("p_l") + Expr::ident("p_r")),
        ),
        dsl::let_expr(
            "dp_rel",
            Expr::call_named("abs", vec![Expr::ident("p_r") - Expr::ident("p_l")])
                / Expr::call_named("max", vec![Expr::ident("p_bar"), Expr::lit_f32(1e-6)]),
        ),
        dsl::let_expr(
            "pc_theta",
            Expr::call_named(
                "min",
                vec![
                    Expr::lit_f32(1.0),
                    Expr::call_named(
                        "max",
                        vec![Expr::ident("mach2"), Expr::ident("constants").field("precond_theta_floor")],
                    ),
                ],
            ),
        ),
        dsl::let_expr("pc_low_mach", Expr::lit_f32(1.0) - Expr::ident("pc_theta")),
        dsl::let_expr(
            "pc_smooth",
            Expr::lit_f32(1.0)
                / (Expr::lit_f32(1.0)
                    + (Expr::ident("dp_rel") / Expr::lit_f32(0.2))
                        * (Expr::ident("dp_rel") / Expr::lit_f32(0.2))),
        ),
        dsl::let_expr(
            "pc_alpha",
            Expr::ident("constants").field("pressure_coupling_alpha")
                * Expr::ident("pc_low_mach")
                * Expr::ident("pc_smooth"),
        ),
        dsl::let_expr(
            "m_corr",
            Expr::ident("pc_alpha")
                * Expr::ident("constants").field("dt")
                / Expr::call_named("max", vec![Expr::ident("rho_face"), Expr::lit_f32(1e-8)])
                * (Expr::ident("grad_p_face_n") - Expr::ident("grad_p_jump_n")),
        ),
        dsl::let_expr(
            "h_l",
            (Expr::ident("rho_e_l") + Expr::ident("p_l")) * Expr::ident("inv_rho_l"),
        ),
        dsl::let_expr(
            "h_r",
            (Expr::ident("rho_e_r") + Expr::ident("p_r")) * Expr::ident("inv_rho_r"),
        ),
        dsl::let_expr(
            "h_face",
            Expr::lit_f32(0.5) * (Expr::ident("h_l") + Expr::ident("h_r")),
        ),
        dsl::assign_op_expr(AssignOp::Add, Expr::ident("flux_rho"), Expr::ident("m_corr")),
        dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("flux_rho_u_x"),
            Expr::ident("m_corr") * Expr::ident("u_face_x"),
        ),
        dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("flux_rho_u_y"),
            Expr::ident("m_corr") * Expr::ident("u_face_y"),
        ),
        dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("flux_rho_e"),
            Expr::ident("m_corr") * Expr::ident("h_face"),
        ),
    ]);
    loop_body.push(dsl::if_block_expr(
        Expr::binary(
            Expr::binary(
                Expr::unary(UnaryOp::Not, Expr::ident("is_boundary")),
                BinaryOp::And,
                Expr::binary(
                    Expr::ident("constants").field("precond_model"),
                    BinaryOp::NotEqual,
                    Expr::lit_u32(2),
                ),
            ),
            BinaryOp::And,
            Expr::binary(
                Expr::ident("constants").field("pressure_coupling_alpha"),
                BinaryOp::Greater,
                Expr::lit_f32(0.0),
            ),
        ),
        pressure_coupling_block,
        None,
    ));
    loop_body.push(dsl::assign_expr(
        Expr::ident("flux_rho_e"),
        Expr::ident("flux_rho_e")
            + Expr::ident("diff_u_x") * Expr::ident("u_face_x")
            + Expr::ident("diff_u_y") * Expr::ident("u_face_y"),
    ));

    loop_body.push(dsl::assign_op_expr(
        AssignOp::Add,
        Expr::ident("sum_rho"),
        Expr::ident("flux_rho") * Expr::ident("area"),
    ));
    loop_body.push(dsl::assign_op_expr(
        AssignOp::Add,
        Expr::ident("sum_rho_u_x"),
        Expr::ident("flux_rho_u_x") * Expr::ident("area"),
    ));
    loop_body.push(dsl::assign_op_expr(
        AssignOp::Add,
        Expr::ident("sum_rho_u_y"),
        Expr::ident("flux_rho_u_y") * Expr::ident("area"),
    ));
    loop_body.push(dsl::assign_op_expr(
        AssignOp::Add,
        Expr::ident("sum_rho_e"),
        Expr::ident("flux_rho_e") * Expr::ident("area"),
    ));

    loop_body.push(dsl::let_expr(
        "q_l",
        Expr::ident("u_l_x") * Expr::ident("u_l_x") + Expr::ident("u_l_y") * Expr::ident("u_l_y"),
    ));
    loop_body.push(dsl::let_expr(
        "dp_drho_l",
        Expr::lit_f32(0.5) * Expr::lit_f32(gamma_minus_1) * Expr::ident("q_l"),
    ));
    loop_body.push(dsl::let_expr(
        "dp_dru_l",
        Expr::unary(UnaryOp::Negate, Expr::lit_f32(gamma_minus_1)) * Expr::ident("u_l_x"),
    ));
    loop_body.push(dsl::let_expr(
        "dp_drv_l",
        Expr::unary(UnaryOp::Negate, Expr::lit_f32(gamma_minus_1)) * Expr::ident("u_l_y"),
    ));
    loop_body.push(dsl::let_expr("dp_dre_l", Expr::lit_f32(gamma_minus_1)));
    loop_body.push(dsl::let_expr(
        "H_l",
        (Expr::ident("rho_e_l") + Expr::ident("p_l")) * Expr::ident("inv_rho_l"),
    ));

    loop_body.push(dsl::let_expr(
        "q_r",
        Expr::ident("u_r_x") * Expr::ident("u_r_x") + Expr::ident("u_r_y") * Expr::ident("u_r_y"),
    ));
    loop_body.push(dsl::let_expr(
        "dp_drho_r",
        Expr::lit_f32(0.5) * Expr::lit_f32(gamma_minus_1) * Expr::ident("q_r"),
    ));
    loop_body.push(dsl::let_expr(
        "dp_dru_r",
        Expr::unary(UnaryOp::Negate, Expr::lit_f32(gamma_minus_1)) * Expr::ident("u_r_x"),
    ));
    loop_body.push(dsl::let_expr(
        "dp_drv_r",
        Expr::unary(UnaryOp::Negate, Expr::lit_f32(gamma_minus_1)) * Expr::ident("u_r_y"),
    ));
    loop_body.push(dsl::let_expr("dp_dre_r", Expr::lit_f32(gamma_minus_1)));
    loop_body.push(dsl::let_expr(
        "H_r",
        (Expr::ident("rho_e_r") + Expr::ident("p_r")) * Expr::ident("inv_rho_r"),
    ));

    loop_body.push(dsl::let_expr(
        "a_l",
        Expr::ident("a_plus") / Expr::ident("denom"),
    ));
    loop_body.push(dsl::let_expr(
        "a_r",
        Expr::unary(UnaryOp::Negate, Expr::ident("a_minus")) / Expr::ident("denom"),
    ));

    loop_body.push(dsl::let_expr(
        "mu_over_dist",
        Expr::binary(Expr::ident("mu"), BinaryOp::Div, Expr::ident("dist")),
    ));
    loop_body.push(dsl::let_expr(
        "u_face_vec",
        Expr::call_named(
            "vec2<f32>",
            vec![Expr::ident("u_face_x"), Expr::ident("u_face_y")],
        ),
    ));
    loop_body.push(dsl::let_expr(
        "diff_u_vec",
        Expr::call_named(
            "vec2<f32>",
            vec![Expr::ident("diff_u_x"), Expr::ident("diff_u_y")],
        ),
    ));

    let a_prod_scaled = Expr::ident("a_prod_scaled");
    let a_l = Expr::ident("a_l");
    let a_r = Expr::ident("a_r");
    let normal = Expr::ident("normal");
    let nx = normal.clone().field("x");
    let ny = normal.clone().field("y");
    let zero = Expr::lit_f32(0.0);
    let gamma = Expr::lit_f32(1.4);
    let u_n_l = Expr::ident("u_n_l");
    let u_n_r = Expr::ident("u_n_r");
    let u_l_x = Expr::ident("u_l_x");
    let u_l_y = Expr::ident("u_l_y");
    let u_r_x = Expr::ident("u_r_x");
    let u_r_y = Expr::ident("u_r_y");
    let dp_drho_l = Expr::ident("dp_drho_l");
    let dp_dru_l = Expr::ident("dp_dru_l");
    let dp_drv_l = Expr::ident("dp_drv_l");
    let dp_dre_l = Expr::ident("dp_dre_l");
    let dp_drho_r = Expr::ident("dp_drho_r");
    let dp_dru_r = Expr::ident("dp_dru_r");
    let dp_drv_r = Expr::ident("dp_drv_r");
    let dp_dre_r = Expr::ident("dp_dre_r");
    let h_l = Expr::ident("H_l");
    let h_r = Expr::ident("H_r");
    let mu_over_dist = Expr::ident("mu_over_dist");

    let u_face = typed::NamedVecExpr::<2, typed::AxisXY>::from_expr(Expr::ident("u_face_vec"));
    let diff_u = typed::NamedVecExpr::<2, typed::AxisXY>::from_expr(Expr::ident("diff_u_vec"));

    let a_l_mat = typed::MatExpr::<4, 4>::from_entries([
        [zero.clone(), nx.clone(), ny.clone(), zero.clone()],
        [
            Expr::binary(
                Expr::binary(dp_drho_l.clone(), BinaryOp::Mul, nx.clone()),
                BinaryOp::Sub,
                Expr::binary(u_l_x.clone(), BinaryOp::Mul, u_n_l.clone()),
            ),
            Expr::binary(
                u_n_l.clone(),
                BinaryOp::Add,
                Expr::binary(
                    nx.clone(),
                    BinaryOp::Mul,
                    Expr::binary(u_l_x.clone(), BinaryOp::Add, dp_dru_l.clone()),
                ),
            ),
            Expr::binary(
                Expr::binary(u_l_x.clone(), BinaryOp::Mul, ny.clone()),
                BinaryOp::Add,
                Expr::binary(dp_drv_l.clone(), BinaryOp::Mul, nx.clone()),
            ),
            Expr::binary(dp_dre_l.clone(), BinaryOp::Mul, nx.clone()),
        ],
        [
            Expr::binary(
                Expr::binary(dp_drho_l.clone(), BinaryOp::Mul, ny.clone()),
                BinaryOp::Sub,
                Expr::binary(u_l_y.clone(), BinaryOp::Mul, u_n_l.clone()),
            ),
            Expr::binary(
                Expr::binary(u_l_y.clone(), BinaryOp::Mul, nx.clone()),
                BinaryOp::Add,
                Expr::binary(dp_dru_l.clone(), BinaryOp::Mul, ny.clone()),
            ),
            Expr::binary(
                u_n_l.clone(),
                BinaryOp::Add,
                Expr::binary(
                    ny.clone(),
                    BinaryOp::Mul,
                    Expr::binary(u_l_y.clone(), BinaryOp::Add, dp_drv_l.clone()),
                ),
            ),
            Expr::binary(dp_dre_l.clone(), BinaryOp::Mul, ny.clone()),
        ],
        [
            Expr::binary(
                u_n_l.clone(),
                BinaryOp::Mul,
                Expr::binary(dp_drho_l.clone(), BinaryOp::Sub, h_l.clone()),
            ),
            Expr::binary(
                Expr::binary(h_l.clone(), BinaryOp::Mul, nx.clone()),
                BinaryOp::Add,
                Expr::binary(dp_dru_l.clone(), BinaryOp::Mul, u_n_l.clone()),
            ),
            Expr::binary(
                Expr::binary(h_l.clone(), BinaryOp::Mul, ny.clone()),
                BinaryOp::Add,
                Expr::binary(dp_drv_l.clone(), BinaryOp::Mul, u_n_l.clone()),
            ),
            Expr::binary(gamma.clone(), BinaryOp::Mul, u_n_l.clone()),
        ],
    ]);

    let a_r_mat = typed::MatExpr::<4, 4>::from_entries([
        [zero.clone(), nx.clone(), ny.clone(), zero.clone()],
        [
            Expr::binary(
                Expr::binary(dp_drho_r.clone(), BinaryOp::Mul, nx.clone()),
                BinaryOp::Sub,
                Expr::binary(u_r_x.clone(), BinaryOp::Mul, u_n_r.clone()),
            ),
            Expr::binary(
                u_n_r.clone(),
                BinaryOp::Add,
                Expr::binary(
                    nx.clone(),
                    BinaryOp::Mul,
                    Expr::binary(u_r_x.clone(), BinaryOp::Add, dp_dru_r.clone()),
                ),
            ),
            Expr::binary(
                Expr::binary(u_r_x.clone(), BinaryOp::Mul, ny.clone()),
                BinaryOp::Add,
                Expr::binary(dp_drv_r.clone(), BinaryOp::Mul, nx.clone()),
            ),
            Expr::binary(dp_dre_r.clone(), BinaryOp::Mul, nx.clone()),
        ],
        [
            Expr::binary(
                Expr::binary(dp_drho_r.clone(), BinaryOp::Mul, ny.clone()),
                BinaryOp::Sub,
                Expr::binary(u_r_y.clone(), BinaryOp::Mul, u_n_r.clone()),
            ),
            Expr::binary(
                Expr::binary(u_r_y.clone(), BinaryOp::Mul, nx.clone()),
                BinaryOp::Add,
                Expr::binary(dp_dru_r.clone(), BinaryOp::Mul, ny.clone()),
            ),
            Expr::binary(
                u_n_r.clone(),
                BinaryOp::Add,
                Expr::binary(
                    ny.clone(),
                    BinaryOp::Mul,
                    Expr::binary(u_r_y.clone(), BinaryOp::Add, dp_drv_r.clone()),
                ),
            ),
            Expr::binary(dp_dre_r.clone(), BinaryOp::Mul, ny.clone()),
        ],
        [
            Expr::binary(
                u_n_r.clone(),
                BinaryOp::Mul,
                Expr::binary(dp_drho_r.clone(), BinaryOp::Sub, h_r.clone()),
            ),
            Expr::binary(
                Expr::binary(h_r.clone(), BinaryOp::Mul, nx.clone()),
                BinaryOp::Add,
                Expr::binary(dp_dru_r.clone(), BinaryOp::Mul, u_n_r.clone()),
            ),
            Expr::binary(
                Expr::binary(h_r.clone(), BinaryOp::Mul, ny.clone()),
                BinaryOp::Add,
                Expr::binary(dp_drv_r.clone(), BinaryOp::Mul, u_n_r.clone()),
            ),
            Expr::binary(gamma, BinaryOp::Mul, u_n_r.clone()),
        ],
    ]);

    let velocity_jacobian = |u_x: Expr, u_y: Expr, inv_rho: Expr| {
        typed::NamedMatExpr::<2, 4, typed::AxisXY, typed::AxisCons>::from_entries([
            [
                Expr::binary(
                    Expr::unary(UnaryOp::Negate, u_x),
                    BinaryOp::Mul,
                    inv_rho.clone(),
                ),
                inv_rho.clone(),
                zero.clone(),
                zero.clone(),
            ],
            [
                Expr::binary(
                    Expr::unary(UnaryOp::Negate, u_y),
                    BinaryOp::Mul,
                    inv_rho.clone(),
                ),
                zero.clone(),
                inv_rho,
                zero.clone(),
            ],
        ])
    };

    let du_l_d_cons =
        velocity_jacobian(u_l_x.clone(), u_l_y.clone(), Expr::ident("inv_rho_l"));
    let du_r_d_cons =
        velocity_jacobian(u_r_x.clone(), u_r_y.clone(), Expr::ident("inv_rho_r"));

    let d_diff_l = du_l_d_cons.mul_scalar(mu_over_dist.clone());
    let d_diff_r = du_r_d_cons.mul_scalar(Expr::unary(UnaryOp::Negate, mu_over_dist.clone()));

    let du_face_l = du_l_d_cons.mul_scalar(Expr::lit_f32(0.5));
    let du_face_r = du_r_d_cons.mul_scalar(Expr::lit_f32(0.5));

    let d_e_visc_l = d_diff_l
        .contract_rows(&u_face)
        .add(&du_face_l.contract_rows(&diff_u));
    let d_e_visc_r = d_diff_r
        .contract_rows(&u_face)
        .add(&du_face_r.contract_rows(&diff_u));

    let visc_l = typed::MatExpr::<4, 4>::from_entries([
        [zero.clone(), zero.clone(), zero.clone(), zero.clone()],
        [
            d_diff_l.at(typed::XY::X, typed::Cons::Rho),
            d_diff_l.at(typed::XY::X, typed::Cons::Ru),
            d_diff_l.at(typed::XY::X, typed::Cons::Rv),
            d_diff_l.at(typed::XY::X, typed::Cons::Re),
        ],
        [
            d_diff_l.at(typed::XY::Y, typed::Cons::Rho),
            d_diff_l.at(typed::XY::Y, typed::Cons::Ru),
            d_diff_l.at(typed::XY::Y, typed::Cons::Rv),
            d_diff_l.at(typed::XY::Y, typed::Cons::Re),
        ],
        [
            d_e_visc_l.at(typed::Cons::Rho),
            d_e_visc_l.at(typed::Cons::Ru),
            d_e_visc_l.at(typed::Cons::Rv),
            d_e_visc_l.at(typed::Cons::Re),
        ],
    ]);
    let visc_r = typed::MatExpr::<4, 4>::from_entries([
        [zero.clone(), zero.clone(), zero.clone(), zero.clone()],
        [
            d_diff_r.at(typed::XY::X, typed::Cons::Rho),
            d_diff_r.at(typed::XY::X, typed::Cons::Ru),
            d_diff_r.at(typed::XY::X, typed::Cons::Rv),
            d_diff_r.at(typed::XY::X, typed::Cons::Re),
        ],
        [
            d_diff_r.at(typed::XY::Y, typed::Cons::Rho),
            d_diff_r.at(typed::XY::Y, typed::Cons::Ru),
            d_diff_r.at(typed::XY::Y, typed::Cons::Rv),
            d_diff_r.at(typed::XY::Y, typed::Cons::Re),
        ],
        [
            d_e_visc_r.at(typed::Cons::Rho),
            d_e_visc_r.at(typed::Cons::Ru),
            d_e_visc_r.at(typed::Cons::Rv),
            d_e_visc_r.at(typed::Cons::Re),
        ],
    ]);

    let diag_term = typed::MatExpr::<4, 4>::identity().mul_scalar(a_prod_scaled.clone());
    let jac_l = a_l_mat
        .mul_scalar(a_l.clone())
        .add(&visc_l)
        .sub(&diag_term);
    let jac_r = a_r_mat
        .mul_scalar(a_r.clone())
        .add(&visc_r)
        .add(&diag_term);

    let mut interior_matrix_stmts = vec![
        dsl::let_expr(
            "scalar_mat_idx",
            Expr::ident("cell_face_matrix_indices").index(Expr::ident("face_offset")),
        ),
        dsl::let_expr(
            "neighbor_rank",
            Expr::ident("scalar_mat_idx") - Expr::ident("scalar_offset"),
        ),
    ];

    let neighbor_entry = block_matrix.row_entry(&Expr::ident("neighbor_rank"));
    interior_matrix_stmts.extend(jac_r.scatter_assign_to_block_entry_scaled(
        &neighbor_entry,
        Some(Expr::ident("area")),
    ));
    interior_matrix_stmts.extend(jac_l.assign_op_to_prefix_scaled(
        AssignOp::Add,
        "diag",
        Some(Expr::ident("area")),
    ));

    let interior_matrix = dsl::block(interior_matrix_stmts);

    let boundary_matrix = {
        let area = Expr::ident("area");
        let eff_default = jac_l.add(&jac_r);
        let default_block = dsl::block(eff_default.assign_op_to_prefix_scaled(
            AssignOp::Add,
            "diag",
            Some(area.clone()),
        ));

        let inlet_velocity = Expr::ident("constants").field("inlet_velocity");
        let t_inlet = typed::MatExpr::<4, 4>::from_entries([
            [
                Expr::lit_f32(1.0),
                Expr::lit_f32(0.0),
                Expr::lit_f32(0.0),
                Expr::lit_f32(0.0),
            ],
            [
                inlet_velocity.clone(),
                Expr::lit_f32(0.0),
                Expr::lit_f32(0.0),
                Expr::lit_f32(0.0),
            ],
            [
                Expr::lit_f32(0.0),
                Expr::lit_f32(0.0),
                Expr::lit_f32(0.0),
                Expr::lit_f32(0.0),
            ],
            [
                Expr::lit_f32(0.0),
                Expr::lit_f32(0.0),
                Expr::lit_f32(0.0),
                Expr::lit_f32(1.0),
            ],
        ]);
        let eff_inlet = jac_l.add(&jac_r.mul_mat(&t_inlet));
        let inlet_block = dsl::block(eff_inlet.assign_op_to_prefix_scaled(
            AssignOp::Add,
            "diag",
            Some(area.clone()),
        ));

        let wall_block = {
            let mut wall = Vec::new();
            // Wall BC couples the right state to the left state:
            //   m_r = m_l - 2 (m_l Â· n) n
            // This requires applying the momentum reflection matrix to the right-state Jacobian.
            let normal = Expr::ident("normal");
            let nx = normal.clone().field("x");
            let ny = normal.clone().field("y");
            let nx_sq = Expr::binary(nx.clone(), BinaryOp::Mul, nx.clone());
            let ny_sq = Expr::binary(ny.clone(), BinaryOp::Mul, ny.clone());
            wall.extend([
                dsl::let_expr(
                    "r11",
                    Expr::binary(
                        Expr::lit_f32(1.0),
                        BinaryOp::Sub,
                        Expr::binary(Expr::lit_f32(2.0), BinaryOp::Mul, nx_sq),
                    ),
                ),
                dsl::let_expr(
                    "r12",
                    Expr::binary(
                        Expr::lit_f32(-2.0),
                        BinaryOp::Mul,
                        Expr::binary(nx.clone(), BinaryOp::Mul, ny.clone()),
                    ),
                ),
                dsl::let_expr(
                    "r21",
                    Expr::binary(
                        Expr::lit_f32(-2.0),
                        BinaryOp::Mul,
                        Expr::binary(ny.clone(), BinaryOp::Mul, nx.clone()),
                    ),
                ),
                dsl::let_expr(
                    "r22",
                    Expr::binary(
                        Expr::lit_f32(1.0),
                        BinaryOp::Sub,
                        Expr::binary(Expr::lit_f32(2.0), BinaryOp::Mul, ny_sq),
                    ),
                ),
            ]);

            let t_wall = typed::MatExpr::<4, 4>::from_entries([
                [
                    Expr::lit_f32(1.0),
                    Expr::lit_f32(0.0),
                    Expr::lit_f32(0.0),
                    Expr::lit_f32(0.0),
                ],
                [
                    Expr::lit_f32(0.0),
                    Expr::ident("r11"),
                    Expr::ident("r12"),
                    Expr::lit_f32(0.0),
                ],
                [
                    Expr::lit_f32(0.0),
                    Expr::ident("r21"),
                    Expr::ident("r22"),
                    Expr::lit_f32(0.0),
                ],
                [
                    Expr::lit_f32(0.0),
                    Expr::lit_f32(0.0),
                    Expr::lit_f32(0.0),
                    Expr::lit_f32(1.0),
                ],
            ]);
            let eff_wall = jac_l.add(&jac_r.mul_mat(&t_wall));
            wall.extend(eff_wall.assign_op_to_prefix_scaled(
                AssignOp::Add,
                "diag",
                Some(area.clone()),
            ));
            dsl::block(wall)
        };

        let boundary_stmt = dsl::if_block_expr(
            Expr::binary(
                Expr::ident("boundary_type"),
                BinaryOp::Equal,
                Expr::lit_u32(1),
            ),
            inlet_block,
            Some(dsl::block(vec![dsl::if_block_expr(
                Expr::binary(
                    Expr::ident("boundary_type"),
                    BinaryOp::Equal,
                    Expr::lit_u32(3),
                ),
                wall_block,
                Some(default_block),
            )])),
        );

        dsl::block(vec![boundary_stmt])
    };

    loop_body.push(dsl::if_block_expr(
        Expr::unary(UnaryOp::Not, Expr::ident("is_boundary")),
        interior_matrix,
        Some(boundary_matrix),
    ));

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("face_offset", Expr::ident("start")),
        Expr::binary(
            Expr::ident("face_offset"),
            BinaryOp::Less,
            Expr::ident("end"),
        ),
        dsl::for_step_increment_expr(Expr::ident("face_offset")),
        dsl::block(loop_body),
    ));

    stmts.push(dsl::var_typed_expr(
        "rhs_rho",
        Type::F32,
        Some(
            Expr::ident("rhs_time_rho")
                + Expr::ident("rhs_pseudo_rho")
                - (Expr::ident("coeff_time") + Expr::ident("coeff_pseudo")) * Expr::ident("rho")
                - Expr::ident("sum_rho"),
        ),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_rho_u_x",
        Type::F32,
        Some(
            Expr::ident("rhs_time_rho_u_x")
                + Expr::ident("rhs_pseudo_rho_u_x")
                - (Expr::ident("coeff_time") + Expr::ident("coeff_pseudo"))
                    * Expr::ident("rho_u").field("x")
                - Expr::ident("sum_rho_u_x"),
        ),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_rho_u_y",
        Type::F32,
        Some(
            Expr::ident("rhs_time_rho_u_y")
                + Expr::ident("rhs_pseudo_rho_u_y")
                - (Expr::ident("coeff_time") + Expr::ident("coeff_pseudo"))
                    * Expr::ident("rho_u").field("y")
                - Expr::ident("sum_rho_u_y"),
        ),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_rho_e",
        Type::F32,
        Some(
            Expr::ident("rhs_time_rho_e")
                + Expr::ident("rhs_pseudo_rho_e")
                - (Expr::ident("coeff_time") + Expr::ident("coeff_pseudo")) * Expr::ident("rho_e")
                - Expr::ident("sum_rho_e"),
        ),
    ));

    stmts.extend(diag_mat.assign_op_diag(AssignOp::Add, Expr::ident("coeff_time")));
    stmts.extend(diag_mat.assign_op_diag(AssignOp::Add, Expr::ident("coeff_pseudo")));

    stmts.push(dsl::let_expr(
        "scalar_diag_idx",
        dsl::array_access("diagonal_indices", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "diag_rank",
        Expr::binary(
            Expr::ident("scalar_diag_idx"),
            BinaryOp::Sub,
            Expr::ident("scalar_offset"),
        ),
    ));
    let diag_entry = block_matrix.row_entry(&Expr::ident("diag_rank"));
    stmts.extend(diag_mat.scatter_assign_to_block_entry_scaled(&diag_entry, None));

    stmts.push(dsl::assign_array_access_linear(
        "rhs",
        Expr::ident("idx"),
        4,
        0,
        Expr::ident("rhs_rho"),
    ));
    stmts.push(dsl::assign_array_access_linear(
        "rhs",
        Expr::ident("idx"),
        4,
        1,
        Expr::ident("rhs_rho_u_x"),
    ));
    stmts.push(dsl::assign_array_access_linear(
        "rhs",
        Expr::ident("idx"),
        4,
        2,
        Expr::ident("rhs_rho_u_y"),
    ));
    stmts.push(dsl::assign_array_access_linear(
        "rhs",
        Expr::ident("idx"),
        4,
        3,
        Expr::ident("rhs_rho_e"),
    ));

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::model::compressible_model;

    #[test]
    fn compressible_assembly_codegen_emits_bindings() {
        let model = compressible_model();
        let fields = model.fields.compressible().expect("compressible fields");
        let wgsl = generate_compressible_assembly_wgsl(&model.state_layout, fields);
        assert!(wgsl.contains("matrix_values"));
        assert!(wgsl.contains("rhs"));
        assert!(wgsl.contains("scalar_row_offsets"));
        assert!(wgsl.contains("state: array<f32>"));
        assert!(wgsl.contains("sum_rho"));
        assert!(wgsl.contains("rhs_time_rho"));
        assert!(wgsl.contains("dp_drho_l"));
        assert!(!wgsl.contains("A_l_10"));
    }
}
