use super::state_access::{state_component, state_scalar, state_vec2};
use super::wgsl_ast::{
    AccessMode, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, StorageClass,
    StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;
use crate::solver::ir::StateLayout;
use crate::solver::codegen::incompressible_fields::CodegenIncompressibleMomentumFields;

pub fn generate_update_fields_from_coupled_wgsl(
    layout: &StateLayout,
    fields: &CodegenIncompressibleMomentumFields,
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (update_fields_from_coupled)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::GlobalVar(shared_max_u_var()));
    module.push(Item::GlobalVar(shared_max_p_var()));
    module.push(Item::Function(main_fn(layout, fields)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment(
        "Group 0: Fields (consolidated state buffers)".to_string(),
    ));
    items.extend(state_bindings());
    items.push(Item::Comment("Group 1: Linear solver outputs".to_string()));
    items.extend(solver_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
        ],
    )
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var("state", Type::array(Type::F32), 0, 0, AccessMode::ReadWrite),
        storage_var("state_old", Type::array(Type::F32), 0, 1, AccessMode::Read),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            0,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            0,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 0, 4),
    ]
}

fn solver_bindings() -> Vec<Item> {
    vec![
        storage_var("x", Type::array(Type::F32), 1, 0, AccessMode::Read),
        storage_var(
            "max_diff_result",
            Type::array(Type::Custom("atomic<u32>".to_string())),
            1,
            1,
            AccessMode::ReadWrite,
        ),
    ]
}

fn shared_max_u_var() -> GlobalVar {
    GlobalVar::new(
        "shared_max_u",
        Type::Custom("array<f32, 64>".to_string()),
        StorageClass::Workgroup,
        None,
        Vec::new(),
    )
}

fn shared_max_p_var() -> GlobalVar {
    GlobalVar::new(
        "shared_max_p",
        Type::Custom("array<f32, 64>".to_string()),
        StorageClass::Workgroup,
        None,
        Vec::new(),
    )
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(layout: &StateLayout, fields: &CodegenIncompressibleMomentumFields) -> Function {
    let params = vec![
        Param::new(
            "global_id",
            Type::vec3_u32(),
            vec![Attribute::Builtin("global_invocation_id".to_string())],
        ),
        Param::new(
            "local_id",
            Type::vec3_u32(),
            vec![Attribute::Builtin("local_invocation_id".to_string())],
        ),
        Param::new(
            "wg_id",
            Type::vec3_u32(),
            vec![Attribute::Builtin("workgroup_id".to_string())],
        ),
    ];
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, fields),
    )
}

fn main_body(layout: &StateLayout, fields: &CodegenIncompressibleMomentumFields) -> Block {
    let mut stmts = Vec::new();
    let stride = layout.stride();
    let u_field = fields.u.name();
    let p_field = fields.p.name();
    let u_components = fields.u.kind().component_count();
    let p_components = fields.p.kind().component_count();
    if u_components != 2 {
        panic!(
            "expected vector2 velocity field, got {} components",
            u_components
        );
    }
    if p_components != 1 {
        panic!(
            "expected scalar pressure field, got {} components",
            p_components
        );
    }
    let coupled_stride = u_components + p_components;
    let p_offset = u_components;
    let coupled_stride_u32 = coupled_stride as u32;
    let p_offset_u32 = p_offset as u32;

    stmts.push(dsl::let_expr("idx", Expr::ident("global_id").field("x")));
    stmts.push(dsl::let_expr("lid", Expr::ident("local_id").field("x")));
    stmts.push(dsl::var_typed_expr("diff_u", Type::F32, Some(0.0.into())));
    stmts.push(dsl::var_typed_expr("diff_p", Type::F32, Some(0.0.into())));
    stmts.push(dsl::let_expr(
        "num_cells",
        Expr::call_named("arrayLength", vec![Expr::ident("state").addr_of()]) / stride,
    ));

    let u_x_target = state_component(layout, "state", "idx", u_field, 0);
    let u_y_target = state_component(layout, "state", "idx", u_field, 1);
    let p_target = state_component(layout, "state", "idx", p_field, 0);

    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").lt(Expr::ident("num_cells")),
        dsl::block(vec![
            dsl::let_expr(
                "u_new",
                Expr::call_named(
                    "vec2<f32>",
                    vec![
                        dsl::array_access_linear("x", Expr::ident("idx"), coupled_stride_u32, 0),
                        dsl::array_access_linear("x", Expr::ident("idx"), coupled_stride_u32, 1),
                    ],
                ),
            ),
            dsl::let_expr(
                "p_new_val",
                dsl::array_access_linear("x", Expr::ident("idx"), coupled_stride_u32, p_offset_u32),
            ),
            dsl::let_expr("u_old_val", state_vec2(layout, "state", "idx", u_field)),
            dsl::let_expr("p_old_val", state_scalar(layout, "state", "idx", p_field)),
            dsl::let_expr("alpha_u", Expr::ident("constants").field("alpha_u")),
            dsl::let_expr("alpha_p", Expr::ident("constants").field("alpha_p")),
            dsl::let_expr(
                "u_updated",
                Expr::ident("u_old_val")
                    + Expr::ident("alpha_u") * (Expr::ident("u_new") - Expr::ident("u_old_val")),
            ),
            dsl::let_expr(
                "p_updated",
                Expr::ident("p_old_val")
                    + Expr::ident("alpha_p")
                        * (Expr::ident("p_new_val") - Expr::ident("p_old_val")),
            ),
            dsl::assign_expr(u_x_target, Expr::ident("u_updated").field("x")),
            dsl::assign_expr(u_y_target, Expr::ident("u_updated").field("y")),
            dsl::assign_expr(p_target, Expr::ident("p_updated")),
            dsl::assign_expr(
                Expr::ident("diff_u"),
                Expr::call_named(
                    "max",
                    vec![
                        Expr::call_named(
                            "abs",
                            vec![
                                Expr::ident("u_updated").field("x")
                                    - Expr::ident("u_old_val").field("x"),
                            ],
                        ),
                        Expr::call_named(
                            "abs",
                            vec![
                                Expr::ident("u_updated").field("y")
                                    - Expr::ident("u_old_val").field("y"),
                            ],
                        ),
                    ],
                ),
            ),
            dsl::assign_expr(
                Expr::ident("diff_p"),
                Expr::call_named(
                    "abs",
                    vec![Expr::ident("p_updated") - Expr::ident("p_old_val")],
                ),
            ),
        ]),
        None,
    ));

    stmts.push(dsl::assign_array_access(
        "shared_max_u",
        Expr::ident("lid"),
        Expr::ident("diff_u"),
    ));
    stmts.push(dsl::assign_array_access(
        "shared_max_p",
        Expr::ident("lid"),
        Expr::ident("diff_p"),
    ));
    stmts.push(dsl::call_stmt_expr(Expr::call_named(
        "workgroupBarrier",
        Vec::new(),
    )));

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("stride", 32u32),
        Expr::ident("stride").gt(0u32),
        dsl::for_step_assign_expr(Expr::ident("stride"), Expr::ident("stride") / 2u32),
        dsl::block(vec![
            dsl::if_block_expr(
                Expr::ident("lid").lt(Expr::ident("stride")),
                dsl::block(vec![
                    dsl::assign_expr(
                        dsl::array_access("shared_max_u", Expr::ident("lid")),
                        Expr::call_named(
                            "max",
                            vec![
                                dsl::array_access("shared_max_u", Expr::ident("lid")),
                                dsl::array_access(
                                    "shared_max_u",
                                    Expr::ident("lid") + Expr::ident("stride"),
                                ),
                            ],
                        ),
                    ),
                    dsl::assign_expr(
                        dsl::array_access("shared_max_p", Expr::ident("lid")),
                        Expr::call_named(
                            "max",
                            vec![
                                dsl::array_access("shared_max_p", Expr::ident("lid")),
                                dsl::array_access(
                                    "shared_max_p",
                                    Expr::ident("lid") + Expr::ident("stride"),
                                ),
                            ],
                        ),
                    ),
                ]),
                None,
            ),
            dsl::call_stmt_expr(Expr::call_named("workgroupBarrier", Vec::new())),
        ]),
    ));

    stmts.push(dsl::if_block_expr(
        Expr::ident("lid").eq(0u32),
        dsl::block(vec![
            dsl::call_stmt_expr(Expr::call_named(
                "atomicMax",
                vec![
                    dsl::array_access("max_diff_result", 0u32).addr_of(),
                    Expr::call_named(
                        "bitcast<u32>",
                        vec![dsl::array_access("shared_max_u", 0u32)],
                    ),
                ],
            )),
            dsl::call_stmt_expr(Expr::call_named(
                "atomicMax",
                vec![
                    dsl::array_access("max_diff_result", 1u32).addr_of(),
                    Expr::call_named(
                        "bitcast<u32>",
                        vec![dsl::array_access("shared_max_p", 0u32)],
                    ),
                ],
            )),
        ]),
        None,
    ));

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::ir::{vol_scalar, vol_vector};
    use crate::solver::units::si;

    #[test]
    fn update_fields_codegen_emits_state_arrays() {
        let layout = StateLayout::new(vec![
            vol_vector("U", si::VELOCITY),
            vol_scalar("p", si::PRESSURE),
            vol_scalar("d_p", si::D_P),
            vol_vector("grad_p", si::PRESSURE_GRADIENT),
        ]);
        let fields = CodegenIncompressibleMomentumFields::new();
        let wgsl = generate_update_fields_from_coupled_wgsl(&layout, &fields);
        assert!(wgsl.contains("state: array<f32>"));
        assert!(wgsl.contains("atomicMax"));
        let stride = layout.stride();
        assert!(wgsl.contains(&format!("arrayLength(&state) / {stride}u")));
    }
}
