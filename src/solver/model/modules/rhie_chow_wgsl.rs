use cfd2_codegen::solver::codegen::{
    constants::constants_struct,
    wgsl_ast::{AccessMode, Attribute, Block, Expr, Function, Item, Module, Param, Stmt, Type},
    wgsl_bindings::{storage_var, uniform_var},
    wgsl_dsl as dsl, KernelWgsl,
};

/// Parameters for the Rhie-Chow correct-velocity-delta kernel generation.
#[derive(Copy, Clone, Debug)]
pub struct RhieChowCorrectVelocityDeltaParams {
    pub state_stride: u32,
    pub u_x_offset: u32,
    pub u_y_offset: u32,
    pub d_p_offset: u32,
    pub grad_p_x_offset: u32,
    pub grad_p_y_offset: u32,
    pub grad_old_x_offset: u32,
    pub grad_old_y_offset: u32,
}

pub fn generate_dp_init_wgsl(state_stride: u32, d_p_offset: u32) -> KernelWgsl {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (dp_init)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.push(Item::Struct(base_constants_struct()));
    module.push(storage_var(
        "cell_vols",
        Type::array(Type::F32),
        0,
        0,
        AccessMode::Read,
    ));
    module.push(storage_var(
        "state",
        Type::array(Type::F32),
        0,
        1,
        AccessMode::ReadWrite,
    ));
    module.push(uniform_var(
        "constants",
        Type::Custom("Constants".to_string()),
        0,
        2,
    ));
    module.push(Item::Function(dp_init_main_fn(state_stride, d_p_offset)));
    KernelWgsl::from(module)
}

pub fn generate_dp_update_from_diag_wgsl(
    state_stride: u32,
    d_p_offset: u32,
    unknowns_per_cell: u32,
    u_indices: &[u32],
) -> Result<KernelWgsl, String> {
    if unknowns_per_cell == 0 {
        return Err("dp_update_from_diag requires unknowns_per_cell > 0".to_string());
    }
    if u_indices.is_empty() {
        return Err(
            "dp_update_from_diag requires at least one momentum component index".to_string(),
        );
    }
    if u_indices.len() > 8 {
        return Err("dp_update_from_diag supports at most 8 momentum components".to_string());
    }
    if u_indices.iter().any(|&u| u >= unknowns_per_cell) {
        return Err(format!(
            "dp_update_from_diag: momentum indices {:?} out of range for unknowns_per_cell={unknowns_per_cell}",
            u_indices
        ));
    }

    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (dp_update_from_diag)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.push(Item::Struct(base_constants_struct()));
    module.push(storage_var(
        "scalar_row_offsets",
        Type::array(Type::U32),
        0,
        0,
        AccessMode::Read,
    ));
    module.push(storage_var(
        "diagonal_indices",
        Type::array(Type::U32),
        0,
        1,
        AccessMode::Read,
    ));
    module.push(storage_var(
        "matrix_values",
        Type::array(Type::F32),
        0,
        2,
        AccessMode::Read,
    ));
    module.push(storage_var(
        "state",
        Type::array(Type::F32),
        0,
        3,
        AccessMode::ReadWrite,
    ));
    module.push(uniform_var(
        "constants",
        Type::Custom("Constants".to_string()),
        0,
        4,
    ));
    module.push(Item::Function(dp_update_main_fn(state_stride, d_p_offset)));
    Ok(KernelWgsl::from(module))
}

pub fn generate_rhie_chow_store_grad_p_wgsl(
    state_stride: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> KernelWgsl {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (rhie_chow_store_grad_p)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(rhie_chow_base_items());
    module.push(Item::Function(rhie_chow_store_grad_p_main_fn(
        state_stride,
        grad_p_x_offset,
        grad_p_y_offset,
        grad_old_x_offset,
        grad_old_y_offset,
    )));
    KernelWgsl::from(module)
}

pub fn generate_dp_update_store_grad_p_fused_wgsl(
    state_stride: u32,
    d_p_offset: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> KernelWgsl {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (rhie_chow_dp_update_store_grad_p_fused)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(rhie_chow_base_items());
    module.push(Item::Function(dp_update_store_grad_p_fused_main_fn(
        state_stride,
        d_p_offset,
        grad_p_x_offset,
        grad_p_y_offset,
        grad_old_x_offset,
        grad_old_y_offset,
    )));
    KernelWgsl::from(module)
}

pub fn generate_rhie_chow_correct_velocity_delta_wgsl(
    params: RhieChowCorrectVelocityDeltaParams,
) -> KernelWgsl {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (rhie_chow_correct_velocity_delta)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(rhie_chow_base_items());
    module.push(Item::Function(rhie_chow_correct_velocity_delta_main_fn(
        params,
    )));
    KernelWgsl::from(module)
}

fn base_constants_struct() -> cfd2_codegen::solver::codegen::wgsl_ast::StructDef {
    // Use shared helper for base Constants struct (no extra params)
    constants_struct(&[])
}

fn dp_init_main_fn(state_stride: u32, d_p_offset: u32) -> Function {
    Function::new(
        "main",
        main_params(),
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        dp_init_main_body(state_stride, d_p_offset),
    )
}

fn dp_init_main_body(state_stride: u32, d_p_offset: u32) -> Block {
    let stmts = vec![
        dsl::let_expr(
            "idx",
            Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
                + Expr::ident("global_id").field("x"),
        ),
        dsl::let_expr(
            "num_cells",
            Expr::call_named("arrayLength", vec![Expr::ident("state").addr_of()])
                / dsl::max(Expr::lit_u32(state_stride), Expr::lit_u32(1)),
        ),
        dsl::if_block_expr(
            Expr::ident("idx").ge(Expr::ident("num_cells")),
            dsl::block(vec![Stmt::Return(None)]),
            None,
        ),
        dsl::let_expr(
            "rho",
            dsl::max(
                Expr::ident("constants").field("density"),
                Expr::lit_f32(1e-12),
            ),
        ),
        dsl::let_expr(
            "dt",
            dsl::max(Expr::ident("constants").field("dt"), Expr::lit_f32(0.0)),
        ),
        // Kept for parity with the historical shader output (even though not currently used).
        dsl::let_expr(
            "vol",
            dsl::max(
                dsl::array_access("cell_vols", Expr::ident("idx")),
                Expr::lit_f32(1e-12),
            ),
        ),
        dsl::comment(
            "Seed Rhie–Chow mobility with a transient-scale approximation.",
        ),
        dsl::comment(
            "For integrated momentum diagonals A_U ~ rho*vol/dt (units: kg/s), a good first guess for",
        ),
        dsl::comment("the mobility-like coefficient is:"),
        dsl::comment("  d_p ≈ vol / A_U ≈ dt / rho"),
        dsl::comment(
            "Note: the solver applies velocity under-relaxation in the update stage rather than",
        ),
        dsl::comment(
            "modifying the assembled momentum diagonal. Match SIMPLE-like behavior by folding the",
        ),
        dsl::comment(
            "relaxation factor into the mobility: d_p ≈ alpha_u / A_U.",
        ),
        dsl::let_expr(
            "d_p",
            Expr::ident("constants").field("alpha_u") * Expr::ident("dt") / Expr::ident("rho"),
        ),
        dsl::assign_array_access_linear(
            "state",
            Expr::ident("idx"),
            state_stride,
            d_p_offset,
            Expr::ident("d_p"),
        ),
    ];

    Block::new(stmts)
}

fn dp_update_main_fn(state_stride: u32, d_p_offset: u32) -> Function {
    Function::new(
        "main",
        main_params(),
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        dp_update_main_body(state_stride, d_p_offset),
    )
}

fn dp_update_main_body(state_stride: u32, d_p_offset: u32) -> Block {
    let stmts = vec![
        dsl::let_expr(
            "idx",
            Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
                + Expr::ident("global_id").field("x"),
        ),
        dsl::let_expr(
            "num_cells",
            Expr::call_named(
                "arrayLength",
                vec![Expr::ident("scalar_row_offsets").addr_of()],
            ) - Expr::lit_u32(1),
        ),
        dsl::if_block_expr(
            Expr::ident("idx").ge(Expr::ident("num_cells")),
            dsl::block(vec![Stmt::Return(None)]),
            None,
        ),
        dsl::comment("Transient-scale approximation: d_p ≈ alpha_u * dt / rho."),
        dsl::comment(
            "This is the mobility used by the Rhie–Chow flux and pressure correction equation for",
        ),
        dsl::comment("incompressible pseudo-time marching."),
        dsl::let_expr(
            "rho",
            dsl::max(
                Expr::ident("constants").field("density"),
                Expr::lit_f32(1e-12),
            ),
        ),
        dsl::let_expr(
            "dt",
            dsl::max(Expr::ident("constants").field("dt"), Expr::lit_f32(0.0)),
        ),
        dsl::let_expr(
            "d_p",
            Expr::ident("constants").field("alpha_u") * Expr::ident("dt") / Expr::ident("rho"),
        ),
        dsl::assign_array_access_linear(
            "state",
            Expr::ident("idx"),
            state_stride,
            d_p_offset,
            Expr::ident("d_p"),
        ),
    ];

    Block::new(stmts)
}

fn rhie_chow_base_items() -> Vec<Item> {
    vec![
        Item::Struct(base_constants_struct()),
        storage_var("state", Type::array(Type::F32), 0, 0, AccessMode::ReadWrite),
        uniform_var("constants", Type::Custom("Constants".to_string()), 0, 1),
    ]
}

fn rhie_chow_store_grad_p_main_fn(
    state_stride: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> Function {
    Function::new(
        "main",
        main_params(),
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        rhie_chow_store_grad_p_main_body(
            state_stride,
            grad_p_x_offset,
            grad_p_y_offset,
            grad_old_x_offset,
            grad_old_y_offset,
        ),
    )
}

fn rhie_chow_store_grad_p_main_body(
    state_stride: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> Block {
    let mut stmts = rhie_chow_main_preamble(state_stride);

    stmts.push(dsl::assign_expr(
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_old_x_offset),
        ),
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_p_x_offset),
        ),
    ));
    stmts.push(dsl::assign_expr(
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_old_y_offset),
        ),
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_p_y_offset),
        ),
    ));

    Block::new(stmts)
}

fn dp_update_store_grad_p_fused_main_fn(
    state_stride: u32,
    d_p_offset: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> Function {
    Function::new(
        "main",
        main_params(),
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        dp_update_store_grad_p_fused_main_body(
            state_stride,
            d_p_offset,
            grad_p_x_offset,
            grad_p_y_offset,
            grad_old_x_offset,
            grad_old_y_offset,
        ),
    )
}

fn dp_update_store_grad_p_fused_main_body(
    state_stride: u32,
    d_p_offset: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> Block {
    let mut stmts = rhie_chow_main_preamble(state_stride);

    stmts.push(dsl::let_expr(
        "rho",
        dsl::max(
            Expr::ident("constants").field("density"),
            Expr::lit_f32(1e-12),
        ),
    ));
    stmts.push(dsl::let_expr(
        "dt",
        dsl::max(Expr::ident("constants").field("dt"), Expr::lit_f32(0.0)),
    ));
    stmts.push(dsl::let_expr(
        "d_p",
        Expr::ident("constants").field("alpha_u") * Expr::ident("dt") / Expr::ident("rho"),
    ));
    stmts.push(dsl::assign_expr(
        dsl::array_access("state", Expr::ident("base") + Expr::lit_u32(d_p_offset)),
        Expr::ident("d_p"),
    ));

    stmts.push(dsl::assign_expr(
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_old_x_offset),
        ),
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_p_x_offset),
        ),
    ));
    stmts.push(dsl::assign_expr(
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_old_y_offset),
        ),
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_p_y_offset),
        ),
    ));

    Block::new(stmts)
}

fn rhie_chow_correct_velocity_delta_main_fn(
    params: RhieChowCorrectVelocityDeltaParams,
) -> Function {
    Function::new(
        "main",
        main_params(),
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        rhie_chow_correct_velocity_delta_main_body(params),
    )
}

fn rhie_chow_correct_velocity_delta_main_body(params: RhieChowCorrectVelocityDeltaParams) -> Block {
    let mut stmts = rhie_chow_main_preamble(params.state_stride);

    stmts.push(dsl::let_expr(
        "d_p",
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(params.d_p_offset),
        ),
    ));
    stmts.push(dsl::let_expr(
        "grad_px",
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(params.grad_p_x_offset),
        ),
    ));
    stmts.push(dsl::let_expr(
        "grad_py",
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(params.grad_p_y_offset),
        ),
    ));
    stmts.push(dsl::let_expr(
        "grad_old_x",
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(params.grad_old_x_offset),
        ),
    ));
    stmts.push(dsl::let_expr(
        "grad_old_y",
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(params.grad_old_y_offset),
        ),
    ));

    stmts.push(dsl::comment(
        "Apply SIMPLE-style velocity correction using the change in pressure gradient:",
    ));
    stmts.push(dsl::comment("  U_new = HbyA - d_p * grad(p_new)"));
    stmts.push(dsl::comment("  U_old = HbyA - d_p * grad(p_old)"));
    stmts.push(dsl::comment(
        "=> U_new = U_old - d_p * (grad(p_new) - grad(p_old))",
    ));

    stmts.push(dsl::let_expr(
        "corr_x",
        Expr::ident("d_p") * (Expr::ident("grad_px") - Expr::ident("grad_old_x")),
    ));
    stmts.push(dsl::let_expr(
        "corr_y",
        Expr::ident("d_p") * (Expr::ident("grad_py") - Expr::ident("grad_old_y")),
    ));

    stmts.push(dsl::assign_expr(
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(params.u_x_offset),
        ),
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(params.u_x_offset),
        ) - Expr::ident("corr_x"),
    ));
    stmts.push(dsl::assign_expr(
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(params.u_y_offset),
        ),
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(params.u_y_offset),
        ) - Expr::ident("corr_y"),
    ));

    Block::new(stmts)
}

fn main_params() -> Vec<Param> {
    vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )]
}

fn rhie_chow_main_preamble(state_stride: u32) -> Vec<Stmt> {
    vec![
        dsl::let_expr(
            "idx",
            Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
                + Expr::ident("global_id").field("x"),
        ),
        dsl::let_expr(
            "num_cells",
            Expr::call_named("arrayLength", vec![Expr::ident("state").addr_of()])
                / dsl::max(Expr::lit_u32(state_stride), Expr::lit_u32(1)),
        ),
        dsl::if_block_expr(
            Expr::ident("idx").ge(Expr::ident("num_cells")),
            dsl::block(vec![Stmt::Return(None)]),
            None,
        ),
        dsl::let_expr("base", Expr::ident("idx") * Expr::lit_u32(state_stride)),
    ]
}
